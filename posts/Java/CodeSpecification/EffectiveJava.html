<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.60" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://riicarus.github.io/posts/Java/CodeSpecification/EffectiveJava.html"><meta property="og:site_name" content="Riicarus"><meta property="og:title" content="Effective Java"><meta property="og:description" content="Effective Java 本文中, 英文部分均来自于原文摘抄, 如果想要更好的理解和阅读体验, 请不要忽略英文引用! Effective Java 这本书作为 Java 编程思想和范式的"集大成者", 需要很深的 Java 编程功底. 我在阅读时也感受到很多没有了解过的东西, 尤其是读英文原著, 感觉一些部分的理解尚且非常浅薄, 尤以 Stream API 的部分为甚. 现在只是第一遍阅读这本书的原版, 只在博客中做粗略的记录和思考. 在读完第一遍之后, 会再次进行巩固和更新."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2023-11-17T18:15:44.000Z"><meta property="article:tag" content="Java"><meta property="article:tag" content="Specification"><meta property="article:tag" content="Effective Java"><meta property="article:published_time" content="2023-09-26T00:00:00.000Z"><meta property="article:modified_time" content="2023-11-17T18:15:44.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"Effective Java","image":[""],"datePublished":"2023-09-26T00:00:00.000Z","dateModified":"2023-11-17T18:15:44.000Z","author":[]}</script><link rel="icon" href="/logo.png"><title>Effective Java | Riicarus</title><meta name="description" content="Effective Java 本文中, 英文部分均来自于原文摘抄, 如果想要更好的理解和阅读体验, 请不要忽略英文引用! Effective Java 这本书作为 Java 编程思想和范式的"集大成者", 需要很深的 Java 编程功底. 我在阅读时也感受到很多没有了解过的东西, 尤其是读英文原著, 感觉一些部分的理解尚且非常浅薄, 尤以 Stream API 的部分为甚. 现在只是第一遍阅读这本书的原版, 只在博客中做粗略的记录和思考. 在读完第一遍之后, 会再次进行巩固和更新.">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-256a168b.css" as="style"><link rel="stylesheet" href="/assets/style-256a168b.css">
    <link rel="modulepreload" href="/assets/app-1db72e39.js"><link rel="modulepreload" href="/assets/framework-c6791857.js"><link rel="modulepreload" href="/assets/EffectiveJava.html-6e0970a1.js"><link rel="modulepreload" href="/assets/EffectiveJava.html-501ff0e4.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header class="navbar" id="navbar"><div class="navbar-start"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><a href="/" class="brand"><img class="logo" src="/logo.png" alt="Riicarus"><!----><span class="site-name hide-in-pad">Riicarus</span></a><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/" class="nav-link" aria-label="Riicarus&#39; Blog"><span class="font-icon icon iconfont icon-home" style=""></span>Riicarus&#39; Blog<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="Java"><span class="title"><span class="font-icon icon iconfont icon-folder" style=""></span>Java</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>JDK</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/Java/JDK/java.lang.html" class="nav-link" aria-label="Java lang 包"><span class="font-icon icon iconfont icon-file" style=""></span>Java lang 包<!----></a></li><li class="dropdown-subitem"><a href="/posts/Java/JDK/java.util.html" class="nav-link" aria-label="Java util 包"><span class="font-icon icon iconfont icon-file" style=""></span>Java util 包<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>JUC</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/Java/JUC/ThreadPool.html" class="nav-link" aria-label="线程池"><span class="font-icon icon iconfont icon-file" style=""></span>线程池<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>JVM</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/Java/JVM/JavaMemoryArea.html" class="nav-link" aria-label="Java 内存区域"><span class="font-icon icon iconfont icon-file" style=""></span>Java 内存区域<!----></a></li><li class="dropdown-subitem"><a href="/posts/Java/JVM/JavaGC.html" class="nav-link" aria-label="Java GC"><span class="font-icon icon iconfont icon-file" style=""></span>Java GC<!----></a></li><li class="dropdown-subitem"><a href="/posts/Java/JVM/ClassLoad.html" class="nav-link" aria-label="类加载机制"><span class="font-icon icon iconfont icon-file" style=""></span>类加载机制<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>代码规范</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html" class="router-link-active router-link-exact-active nav-link active" aria-label="EffectiveJava"><span class="font-icon icon iconfont icon-file" style=""></span>EffectiveJava<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="算法"><span class="title"><span class="font-icon icon iconfont icon-folder" style=""></span>算法</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>模板</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/Algorithm/Template/DataStructure/" class="nav-link" aria-label="数据结构"><span class="font-icon icon iconfont icon-folder" style=""></span>数据结构<!----></a></li><li class="dropdown-subitem"><a href="/posts/Algorithm/Template/Search/" class="nav-link" aria-label="搜索"><span class="font-icon icon iconfont icon-folder" style=""></span>搜索<!----></a></li><li class="dropdown-subitem"><a href="/posts/Algorithm/Template/DynamicProgramming/" class="nav-link" aria-label="动态规划"><span class="font-icon icon iconfont icon-folder" style=""></span>动态规划<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>置换算法</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/Algorithm/Replacement/LRU.html" class="nav-link" aria-label="LRU"><span class="font-icon icon iconfont icon-file" style=""></span>LRU<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>读谱不能</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/Algorithm/SuchDifficult/PackFruit.html" class="nav-link" aria-label="水果打包"><span class="font-icon icon iconfont icon-file" style=""></span>水果打包<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="架构设计"><span class="title"><span class="font-icon icon iconfont icon-folder" style=""></span>架构设计</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>高并发设计</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/Architecture/HighConcurrency/SpikeSystemDesign.html" class="nav-link" aria-label="秒杀系统设计"><span class="font-icon icon iconfont icon-file" style=""></span>秒杀系统设计<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>分布式</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/Architecture/DistributedSystem/DistributedSystem(MIT%206.824).html" class="nav-link" aria-label="分布式系统"><span class="font-icon icon iconfont icon-file" style=""></span>分布式系统<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="中间件"><span class="title"><span class="font-icon icon iconfont icon-folder" style=""></span>中间件</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>缓存</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/Middleware/Cache/Cache.html" class="nav-link" aria-label="缓存"><span class="font-icon icon iconfont icon-file" style=""></span>缓存<!----></a></li><li class="dropdown-subitem"><a href="/posts/Middleware/Cache/BloomFilter.html" class="nav-link" aria-label="布隆过滤器"><span class="font-icon icon iconfont icon-file" style=""></span>布隆过滤器<!----></a></li><li class="dropdown-subitem"><a href="/posts/Middleware/Cache/Lua.html" class="nav-link" aria-label="LUA"><span class="font-icon icon iconfont icon-file" style=""></span>LUA<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>消息队列</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/Middleware/MQ/MQ.html" class="nav-link" aria-label="消息队列"><span class="font-icon icon iconfont icon-file" style=""></span>消息队列<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="组件"><span class="title"><span class="font-icon icon iconfont icon-folder" style=""></span>组件</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/posts/Component/TimeWheel.html" class="nav-link" aria-label="时间轮"><span class="font-icon icon iconfont icon-file" style=""></span>时间轮<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="计算机科学"><span class="title"><span class="font-icon icon iconfont icon-folder" style=""></span>计算机科学</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>编译原理</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/ComputerScience/CompilationPrinciple/CompilationPrinciple.html" class="nav-link" aria-label="编译原理基础"><span class="font-icon icon iconfont icon-file" style=""></span>编译原理基础<!----></a></li><li class="dropdown-subitem"><a href="/posts/ComputerScience/CompilationPrinciple/CompilationPrincipleExp.html" class="nav-link" aria-label="编译原理实验"><span class="font-icon icon iconfont icon-file" style=""></span>编译原理实验<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>计算机体系结构</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/ComputerScience/ComputerArchitecture/ComputerArchitecture.html" class="nav-link" aria-label="计算机体系结构"><span class="font-icon icon iconfont icon-file" style=""></span>计算机体系结构<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>计算机网络</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/ComputerScience/ComputerNetworking/Generic.html" class="nav-link" aria-label="概述"><span class="font-icon icon iconfont icon-file" style=""></span>概述<!----></a></li><li class="dropdown-subitem"><a href="/posts/ComputerScience/ComputerNetworking/HTTP(S).html" class="nav-link" aria-label="HTTP(S)"><span class="font-icon icon iconfont icon-file" style=""></span>HTTP(S)<!----></a></li><li class="dropdown-subitem"><a href="/posts/ComputerScience/ComputerNetworking/WebSocket.html" class="nav-link" aria-label="WebSocket"><span class="font-icon icon iconfont icon-file" style=""></span>WebSocket<!----></a></li><li class="dropdown-subitem"><a href="/posts/ComputerScience/ComputerNetworking/TCP.html" class="nav-link" aria-label="TCP"><span class="font-icon icon iconfont icon-file" style=""></span>TCP<!----></a></li><li class="dropdown-subitem"><a href="/posts/ComputerScience/ComputerNetworking/UDP.html" class="nav-link" aria-label="UDP"><span class="font-icon icon iconfont icon-file" style=""></span>UDP<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>数据库</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/ComputerScience/Database/MySQL_Index.html" class="nav-link" aria-label="索引"><span class="font-icon icon iconfont icon-file" style=""></span>索引<!----></a></li><li class="dropdown-subitem"><a href="/posts/ComputerScience/Database/Transaction.html" class="nav-link" aria-label="事务"><span class="font-icon icon iconfont icon-file" style=""></span>事务<!----></a></li><li class="dropdown-subitem"><a href="/posts/ComputerScience/Database/SQL.html" class="nav-link" aria-label="SQL"><span class="font-icon icon iconfont icon-file" style=""></span>SQL<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="星辰"><span class="title"><span class="font-icon icon iconfont icon-folder" style=""></span>星辰</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/posts/StarStudio/LearningPath.html" class="nav-link" aria-label="学习路线"><span class="font-icon icon iconfont icon-file" style=""></span>学习路线<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="/posts/InterviewLog/" class="nav-link" aria-label="面经"><span class="font-icon icon iconfont icon-folder" style=""></span>面经<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="项目"><span class="title"><span class="font-icon icon iconfont icon-folder" style=""></span>项目</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>编译器</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/Project/Compiler/LangDefine.html" class="nav-link" aria-label="语言定义"><span class="font-icon icon iconfont icon-file" style=""></span>语言定义<!----></a></li></ul></li></ul></button></div></div></nav><!--[--><!----><!--]--></div><div class="navbar-end"><!--[--><!----><!--]--><!----><div class="nav-item"><a class="repo-link" href="https://github.com/Riicarus" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!----><!--[--><!----><!--]--><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar" id="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a href="/" class="nav-link sidebar-link sidebar-page" aria-label="Riicarus&#39; Blog"><span class="font-icon icon iconfont icon-home" style=""></span>Riicarus&#39; Blog<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><section class="sidebar-group"><button class="sidebar-heading clickable active"><span class="font-icon icon iconfont icon-folder" style=""></span><span class="title">文章</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><section class="sidebar-group"><button class="sidebar-heading clickable active"><span class="font-icon icon iconfont icon-folder" style=""></span><span class="title">Java</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-folder" style=""></span><span class="title">JDK</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-folder" style=""></span><span class="title">JUC</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-folder" style=""></span><span class="title">JVM</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable active"><span class="font-icon icon iconfont icon-folder" style=""></span><span class="title">代码规范</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="Effective Java"><!---->Effective Java<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#对象的创建与销毁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="对象的创建与销毁"><!---->对象的创建与销毁<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-1-使用静态工厂方法代替构造方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 1: 使用静态工厂方法代替构造方法"><!---->Item 1: 使用静态工厂方法代替构造方法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-2-使用构造器代替构造方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 2: 使用构造器代替构造方法"><!---->Item 2: 使用构造器代替构造方法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-3-强制单例构造方法私有或使用枚举类" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 3: 强制单例构造方法私有或使用枚举类"><!---->Item 3: 强制单例构造方法私有或使用枚举类<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-4-强制非实例化类的构造方法私有" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 4: 强制非实例化类的构造方法私有"><!---->Item 4: 强制非实例化类的构造方法私有<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-5-使用依赖注入替代硬性资源引用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 5: 使用依赖注入替代硬性资源引用"><!---->Item 5: 使用依赖注入替代硬性资源引用<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-6-避免创建不必要的实例" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 6: 避免创建不必要的实例"><!---->Item 6: 避免创建不必要的实例<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-7-消除过时的对象引用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 7: 消除过时的对象引用"><!---->Item 7: 消除过时的对象引用<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-8-避免使用-finalize-等方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 8: 避免使用 finalize() 等方法"><!---->Item 8: 避免使用 finalize() 等方法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-9-使用-try-with-resources-替代-try-finally" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 9: 使用 try-with-resources 替代 try-finally"><!---->Item 9: 使用 try-with-resources 替代 try-finally<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#类共有方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="类共有方法"><!---->类共有方法<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-10-遵循重写-equals-方法的共识" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 10: 遵循重写 equals() 方法的共识"><!---->Item 10: 遵循重写 equals() 方法的共识<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-11-总是同时重写-hashcode-和-equals-方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 11: 总是同时重写 hashCode() 和 equals() 方法"><!---->Item 11: 总是同时重写 hashCode() 和 equals() 方法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-12-总是重写-tostring-方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 12: 总是重写 toString() 方法"><!---->Item 12: 总是重写 toString() 方法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-13-谨慎地重写-clone-方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 13: 谨慎地重写 clone() 方法"><!---->Item 13: 谨慎地重写 clone() 方法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-14-考虑实现-comparable-接口" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 14: 考虑实现 Comparable 接口"><!---->Item 14: 考虑实现 Comparable 接口<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#类与接口" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="类与接口"><!---->类与接口<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-15-最小化类和成员可见性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 15: 最小化类和成员可见性"><!---->Item 15: 最小化类和成员可见性<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-16-在公共类中-使用访问方法-而不是公共字段" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 16: 在公共类中, 使用访问方法, 而不是公共字段"><!---->Item 16: 在公共类中, 使用访问方法, 而不是公共字段<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-17-最小化可变性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 17: 最小化可变性"><!---->Item 17: 最小化可变性<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-18-使用组合替代继承" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 18: 使用组合替代继承"><!---->Item 18: 使用组合替代继承<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-19-要么为继承做好兼容和文档化-要么禁止继承" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 19: 要么为继承做好兼容和文档化, 要么禁止继承"><!---->Item 19: 要么为继承做好兼容和文档化, 要么禁止继承<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-20-使用接口替代抽象类" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 20: 使用接口替代抽象类"><!---->Item 20: 使用接口替代抽象类<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-21-为子类设计接口" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 21: 为子类设计接口"><!---->Item 21: 为子类设计接口<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-22-只用接口来定义类型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 22: 只用接口来定义类型"><!---->Item 22: 只用接口来定义类型<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-23-使用类的层级结构代替类标签" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 23: 使用类的层级结构代替类标签"><!---->Item 23: 使用类的层级结构代替类标签<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-24-尽可能使用静态成员类" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 24: 尽可能使用静态成员类"><!---->Item 24: 尽可能使用静态成员类<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-25-一个源文件中只应该有一个主类" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 25: 一个源文件中只应该有一个主类"><!---->Item 25: 一个源文件中只应该有一个主类<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#泛型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="泛型"><!---->泛型<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-26-不要使用原始类型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 26: 不要使用原始类型"><!---->Item 26: 不要使用原始类型<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-27-排除未检查警告" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 27: 排除未检查警告"><!---->Item 27: 排除未检查警告<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-28-使用-list-替代-array" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 28: 使用 List 替代 Array"><!---->Item 28: 使用 List 替代 Array<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-29-使用泛型类" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 29: 使用泛型类"><!---->Item 29: 使用泛型类<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-30-优先使用泛型方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 30: 优先使用泛型方法"><!---->Item 30: 优先使用泛型方法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-31-使用有界通配符来提高-api-的灵活性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 31: 使用有界通配符来提高 API 的灵活性"><!---->Item 31: 使用有界通配符来提高 API 的灵活性<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-32-明智地组合泛型和可变参数" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 32: 明智地组合泛型和可变参数"><!---->Item 32: 明智地组合泛型和可变参数<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-33-使用各种类型安全的容器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 33: 使用各种类型安全的容器"><!---->Item 33: 使用各种类型安全的容器<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#枚举和注解" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="枚举和注解"><!---->枚举和注解<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-34-使用枚举而不是-int-常量" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 34: 使用枚举而不是 int 常量"><!---->Item 34: 使用枚举而不是 int 常量<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-35-使用实例字段而不是序数" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 35: 使用实例字段而不是序数"><!---->Item 35: 使用实例字段而不是序数<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-36-使用-enumset-代替位字段" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 36: 使用 EnumSet 代替位字段"><!---->Item 36: 使用 EnumSet 代替位字段<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-37-使用-enummap-而不是序数索引" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 37: 使用 EnumMap 而不是序数索引"><!---->Item 37: 使用 EnumMap 而不是序数索引<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-38-使用接口模拟可继承枚举类" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 38: 使用接口模拟可继承枚举类"><!---->Item 38: 使用接口模拟可继承枚举类<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-39-使用注解替代命名模式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 39: 使用注解替代命名模式"><!---->Item 39: 使用注解替代命名模式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-40-总是使用-override-注解" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 40: 总是使用 Override 注解"><!---->Item 40: 总是使用 Override 注解<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-41-使用标记接口来定义类型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item-41: 使用标记接口来定义类型"><!---->Item-41: 使用标记接口来定义类型<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#lambdas-与-streams" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Lambdas 与 Streams"><!---->Lambdas 与 Streams<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-42-使用-lambda-表达式替代匿名类" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 42: 使用 Lambda 表达式替代匿名类"><!---->Item 42: 使用 Lambda 表达式替代匿名类<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-43-使用方法引用替代-lambda-表达式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 43: 使用方法引用替代 Lambda 表达式"><!---->Item 43: 使用方法引用替代 Lambda 表达式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-44-使用标准的函数式接口" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 44: 使用标准的函数式接口"><!---->Item 44: 使用标准的函数式接口<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-45-明智地使用-stream-api" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 45: 明智地使用 Stream API"><!---->Item 45: 明智地使用 Stream API<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-46-在流中使用无副作用函数" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item-46: 在流中使用无副作用函数"><!---->Item-46: 在流中使用无副作用函数<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-47-使用-collection-作为-stream-api-的返回类型-而不是-stream" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 47: 使用 Collection 作为 Stream API 的返回类型, 而不是 Stream"><!---->Item 47: 使用 Collection 作为 Stream API 的返回类型, 而不是 Stream<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-48-谨慎使用并行流" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 48: 谨慎使用并行流"><!---->Item 48: 谨慎使用并行流<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="方法"><!---->方法<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-49-检查参数有效性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 49: 检查参数有效性"><!---->Item 49: 检查参数有效性<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-50-在需要时制作防御性副本" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 50: 在需要时制作防御性副本"><!---->Item 50: 在需要时制作防御性副本<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-51-仔细设计方法签名" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 51: 仔细设计方法签名"><!---->Item 51: 仔细设计方法签名<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-52-谨慎重载方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 52: 谨慎重载方法"><!---->Item 52: 谨慎重载方法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-53-谨慎使用可变参数" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 53: 谨慎使用可变参数"><!---->Item 53: 谨慎使用可变参数<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-54-返回空集合或数组-而不是-null-对象" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 54: 返回空集合或数组, 而不是 null 对象"><!---->Item 54: 返回空集合或数组, 而不是 null 对象<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-55-谨慎返回-optional-对象" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 55: 谨慎返回 Optional 对象"><!---->Item 55: 谨慎返回 Optional 对象<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-56-为所有暴露的-api-中的元素编写文档注释" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 56: 为所有暴露的 API 中的元素编写文档注释"><!---->Item 56: 为所有暴露的 API 中的元素编写文档注释<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#通用编程事项" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="通用编程事项"><!---->通用编程事项<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-57-最小化局部变量的作用域" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 57: 最小化局部变量的作用域"><!---->Item 57: 最小化局部变量的作用域<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-58-使用-for-each-代替-for-循环" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 58: 使用 for-each 代替 for 循环"><!---->Item 58: 使用 for-each 代替 for 循环<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-59-了解并使用库" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 59: 了解并使用库"><!---->Item 59: 了解并使用库<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-60-不要在需要精确结果的地方使用-float-或-double" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 60: 不要在需要精确结果的地方使用 float 或 double"><!---->Item 60: 不要在需要精确结果的地方使用 float 或 double<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-61-使用原始类型而不是装箱类型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 61: 使用原始类型而不是装箱类型"><!---->Item 61: 使用原始类型而不是装箱类型<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-62-避免在其他类型更合适时使用-string" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 62: 避免在其他类型更合适时使用 String"><!---->Item 62: 避免在其他类型更合适时使用 String<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-63-注意-string-拼接的性能消耗" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 63: 注意 String 拼接的性能消耗"><!---->Item 63: 注意 String 拼接的性能消耗<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-64-通过接口引用对象" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 64: 通过接口引用对象"><!---->Item 64: 通过接口引用对象<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-65-使用接口代替反射" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 65: 使用接口代替反射"><!---->Item 65: 使用接口代替反射<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-66-谨慎使用-native-方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 66: 谨慎使用 native 方法"><!---->Item 66: 谨慎使用 native 方法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-67-谨慎地进行优化" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 67: 谨慎地进行优化"><!---->Item 67: 谨慎地进行优化<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-68-遵守普遍接受的命名约定" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 68: 遵守普遍接受的命名约定"><!---->Item 68: 遵守普遍接受的命名约定<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#异常" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="异常"><!---->异常<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-69-只在异常情况下使用异常" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 69: 只在异常情况下使用异常"><!---->Item 69: 只在异常情况下使用异常<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-70-可恢复环境使用受检异常-程序错误使用运行时异常" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 70: 可恢复环境使用受检异常, 程序错误使用运行时异常"><!---->Item 70: 可恢复环境使用受检异常, 程序错误使用运行时异常<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-71-避免不必要地使用受检异常" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 71: 避免不必要地使用受检异常"><!---->Item 71: 避免不必要地使用受检异常<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-72-尽量使用标准异常" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 72: 尽量使用标准异常"><!---->Item 72: 尽量使用标准异常<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-73-抛出符合抽象层级的异常" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 73: 抛出符合抽象层级的异常"><!---->Item 73: 抛出符合抽象层级的异常<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-74-文档化每个方法抛出的所有异常" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 74: 文档化每个方法抛出的所有异常"><!---->Item 74: 文档化每个方法抛出的所有异常<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-75-在详细信息中包含故障捕获信息" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 75: 在详细信息中包含故障捕获信息"><!---->Item 75: 在详细信息中包含故障捕获信息<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-76-尽力保证故障原子性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 76: 尽力保证故障原子性"><!---->Item 76: 尽力保证故障原子性<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-77-不要忽略异常" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 77: 不要忽略异常"><!---->Item 77: 不要忽略异常<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#并发" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="并发"><!---->并发<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-78-并行化对共享可变对象的访问操作" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 78: 并行化对共享可变对象的访问操作"><!---->Item 78: 并行化对共享可变对象的访问操作<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-79-避免过度同步" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 79: 避免过度同步"><!---->Item 79: 避免过度同步<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-80-使用线程池-任务池和流替代线程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 80: 使用线程池, 任务池和流替代线程"><!---->Item 80: 使用线程池, 任务池和流替代线程<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-81-使用并发工具代替-wait-和-notify" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 81: 使用并发工具代替 wait 和 notify"><!---->Item 81: 使用并发工具代替 wait 和 notify<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-82-文档化线程安全情况" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 82: 文档化线程安全情况"><!---->Item 82: 文档化线程安全情况<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-83-谨慎使用懒加载" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 83: 谨慎使用懒加载"><!---->Item 83: 谨慎使用懒加载<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-84-不要依靠线程调度器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 84: 不要依靠线程调度器"><!---->Item 84: 不要依靠线程调度器<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#序列化" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="序列化"><!---->序列化<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-85-优先使用-java-序列化的替代方案" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 85: 优先使用 Java 序列化的替代方案"><!---->Item 85: 优先使用 Java 序列化的替代方案<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-86-谨慎实现-serializable-接口" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 86: 谨慎实现 Serializable 接口"><!---->Item 86: 谨慎实现 Serializable 接口<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-87-使用自定义序列化格式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 87: 使用自定义序列化格式"><!---->Item 87: 使用自定义序列化格式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-88-防御性地编写-readobject-方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 88: 防御性地编写 readObject 方法"><!---->Item 88: 防御性地编写 readObject 方法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-89-优先使用枚举类型进行实例控制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 89: 优先使用枚举类型进行实例控制"><!---->Item 89: 优先使用枚举类型进行实例控制<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-90-考虑序列化代理而不是序列化实例" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Item 90: 考虑序列化代理而不是序列化实例"><!---->Item 90: 考虑序列化代理而不是序列化实例<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#结语" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="结语"><!---->结语<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li></ul></section></li></ul></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-folder" style=""></span><span class="title">算法</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-folder" style=""></span><span class="title">架构设计</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-folder" style=""></span><span class="title">中间件</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-folder" style=""></span><span class="title">组件</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-folder" style=""></span><span class="title">计算机科学</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-folder" style=""></span><span class="title">星辰</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-folder" style=""></span><span class="title">项目</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-folder" style=""></span><span class="title">面经</span><span class="arrow right"></span></button><!----></section></li></ul></section></li><li><!--[--><a href="/intro.html" class="nav-link sidebar-link sidebar-page" aria-label="关于"><span class="font-icon icon iconfont icon-info" style=""></span>关于<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->Effective Java</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://github.com/Riicarus" target="_blank" rel="noopener noreferrer">Riicarus</a></span><span property="author" content="Riicarus"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-09-26T00:00:00.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 152 分钟</span><meta property="timeRequired" content="PT152M"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><span class="page-category-item category4 clickable" role="navigation">Java</span><span class="page-category-item category3 clickable" role="navigation">Specification</span><meta property="articleSection" content="Java,Specification"></span><span class="page-tag-info" aria-label="标签🏷" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="tag icon"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><span class="page-tag-item tag4 clickable" role="navigation">Java</span><span class="page-tag-item tag3 clickable" role="navigation">Specification</span><span class="page-tag-item tag2 clickable" role="navigation">Effective Java</span><meta property="keywords" content="Java,Specification,Effective Java"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容<button class="print-button" title="print"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#对象的创建与销毁" class="router-link-active router-link-exact-active toc-link level2">对象的创建与销毁</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-1-使用静态工厂方法代替构造方法" class="router-link-active router-link-exact-active toc-link level3">Item 1: 使用静态工厂方法代替构造方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-2-使用构造器代替构造方法" class="router-link-active router-link-exact-active toc-link level3">Item 2: 使用构造器代替构造方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-3-强制单例构造方法私有或使用枚举类" class="router-link-active router-link-exact-active toc-link level3">Item 3: 强制单例构造方法私有或使用枚举类</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-4-强制非实例化类的构造方法私有" class="router-link-active router-link-exact-active toc-link level3">Item 4: 强制非实例化类的构造方法私有</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-5-使用依赖注入替代硬性资源引用" class="router-link-active router-link-exact-active toc-link level3">Item 5: 使用依赖注入替代硬性资源引用</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-6-避免创建不必要的实例" class="router-link-active router-link-exact-active toc-link level3">Item 6: 避免创建不必要的实例</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-7-消除过时的对象引用" class="router-link-active router-link-exact-active toc-link level3">Item 7: 消除过时的对象引用</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-8-避免使用-finalize-等方法" class="router-link-active router-link-exact-active toc-link level3">Item 8: 避免使用 finalize() 等方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-9-使用-try-with-resources-替代-try-finally" class="router-link-active router-link-exact-active toc-link level3">Item 9: 使用 try-with-resources 替代 try-finally</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#类共有方法" class="router-link-active router-link-exact-active toc-link level2">类共有方法</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-10-遵循重写-equals-方法的共识" class="router-link-active router-link-exact-active toc-link level3">Item 10: 遵循重写 equals() 方法的共识</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-11-总是同时重写-hashcode-和-equals-方法" class="router-link-active router-link-exact-active toc-link level3">Item 11: 总是同时重写 hashCode() 和 equals() 方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-12-总是重写-tostring-方法" class="router-link-active router-link-exact-active toc-link level3">Item 12: 总是重写 toString() 方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-13-谨慎地重写-clone-方法" class="router-link-active router-link-exact-active toc-link level3">Item 13: 谨慎地重写 clone() 方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-14-考虑实现-comparable-接口" class="router-link-active router-link-exact-active toc-link level3">Item 14: 考虑实现 Comparable 接口</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#类与接口" class="router-link-active router-link-exact-active toc-link level2">类与接口</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-15-最小化类和成员可见性" class="router-link-active router-link-exact-active toc-link level3">Item 15: 最小化类和成员可见性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-16-在公共类中-使用访问方法-而不是公共字段" class="router-link-active router-link-exact-active toc-link level3">Item 16: 在公共类中, 使用访问方法, 而不是公共字段</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-17-最小化可变性" class="router-link-active router-link-exact-active toc-link level3">Item 17: 最小化可变性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-18-使用组合替代继承" class="router-link-active router-link-exact-active toc-link level3">Item 18: 使用组合替代继承</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-19-要么为继承做好兼容和文档化-要么禁止继承" class="router-link-active router-link-exact-active toc-link level3">Item 19: 要么为继承做好兼容和文档化, 要么禁止继承</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-20-使用接口替代抽象类" class="router-link-active router-link-exact-active toc-link level3">Item 20: 使用接口替代抽象类</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-21-为子类设计接口" class="router-link-active router-link-exact-active toc-link level3">Item 21: 为子类设计接口</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-22-只用接口来定义类型" class="router-link-active router-link-exact-active toc-link level3">Item 22: 只用接口来定义类型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-23-使用类的层级结构代替类标签" class="router-link-active router-link-exact-active toc-link level3">Item 23: 使用类的层级结构代替类标签</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-24-尽可能使用静态成员类" class="router-link-active router-link-exact-active toc-link level3">Item 24: 尽可能使用静态成员类</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-25-一个源文件中只应该有一个主类" class="router-link-active router-link-exact-active toc-link level3">Item 25: 一个源文件中只应该有一个主类</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#泛型" class="router-link-active router-link-exact-active toc-link level2">泛型</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-26-不要使用原始类型" class="router-link-active router-link-exact-active toc-link level3">Item 26: 不要使用原始类型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-27-排除未检查警告" class="router-link-active router-link-exact-active toc-link level3">Item 27: 排除未检查警告</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-28-使用-list-替代-array" class="router-link-active router-link-exact-active toc-link level3">Item 28: 使用 List 替代 Array</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-29-使用泛型类" class="router-link-active router-link-exact-active toc-link level3">Item 29: 使用泛型类</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-30-优先使用泛型方法" class="router-link-active router-link-exact-active toc-link level3">Item 30: 优先使用泛型方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-31-使用有界通配符来提高-api-的灵活性" class="router-link-active router-link-exact-active toc-link level3">Item 31: 使用有界通配符来提高 API 的灵活性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-32-明智地组合泛型和可变参数" class="router-link-active router-link-exact-active toc-link level3">Item 32: 明智地组合泛型和可变参数</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-33-使用各种类型安全的容器" class="router-link-active router-link-exact-active toc-link level3">Item 33: 使用各种类型安全的容器</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#枚举和注解" class="router-link-active router-link-exact-active toc-link level2">枚举和注解</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-34-使用枚举而不是-int-常量" class="router-link-active router-link-exact-active toc-link level3">Item 34: 使用枚举而不是 int 常量</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-35-使用实例字段而不是序数" class="router-link-active router-link-exact-active toc-link level3">Item 35: 使用实例字段而不是序数</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-36-使用-enumset-代替位字段" class="router-link-active router-link-exact-active toc-link level3">Item 36: 使用 EnumSet 代替位字段</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-37-使用-enummap-而不是序数索引" class="router-link-active router-link-exact-active toc-link level3">Item 37: 使用 EnumMap 而不是序数索引</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-38-使用接口模拟可继承枚举类" class="router-link-active router-link-exact-active toc-link level3">Item 38: 使用接口模拟可继承枚举类</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-39-使用注解替代命名模式" class="router-link-active router-link-exact-active toc-link level3">Item 39: 使用注解替代命名模式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-40-总是使用-override-注解" class="router-link-active router-link-exact-active toc-link level3">Item 40: 总是使用 Override 注解</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-41-使用标记接口来定义类型" class="router-link-active router-link-exact-active toc-link level3">Item-41: 使用标记接口来定义类型</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#lambdas-与-streams" class="router-link-active router-link-exact-active toc-link level2">Lambdas 与 Streams</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-42-使用-lambda-表达式替代匿名类" class="router-link-active router-link-exact-active toc-link level3">Item 42: 使用 Lambda 表达式替代匿名类</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-43-使用方法引用替代-lambda-表达式" class="router-link-active router-link-exact-active toc-link level3">Item 43: 使用方法引用替代 Lambda 表达式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-44-使用标准的函数式接口" class="router-link-active router-link-exact-active toc-link level3">Item 44: 使用标准的函数式接口</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-45-明智地使用-stream-api" class="router-link-active router-link-exact-active toc-link level3">Item 45: 明智地使用 Stream API</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-46-在流中使用无副作用函数" class="router-link-active router-link-exact-active toc-link level3">Item-46: 在流中使用无副作用函数</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-47-使用-collection-作为-stream-api-的返回类型-而不是-stream" class="router-link-active router-link-exact-active toc-link level3">Item 47: 使用 Collection 作为 Stream API 的返回类型, 而不是 Stream</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-48-谨慎使用并行流" class="router-link-active router-link-exact-active toc-link level3">Item 48: 谨慎使用并行流</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#方法" class="router-link-active router-link-exact-active toc-link level2">方法</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-49-检查参数有效性" class="router-link-active router-link-exact-active toc-link level3">Item 49: 检查参数有效性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-50-在需要时制作防御性副本" class="router-link-active router-link-exact-active toc-link level3">Item 50: 在需要时制作防御性副本</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-51-仔细设计方法签名" class="router-link-active router-link-exact-active toc-link level3">Item 51: 仔细设计方法签名</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-52-谨慎重载方法" class="router-link-active router-link-exact-active toc-link level3">Item 52: 谨慎重载方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-53-谨慎使用可变参数" class="router-link-active router-link-exact-active toc-link level3">Item 53: 谨慎使用可变参数</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-54-返回空集合或数组-而不是-null-对象" class="router-link-active router-link-exact-active toc-link level3">Item 54: 返回空集合或数组, 而不是 null 对象</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-55-谨慎返回-optional-对象" class="router-link-active router-link-exact-active toc-link level3">Item 55: 谨慎返回 Optional 对象</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-56-为所有暴露的-api-中的元素编写文档注释" class="router-link-active router-link-exact-active toc-link level3">Item 56: 为所有暴露的 API 中的元素编写文档注释</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#通用编程事项" class="router-link-active router-link-exact-active toc-link level2">通用编程事项</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-57-最小化局部变量的作用域" class="router-link-active router-link-exact-active toc-link level3">Item 57: 最小化局部变量的作用域</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-58-使用-for-each-代替-for-循环" class="router-link-active router-link-exact-active toc-link level3">Item 58: 使用 for-each 代替 for 循环</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-59-了解并使用库" class="router-link-active router-link-exact-active toc-link level3">Item 59: 了解并使用库</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-60-不要在需要精确结果的地方使用-float-或-double" class="router-link-active router-link-exact-active toc-link level3">Item 60: 不要在需要精确结果的地方使用 float 或 double</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-61-使用原始类型而不是装箱类型" class="router-link-active router-link-exact-active toc-link level3">Item 61: 使用原始类型而不是装箱类型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-62-避免在其他类型更合适时使用-string" class="router-link-active router-link-exact-active toc-link level3">Item 62: 避免在其他类型更合适时使用 String</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-63-注意-string-拼接的性能消耗" class="router-link-active router-link-exact-active toc-link level3">Item 63: 注意 String 拼接的性能消耗</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-64-通过接口引用对象" class="router-link-active router-link-exact-active toc-link level3">Item 64: 通过接口引用对象</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-65-使用接口代替反射" class="router-link-active router-link-exact-active toc-link level3">Item 65: 使用接口代替反射</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-66-谨慎使用-native-方法" class="router-link-active router-link-exact-active toc-link level3">Item 66: 谨慎使用 native 方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-67-谨慎地进行优化" class="router-link-active router-link-exact-active toc-link level3">Item 67: 谨慎地进行优化</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-68-遵守普遍接受的命名约定" class="router-link-active router-link-exact-active toc-link level3">Item 68: 遵守普遍接受的命名约定</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#异常" class="router-link-active router-link-exact-active toc-link level2">异常</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-69-只在异常情况下使用异常" class="router-link-active router-link-exact-active toc-link level3">Item 69: 只在异常情况下使用异常</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-70-可恢复环境使用受检异常-程序错误使用运行时异常" class="router-link-active router-link-exact-active toc-link level3">Item 70: 可恢复环境使用受检异常, 程序错误使用运行时异常</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-71-避免不必要地使用受检异常" class="router-link-active router-link-exact-active toc-link level3">Item 71: 避免不必要地使用受检异常</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-72-尽量使用标准异常" class="router-link-active router-link-exact-active toc-link level3">Item 72: 尽量使用标准异常</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-73-抛出符合抽象层级的异常" class="router-link-active router-link-exact-active toc-link level3">Item 73: 抛出符合抽象层级的异常</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-74-文档化每个方法抛出的所有异常" class="router-link-active router-link-exact-active toc-link level3">Item 74: 文档化每个方法抛出的所有异常</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-75-在详细信息中包含故障捕获信息" class="router-link-active router-link-exact-active toc-link level3">Item 75: 在详细信息中包含故障捕获信息</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-76-尽力保证故障原子性" class="router-link-active router-link-exact-active toc-link level3">Item 76: 尽力保证故障原子性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-77-不要忽略异常" class="router-link-active router-link-exact-active toc-link level3">Item 77: 不要忽略异常</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#并发" class="router-link-active router-link-exact-active toc-link level2">并发</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-78-并行化对共享可变对象的访问操作" class="router-link-active router-link-exact-active toc-link level3">Item 78: 并行化对共享可变对象的访问操作</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-79-避免过度同步" class="router-link-active router-link-exact-active toc-link level3">Item 79: 避免过度同步</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-80-使用线程池-任务池和流替代线程" class="router-link-active router-link-exact-active toc-link level3">Item 80: 使用线程池, 任务池和流替代线程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-81-使用并发工具代替-wait-和-notify" class="router-link-active router-link-exact-active toc-link level3">Item 81: 使用并发工具代替 wait 和 notify</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-82-文档化线程安全情况" class="router-link-active router-link-exact-active toc-link level3">Item 82: 文档化线程安全情况</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-83-谨慎使用懒加载" class="router-link-active router-link-exact-active toc-link level3">Item 83: 谨慎使用懒加载</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-84-不要依靠线程调度器" class="router-link-active router-link-exact-active toc-link level3">Item 84: 不要依靠线程调度器</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#序列化" class="router-link-active router-link-exact-active toc-link level2">序列化</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-85-优先使用-java-序列化的替代方案" class="router-link-active router-link-exact-active toc-link level3">Item 85: 优先使用 Java 序列化的替代方案</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-86-谨慎实现-serializable-接口" class="router-link-active router-link-exact-active toc-link level3">Item 86: 谨慎实现 Serializable 接口</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-87-使用自定义序列化格式" class="router-link-active router-link-exact-active toc-link level3">Item 87: 使用自定义序列化格式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-88-防御性地编写-readobject-方法" class="router-link-active router-link-exact-active toc-link level3">Item 88: 防御性地编写 readObject 方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-89-优先使用枚举类型进行实例控制" class="router-link-active router-link-exact-active toc-link level3">Item 89: 优先使用枚举类型进行实例控制</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#item-90-考虑序列化代理而不是序列化实例" class="router-link-active router-link-exact-active toc-link level3">Item 90: 考虑序列化代理而不是序列化实例</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Java/CodeSpecification/EffectiveJava.html#结语" class="router-link-active router-link-exact-active toc-link level2">结语</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="effective-java" tabindex="-1"><a class="header-anchor" href="#effective-java" aria-hidden="true">#</a> Effective Java</h1><p><strong>本文中, 英文部分均来自于原文摘抄, 如果想要更好的理解和阅读体验, 请不要忽略英文引用!</strong></p><p><em>Effective Java</em> 这本书作为 Java 编程思想和范式的&quot;集大成者&quot;, 需要很深的 Java 编程功底. 我在阅读时也感受到很多没有了解过的东西, 尤其是读英文原著, 感觉一些部分的理解尚且非常浅薄, 尤以 Stream API 的部分为甚.</p><p>现在只是第一遍阅读这本书的原版, 只在博客中做粗略的记录和思考. 在读完第一遍之后, 会再次进行巩固和更新.</p><p>预期阅读计划:</p><ol><li>英文原版第一遍(<em>current process</em>).</li><li>中文译版对照阅读.</li><li>英文原版第二遍.</li></ol><ul><li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%94%80%E6%AF%81">对象的创建与销毁</a><ul><li><a href="#item-1-%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E4%BB%A3%E6%9B%BF%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">Item 1: 使用静态工厂方法代替构造方法</a><ul><li><a href="#%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0">可以自定义方法名称</a></li><li><a href="#%E4%B8%8D%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E6%96%B0%E5%AF%B9%E8%B1%A1">不需要创建新对象</a></li><li><a href="#%E5%8F%AF%E4%BB%A5%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%AD%90%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B">可以返回类及其子类的实例</a></li><li><a href="#%E5%8F%AF%E4%BB%A5%E6%A0%B9%E6%8D%AE%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0%E8%BF%94%E5%9B%9E%E4%B8%8D%E5%90%8C%E7%9A%84%E7%B1%BB%E5%9E%8B">可以根据输入参数返回不同的类型</a></li><li><a href="#%E8%BF%94%E5%9B%9E%E7%9A%84%E7%B1%BB%E5%8F%AF%E4%BB%A5%E4%B8%8D%E5%AD%98%E5%9C%A8">返回的类可以不存在</a></li><li><a href="#%E5%8F%AA%E6%9C%89%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%9A%84%E7%B1%BB%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%BB%A7%E6%89%BF">只有静态工厂方法的类不能被继承</a></li><li><a href="#%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%9A%84-api-%E4%B8%8D%E6%98%93%E5%AF%BB%E6%89%BE">静态工厂方法的 API 不易寻找</a></li><li><a href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95">常见的静态工厂方法</a></li></ul></li><li><a href="#item-2-%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E4%BB%A3%E6%9B%BF%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">Item 2: 使用构造器代替构造方法</a></li><li><a href="#item-3-%E5%BC%BA%E5%88%B6%E5%8D%95%E4%BE%8B%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%A7%81%E6%9C%89%E6%88%96%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E7%B1%BB">Item 3: 强制单例构造方法私有或使用枚举类</a></li><li><a href="#item-4-%E5%BC%BA%E5%88%B6%E9%9D%9E%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%A7%81%E6%9C%89">Item 4: 强制非实例化类的构造方法私有</a></li><li><a href="#item-5-%E4%BD%BF%E7%94%A8%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%9B%BF%E4%BB%A3%E7%A1%AC%E6%80%A7%E8%B5%84%E6%BA%90%E5%BC%95%E7%94%A8">Item 5: 使用依赖注入替代硬性资源引用</a></li><li><a href="#item-6-%E9%81%BF%E5%85%8D%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%AE%9E%E4%BE%8B">Item 6: 避免创建不必要的实例</a></li><li><a href="#item-7-%E6%B6%88%E9%99%A4%E8%BF%87%E6%97%B6%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">Item 7: 消除过时的对象引用</a></li><li><a href="#item-8-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8-finalize-%E7%AD%89%E6%96%B9%E6%B3%95">Item 8: 避免使用 finalize() 等方法</a></li><li><a href="#item-9-%E4%BD%BF%E7%94%A8-try-with-resources-%E6%9B%BF%E4%BB%A3-try-finally">Item 9: 使用 try-with-resources 替代 try-finally</a></li></ul></li><li><a href="#%E7%B1%BB%E5%85%B1%E6%9C%89%E6%96%B9%E6%B3%95">类共有方法</a><ul><li><a href="#item-10-%E9%81%B5%E5%BE%AA%E9%87%8D%E5%86%99-equals-%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B1%E8%AF%86">Item 10: 遵循重写 equals() 方法的共识</a></li><li><a href="#item-11-%E6%80%BB%E6%98%AF%E5%90%8C%E6%97%B6%E9%87%8D%E5%86%99-hashcode-%E5%92%8C-equals-%E6%96%B9%E6%B3%95">Item 11: 总是同时重写 hashCode() 和 equals() 方法</a></li><li><a href="#item-12-%E6%80%BB%E6%98%AF%E9%87%8D%E5%86%99-tostring-%E6%96%B9%E6%B3%95">Item 12: 总是重写 toString() 方法</a></li><li><a href="#item-13-%E8%B0%A8%E6%85%8E%E5%9C%B0%E9%87%8D%E5%86%99-clone-%E6%96%B9%E6%B3%95">Item 13: 谨慎地重写 clone() 方法</a></li><li><a href="#item-14-%E8%80%83%E8%99%91%E5%AE%9E%E7%8E%B0-comparable-%E6%8E%A5%E5%8F%A3">Item 14: 考虑实现 Comparable 接口</a></li></ul></li><li><a href="#%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3">类与接口</a><ul><li><a href="#item-15-%E6%9C%80%E5%B0%8F%E5%8C%96%E7%B1%BB%E5%92%8C%E6%88%90%E5%91%98%E5%8F%AF%E8%A7%81%E6%80%A7">Item 15: 最小化类和成员可见性</a></li><li><a href="#item-16-%E5%9C%A8%E5%85%AC%E5%85%B1%E7%B1%BB%E4%B8%AD-%E4%BD%BF%E7%94%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95-%E8%80%8C%E4%B8%8D%E6%98%AF%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5">Item 16: 在公共类中, 使用访问方法, 而不是公共字段</a></li><li><a href="#item-17-%E6%9C%80%E5%B0%8F%E5%8C%96%E5%8F%AF%E5%8F%98%E6%80%A7">Item 17: 最小化可变性</a></li><li><a href="#item-18-%E4%BD%BF%E7%94%A8%E7%BB%84%E5%90%88%E6%9B%BF%E4%BB%A3%E7%BB%A7%E6%89%BF">Item 18: 使用组合替代继承</a></li><li><a href="#item-19-%E8%A6%81%E4%B9%88%E4%B8%BA%E7%BB%A7%E6%89%BF%E5%81%9A%E5%A5%BD%E5%85%BC%E5%AE%B9%E5%92%8C%E6%96%87%E6%A1%A3%E5%8C%96-%E8%A6%81%E4%B9%88%E7%A6%81%E6%AD%A2%E7%BB%A7%E6%89%BF">Item 19: 要么为继承做好兼容和文档化, 要么禁止继承</a></li><li><a href="#item-20-%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%9B%BF%E4%BB%A3%E6%8A%BD%E8%B1%A1%E7%B1%BB">Item 20: 使用接口替代抽象类</a></li><li><a href="#item-21-%E4%B8%BA%E5%AD%90%E7%B1%BB%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3">Item 21: 为子类设计接口</a></li><li><a href="#item-22-%E5%8F%AA%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%9D%A5%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B">Item 22: 只用接口来定义类型</a></li><li><a href="#item-23-%E4%BD%BF%E7%94%A8%E7%B1%BB%E7%9A%84%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E4%BB%A3%E6%9B%BF%E7%B1%BB%E6%A0%87%E7%AD%BE">Item 23: 使用类的层级结构代替类标签</a></li><li><a href="#item-24-%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%B1%BB">Item 24: 尽可能使用静态成员类</a><ul><li><a href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%B1%BB">静态成员类</a></li><li><a href="#%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%B1%BB">非静态成员类</a></li><li><a href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB">匿名内部类</a></li><li><a href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB">局部内部类</a></li></ul></li><li><a href="#item-25-%E4%B8%80%E4%B8%AA%E6%BA%90%E6%96%87%E4%BB%B6%E4%B8%AD%E5%8F%AA%E5%BA%94%E8%AF%A5%E6%9C%89%E4%B8%80%E4%B8%AA%E4%B8%BB%E7%B1%BB">Item 25: 一个源文件中只应该有一个主类</a></li></ul></li><li><a href="#%E6%B3%9B%E5%9E%8B">泛型</a><ul><li><a href="#item-26-%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B">Item 26: 不要使用原始类型</a></li><li><a href="#item-27-%E6%8E%92%E9%99%A4%E6%9C%AA%E6%A3%80%E6%9F%A5%E8%AD%A6%E5%91%8A">Item 27: 排除未检查警告</a></li><li><a href="#item-28-%E4%BD%BF%E7%94%A8-list-%E6%9B%BF%E4%BB%A3-array">Item 28: 使用 List 替代 Array</a><ul><li><a href="#%E6%95%B0%E7%BB%84%E6%98%AF%E5%8D%8F%E5%8F%98%E7%9A%84-%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%B8%8D%E5%8F%98%E7%9A%84">数组是协变的, 泛型类型是不变的</a></li><li><a href="#%E6%95%B0%E7%BB%84%E6%98%AF%E5%85%B7%E4%BD%93%E5%8C%96%E7%9A%84">数组是具体化的</a></li></ul></li><li><a href="#item-29-%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%B1%BB">Item 29: 使用泛型类</a></li><li><a href="#item-30-%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95">Item 30: 优先使用泛型方法</a></li><li><a href="#item-31-%E4%BD%BF%E7%94%A8%E6%9C%89%E7%95%8C%E9%80%9A%E9%85%8D%E7%AC%A6%E6%9D%A5%E6%8F%90%E9%AB%98-api-%E7%9A%84%E7%81%B5%E6%B4%BB%E6%80%A7">Item 31: 使用有界通配符来提高 API 的灵活性</a></li><li><a href="#item-32-%E6%98%8E%E6%99%BA%E5%9C%B0%E7%BB%84%E5%90%88%E6%B3%9B%E5%9E%8B%E5%92%8C%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0">Item 32: 明智地组合泛型和可变参数</a><ul><li><a href="#%E6%80%BB%E7%BB%93-32">总结-32</a></li></ul></li><li><a href="#item-33-%E4%BD%BF%E7%94%A8%E5%90%84%E7%A7%8D%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%B9%E5%99%A8">Item 33: 使用各种类型安全的容器</a><ul><li><a href="#%E6%80%BB%E7%BB%93-33">总结-33</a></li></ul></li></ul></li><li><a href="#%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3">枚举和注解</a><ul><li><a href="#item-34-%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E8%80%8C%E4%B8%8D%E6%98%AF-int-%E5%B8%B8%E9%87%8F">Item 34: 使用枚举而不是 int 常量</a><ul><li><a href="#%E6%80%BB%E7%BB%93-34">总结-34</a></li></ul></li><li><a href="#item-35-%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B%E5%AD%97%E6%AE%B5%E8%80%8C%E4%B8%8D%E6%98%AF%E5%BA%8F%E6%95%B0">Item 35: 使用实例字段而不是序数</a><ul><li><a href="#%E6%80%BB%E7%BB%93-35">总结-35</a></li></ul></li><li><a href="#item-36-%E4%BD%BF%E7%94%A8-enumset-%E4%BB%A3%E6%9B%BF%E4%BD%8D%E5%AD%97%E6%AE%B5">Item 36: 使用 EnumSet 代替位字段</a><ul><li><a href="#%E6%80%BB%E7%BB%93-36">总结-36</a></li></ul></li><li><a href="#item-37-%E4%BD%BF%E7%94%A8-enummap-%E8%80%8C%E4%B8%8D%E6%98%AF%E5%BA%8F%E6%95%B0%E7%B4%A2%E5%BC%95">Item 37: 使用 EnumMap 而不是序数索引</a><ul><li><a href="#%E6%80%BB%E7%BB%93-37">总结-37</a></li></ul></li><li><a href="#item-38-%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%A8%A1%E6%8B%9F%E5%8F%AF%E7%BB%A7%E6%89%BF%E6%9E%9A%E4%B8%BE%E7%B1%BB">Item 38: 使用接口模拟可继承枚举类</a><ul><li><a href="#%E6%80%BB%E7%BB%93-38">总结-38</a></li></ul></li><li><a href="#item-39-%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%9B%BF%E4%BB%A3%E5%91%BD%E5%90%8D%E6%A8%A1%E5%BC%8F">Item 39: 使用注解替代命名模式</a><ul><li><a href="#%E6%80%BB%E7%BB%93-39">总结-39</a></li></ul></li><li><a href="#item-40-%E6%80%BB%E6%98%AF%E4%BD%BF%E7%94%A8-override-%E6%B3%A8%E8%A7%A3">Item 40: 总是使用 Override 注解</a><ul><li><a href="#%E6%80%BB%E7%BB%93-40">总结-40</a></li></ul></li><li><a href="#item-41-%E4%BD%BF%E7%94%A8%E6%A0%87%E8%AE%B0%E6%8E%A5%E5%8F%A3%E6%9D%A5%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B">Item-41: 使用标记接口来定义类型</a><ul><li><a href="#%E6%80%BB%E7%BB%93-41">总结-41</a></li></ul></li></ul></li><li><a href="#lambdas-%E4%B8%8E-streams">Lambdas 与 Streams</a><ul><li><a href="#item-42-%E4%BD%BF%E7%94%A8-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9B%BF%E4%BB%A3%E5%8C%BF%E5%90%8D%E7%B1%BB">Item 42: 使用 Lambda 表达式替代匿名类</a><ul><li><a href="#%E6%80%BB%E7%BB%93-42">总结-42</a></li></ul></li><li><a href="#item-43-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E6%9B%BF%E4%BB%A3-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F">Item 43: 使用方法引用替代 Lambda 表达式</a><ul><li><a href="#%E6%80%BB%E7%BB%93-43">总结-43</a></li></ul></li><li><a href="#item-44-%E4%BD%BF%E7%94%A8%E6%A0%87%E5%87%86%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3">Item 44: 使用标准的函数式接口</a><ul><li><a href="#%E6%80%BB%E7%BB%93-44">总结-44</a></li></ul></li><li><a href="#item-45-%E6%98%8E%E6%99%BA%E5%9C%B0%E4%BD%BF%E7%94%A8-stream-api">Item 45: 明智地使用 Stream API</a><ul><li><a href="#%E6%80%BB%E7%BB%93-45">总结-45</a></li></ul></li><li><a href="#item-46-%E5%9C%A8%E6%B5%81%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%97%A0%E5%89%AF%E4%BD%9C%E7%94%A8%E5%87%BD%E6%95%B0">Item-46: 在流中使用无副作用函数</a><ul><li><a href="#%E6%80%BB%E7%BB%93-46">总结-46</a></li></ul></li><li><a href="#item-47-%E4%BD%BF%E7%94%A8-collection-%E4%BD%9C%E4%B8%BA-stream-api-%E7%9A%84%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B-%E8%80%8C%E4%B8%8D%E6%98%AF-stream">Item 47: 使用 Collection 作为 Stream API 的返回类型, 而不是 Stream</a><ul><li><a href="#%E6%80%BB%E7%BB%93-47">总结-47</a></li></ul></li><li><a href="#item-48-%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8%E5%B9%B6%E8%A1%8C%E6%B5%81">Item 48: 谨慎使用并行流</a><ul><li><a href="#%E6%80%BB%E7%BB%93-48">总结-48</a></li></ul></li></ul></li><li><a href="#%E6%96%B9%E6%B3%95">方法</a><ul><li><a href="#item-49-%E6%A3%80%E6%9F%A5%E5%8F%82%E6%95%B0%E6%9C%89%E6%95%88%E6%80%A7">Item 49: 检查参数有效性</a><ul><li><a href="#%E6%80%BB%E7%BB%93-49">总结-49</a></li></ul></li><li><a href="#item-50-%E5%9C%A8%E9%9C%80%E8%A6%81%E6%97%B6%E5%88%B6%E4%BD%9C%E9%98%B2%E5%BE%A1%E6%80%A7%E5%89%AF%E6%9C%AC">Item 50: 在需要时制作防御性副本</a><ul><li><a href="#%E6%80%BB%E7%BB%93-50">总结-50</a></li></ul></li><li><a href="#item-51-%E4%BB%94%E7%BB%86%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E7%AD%BE%E5%90%8D">Item 51: 仔细设计方法签名</a><ul><li><a href="#%E6%80%BB%E7%BB%93-51">总结-51</a></li></ul></li><li><a href="#item-52-%E8%B0%A8%E6%85%8E%E9%87%8D%E8%BD%BD%E6%96%B9%E6%B3%95">Item 52: 谨慎重载方法</a><ul><li><a href="#%E6%80%BB%E7%BB%93-52">总结-52</a></li></ul></li><li><a href="#item-53-%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0">Item 53: 谨慎使用可变参数</a><ul><li><a href="#%E6%80%BB%E7%BB%93-53">总结-53</a></li></ul></li><li><a href="#item-54-%E8%BF%94%E5%9B%9E%E7%A9%BA%E9%9B%86%E5%90%88%E6%88%96%E6%95%B0%E7%BB%84-%E8%80%8C%E4%B8%8D%E6%98%AF-null-%E5%AF%B9%E8%B1%A1">Item 54: 返回空集合或数组, 而不是 null 对象</a><ul><li><a href="#%E6%80%BB%E7%BB%93-54">总结-54</a></li></ul></li><li><a href="#item-55-%E8%B0%A8%E6%85%8E%E8%BF%94%E5%9B%9E-optional-%E5%AF%B9%E8%B1%A1">Item 55: 谨慎返回 Optional 对象</a><ul><li><a href="#%E6%80%BB%E7%BB%93-55">总结-55</a></li></ul></li><li><a href="#item-56-%E4%B8%BA%E6%89%80%E6%9C%89%E6%9A%B4%E9%9C%B2%E7%9A%84-api-%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E7%BC%96%E5%86%99%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A">Item 56: 为所有暴露的 API 中的元素编写文档注释</a><ul><li><a href="#%E6%80%BB%E7%BB%93-56">总结-56</a></li></ul></li></ul></li><li><a href="#%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E4%BA%8B%E9%A1%B9">通用编程事项</a><ul><li><a href="#item-57-%E6%9C%80%E5%B0%8F%E5%8C%96%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F">Item 57: 最小化局部变量的作用域</a></li><li><a href="#item-58-%E4%BD%BF%E7%94%A8-for-each-%E4%BB%A3%E6%9B%BF-for-%E5%BE%AA%E7%8E%AF">Item 58: 使用 for-each 代替 for 循环</a></li><li><a href="#item-59-%E4%BA%86%E8%A7%A3%E5%B9%B6%E4%BD%BF%E7%94%A8%E5%BA%93">Item 59: 了解并使用库</a></li><li><a href="#item-60-%E4%B8%8D%E8%A6%81%E5%9C%A8%E9%9C%80%E8%A6%81%E7%B2%BE%E7%A1%AE%E7%BB%93%E6%9E%9C%E7%9A%84%E5%9C%B0%E6%96%B9%E4%BD%BF%E7%94%A8-float-%E6%88%96-double">Item 60: 不要在需要精确结果的地方使用 float 或 double</a></li><li><a href="#item-61-%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E8%80%8C%E4%B8%8D%E6%98%AF%E8%A3%85%E7%AE%B1%E7%B1%BB%E5%9E%8B">Item 61: 使用原始类型而不是装箱类型</a></li><li><a href="#item-62-%E9%81%BF%E5%85%8D%E5%9C%A8%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E6%9B%B4%E5%90%88%E9%80%82%E6%97%B6%E4%BD%BF%E7%94%A8-string">Item 62: 避免在其他类型更合适时使用 String</a></li><li><a href="#item-63-%E6%B3%A8%E6%84%8F-string-%E6%8B%BC%E6%8E%A5%E7%9A%84%E6%80%A7%E8%83%BD%E6%B6%88%E8%80%97">Item 63: 注意 String 拼接的性能消耗</a></li><li><a href="#item-64-%E9%80%9A%E8%BF%87%E6%8E%A5%E5%8F%A3%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1">Item 64: 通过接口引用对象</a></li><li><a href="#item-65-%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E4%BB%A3%E6%9B%BF%E5%8F%8D%E5%B0%84">Item 65: 使用接口代替反射</a></li><li><a href="#item-66-%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8-native-%E6%96%B9%E6%B3%95">Item 66: 谨慎使用 native 方法</a></li><li><a href="#item-67-%E8%B0%A8%E6%85%8E%E5%9C%B0%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96">Item 67: 谨慎地进行优化</a></li><li><a href="#item-68-%E9%81%B5%E5%AE%88%E6%99%AE%E9%81%8D%E6%8E%A5%E5%8F%97%E7%9A%84%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A">Item 68: 遵守普遍接受的命名约定</a></li></ul></li><li><a href="#%E5%BC%82%E5%B8%B8">异常</a><ul><li><a href="#item-69-%E5%8F%AA%E5%9C%A8%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5%E4%B8%8B%E4%BD%BF%E7%94%A8%E5%BC%82%E5%B8%B8">Item 69: 只在异常情况下使用异常</a></li><li><a href="#item-70-%E5%8F%AF%E6%81%A2%E5%A4%8D%E7%8E%AF%E5%A2%83%E4%BD%BF%E7%94%A8%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8-%E7%A8%8B%E5%BA%8F%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8">Item 70: 可恢复环境使用受检异常, 程序错误使用运行时异常</a></li><li><a href="#item-71-%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8">Item 71: 避免不必要地使用受检异常</a></li><li><a href="#item-72-%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E6%A0%87%E5%87%86%E5%BC%82%E5%B8%B8">Item 72: 尽量使用标准异常</a></li><li><a href="#item-73-%E6%8A%9B%E5%87%BA%E7%AC%A6%E5%90%88%E6%8A%BD%E8%B1%A1%E5%B1%82%E7%BA%A7%E7%9A%84%E5%BC%82%E5%B8%B8">Item 73: 抛出符合抽象层级的异常</a></li><li><a href="#item-74-%E6%96%87%E6%A1%A3%E5%8C%96%E6%AF%8F%E4%B8%AA%E6%96%B9%E6%B3%95%E6%8A%9B%E5%87%BA%E7%9A%84%E6%89%80%E6%9C%89%E5%BC%82%E5%B8%B8">Item 74: 文档化每个方法抛出的所有异常</a></li><li><a href="#item-75-%E5%9C%A8%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF%E4%B8%AD%E5%8C%85%E5%90%AB%E6%95%85%E9%9A%9C%E6%8D%95%E8%8E%B7%E4%BF%A1%E6%81%AF">Item 75: 在详细信息中包含故障捕获信息</a></li><li><a href="#item-76-%E5%B0%BD%E5%8A%9B%E4%BF%9D%E8%AF%81%E6%95%85%E9%9A%9C%E5%8E%9F%E5%AD%90%E6%80%A7">Item 76: 尽力保证故障原子性</a></li><li><a href="#item-77-%E4%B8%8D%E8%A6%81%E5%BF%BD%E7%95%A5%E5%BC%82%E5%B8%B8">Item 77: 不要忽略异常</a></li></ul></li><li><a href="#%E5%B9%B6%E5%8F%91">并发</a><ul><li><a href="#item-78-%E5%B9%B6%E8%A1%8C%E5%8C%96%E5%AF%B9%E5%85%B1%E4%BA%AB%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C">Item 78: 并行化对共享可变对象的访问操作</a></li><li><a href="#item-79-%E9%81%BF%E5%85%8D%E8%BF%87%E5%BA%A6%E5%90%8C%E6%AD%A5">Item 79: 避免过度同步</a></li><li><a href="#item-80-%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E4%BB%BB%E5%8A%A1%E6%B1%A0%E5%92%8C%E6%B5%81%E6%9B%BF%E4%BB%A3%E7%BA%BF%E7%A8%8B">Item 80: 使用线程池, 任务池和流替代线程</a></li><li><a href="#item-81-%E4%BD%BF%E7%94%A8%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E4%BB%A3%E6%9B%BF-wait-%E5%92%8C-notify">Item 81: 使用并发工具代替 wait 和 notify</a></li><li><a href="#item-82-%E6%96%87%E6%A1%A3%E5%8C%96%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%83%85%E5%86%B5">Item 82: 文档化线程安全情况</a></li><li><a href="#item-83-%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8%E6%87%92%E5%8A%A0%E8%BD%BD">Item 83: 谨慎使用懒加载</a></li><li><a href="#item-84-%E4%B8%8D%E8%A6%81%E4%BE%9D%E9%9D%A0%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8">Item 84: 不要依靠线程调度器</a></li></ul></li><li><a href="#%E5%BA%8F%E5%88%97%E5%8C%96">序列化</a><ul><li><a href="#item-85-%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8-java-%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88">Item 85: 优先使用 Java 序列化的替代方案</a></li><li><a href="#item-86-%E8%B0%A8%E6%85%8E%E5%AE%9E%E7%8E%B0-serializable-%E6%8E%A5%E5%8F%A3">Item 86: 谨慎实现 Serializable 接口</a></li><li><a href="#item-87-%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96%E6%A0%BC%E5%BC%8F">Item 87: 使用自定义序列化格式</a></li><li><a href="#item-88-%E9%98%B2%E5%BE%A1%E6%80%A7%E5%9C%B0%E7%BC%96%E5%86%99-readobject-%E6%96%B9%E6%B3%95">Item 88: 防御性地编写 readObject 方法</a></li><li><a href="#item-89-%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8C%E5%AE%9E%E4%BE%8B%E6%8E%A7%E5%88%B6">Item 89: 优先使用枚举类型进行实例控制</a></li><li><a href="#item-90-%E8%80%83%E8%99%91%E5%BA%8F%E5%88%97%E5%8C%96%E4%BB%A3%E7%90%86%E8%80%8C%E4%B8%8D%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%9E%E4%BE%8B">Item 90: 考虑序列化代理而不是序列化实例</a></li></ul></li><li><a href="#%E7%BB%93%E8%AF%AD">结语</a></li></ul><h2 id="对象的创建与销毁" tabindex="-1"><a class="header-anchor" href="#对象的创建与销毁" aria-hidden="true">#</a> 对象的创建与销毁</h2><blockquote><p>Creating and Destroying Objects.</p></blockquote><h3 id="item-1-使用静态工厂方法代替构造方法" tabindex="-1"><a class="header-anchor" href="#item-1-使用静态工厂方法代替构造方法" aria-hidden="true">#</a> Item 1: 使用静态工厂方法代替构造方法</h3><blockquote><p>Consider static factory methods instead of constructors.</p></blockquote><p>此处的静态工厂方法与设计模式中的静态工厂方法不同, 指的是使用类的静态方法来创建类实例, 而不是使用类构造器.</p><p>例:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// static factory method</span>
<span class="token class-name">String</span> hello <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// constructor</span>
<span class="token class-name">String</span> hello <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>通常, 在使用静态工厂方法时, 需要将类构造方法设置为 <code>private</code>.</strong></p><p>静态工厂方法相较于类构造方法, 主要优点在于它具有<strong>更高的灵活性</strong>:</p><h4 id="可以自定义方法名称" tabindex="-1"><a class="header-anchor" href="#可以自定义方法名称" aria-hidden="true">#</a> 可以自定义方法名称</h4><blockquote><p>One advantage of static factory methods is that, unlike constructors, they have names.</p></blockquote><p>构造方法只能使用类名作为方法名, 但是静态工厂方法可以根据方法的内部逻辑来表现出不同的命名, 如: <code>String.valueOf()</code>, <code>List.of()</code>, <code>Collections.lit()</code>. 可以通过命名来更好地展示(区分)方法的作用, 细分构造出类实例的类型.</p><h4 id="不需要创建新对象" tabindex="-1"><a class="header-anchor" href="#不需要创建新对象" aria-hidden="true">#</a> 不需要创建新对象</h4><blockquote><p>A second advantage of static factory methods is that, unlike constructors, they are not required to create a new object each time they&#39;re invoked.</p></blockquote><p>构造方法每次返回一个新的类实例, 但是很多时候我们希望一个类是单例的, 或者说类实例可以复用, 来减少创建消耗. 静态工厂方法可以自定义地返回类实例, 对已创建的实例进行复用.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> <span class="token constant">SINGLETON</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token constant">SINGLETON</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="可以返回类及其子类的实例" tabindex="-1"><a class="header-anchor" href="#可以返回类及其子类的实例" aria-hidden="true">#</a> 可以返回类及其子类的实例</h4><blockquote><p>A third advantage of static factory methods is that, unlike constructors, they can return object of any subtype of their return type.</p></blockquote><p>构造方法只能返回对应类的实例, 但是静态工厂方法可以返回类及其子类的实例. 返回类型更加灵活. 如: <code>Collections.list()</code>, 返回的是一个 <code>List</code> 的子类的实例.</p><h4 id="可以根据输入参数返回不同的类型" tabindex="-1"><a class="header-anchor" href="#可以根据输入参数返回不同的类型" aria-hidden="true">#</a> 可以根据输入参数返回不同的类型</h4><blockquote><p>A forth advantage of static factories is that the class of the returned object can vary from call to call as a function of the input parameters.</p></blockquote><p>静态工厂方法可以根据输入参数的不同, 来返回不同类型的实例. 如: <code>EnumSet</code> 根据输入的枚举类的常量的数量, 来返回不同类型的子类.</p><p>和 Redis 的底层实现略有类似, Redis hash 会根据存储的数据的类型和数量, 在两种存储数据结构(<code>ziplist</code>/<code>hashtable</code>)中进行选择.</p><h4 id="返回的类可以不存在" tabindex="-1"><a class="header-anchor" href="#返回的类可以不存在" aria-hidden="true">#</a> 返回的类可以不存在</h4><blockquote><p>A fifth advantage of static factories is that the class of the returned object need not exist when the class containing the method is written.</p></blockquote><p>Java 中有很多的情况, 以 Java SPI 和 RPC 最为经典. 比如 JDBC 中, 获取到的数据库驱动(Driver)是由下游厂家实现的, 在 JDBC 中并不存在对应的类.</p><h4 id="只有静态工厂方法的类不能被继承" tabindex="-1"><a class="header-anchor" href="#只有静态工厂方法的类不能被继承" aria-hidden="true">#</a> 只有静态工厂方法的类不能被继承</h4><blockquote><p>The main limitation of providing only static factory methods is that classes without public or protected constructors cannot be subclassed.</p></blockquote><p>类构造方法被设置为了 <code>private</code>, 子类无法通过 <code>super()</code> 调用父类的构造方法, 导致无法继承.</p><p>但是, 这更好的驱动开发者去使用<strong>组合替代继承</strong>的设计策略, 这是一个良好的设计方法.</p><h4 id="静态工厂方法的-api-不易寻找" tabindex="-1"><a class="header-anchor" href="#静态工厂方法的-api-不易寻找" aria-hidden="true">#</a> 静态工厂方法的 API 不易寻找</h4><blockquote><p>A second shortcoming of static factory methods is that they are hard for programmers to find.</p></blockquote><p>静态工厂方法不像类构造方法那样有固定的名称, 正式由于其很灵活, 才导致需要使用者主动去寻找其提供的 API.</p><p>所以说, 一个良好的项目流程中, 文档的编写和维护一定是非常重要的.</p><h4 id="常见的静态工厂方法" tabindex="-1"><a class="header-anchor" href="#常见的静态工厂方法" aria-hidden="true">#</a> 常见的静态工厂方法</h4><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Date</span><span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Array</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="item-2-使用构造器代替构造方法" tabindex="-1"><a class="header-anchor" href="#item-2-使用构造器代替构造方法" aria-hidden="true">#</a> Item 2: 使用构造器代替构造方法</h3><blockquote><p>Consider a builder when faced with many constructor parameters.</p></blockquote><p>当一个类的构造方法中含有过多的参数时, 构造方法就变得很复杂而且难以读写(或者使用很多的 <code>setter</code> 方法). 这时候, 我们堆外提供一个类构造器来选择性地传入参数构造对应的类实例.</p><p>构造器通常和静态工厂方法配合使用, 可以获得更好的效果.</p><blockquote><p>The Builder pattern is a good choice when designing classes whose constructors or static factories would have more than a handful of parameters, especially if many of the parameters are optional or of identical type.</p></blockquote><p>例:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Pizza</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Topping</span> <span class="token punctuation">{</span> <span class="token constant">HAM</span><span class="token punctuation">,</span> <span class="token constant">MUSHROOM</span><span class="token punctuation">,</span> <span class="token constant">ONION</span><span class="token punctuation">,</span> <span class="token constant">PEPPER</span><span class="token punctuation">,</span> <span class="token constant">SAUSAGE</span> <span class="token punctuation">}</span>

    <span class="token keyword">final</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Topping</span><span class="token punctuation">&gt;</span></span> toppings<span class="token punctuation">;</span>

    <span class="token comment">// 这里使用了循环泛型参数, 参见 Item 30</span>
    <span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Builder</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Builder</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
        <span class="token class-name">EnumSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Topping</span><span class="token punctuation">&gt;</span></span> toppings <span class="token operator">=</span> <span class="token class-name">EnumSet</span><span class="token punctuation">.</span><span class="token function">noneOf</span><span class="token punctuation">(</span><span class="token class-name">Topping</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">addTopping</span><span class="token punctuation">(</span><span class="token class-name">Topping</span> topping<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            toppings<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>topping<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">abstract</span> <span class="token class-name">Pizza</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 注意这里, 让子类的构造器可以返回自己, 而不是只能返回父类型.</span>
        <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token class-name">T</span> <span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token class-name">Pizza</span><span class="token punctuation">(</span><span class="token class-name">Builder</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> builder<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        toppings <span class="token operator">=</span> builder<span class="token punctuation">.</span>toppings<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里写一个子类:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">MyPizza</span> <span class="token keyword">extends</span> <span class="token class-name">Pizza</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Size</span> <span class="token punctuation">{</span> <span class="token constant">SMALL</span><span class="token punctuation">,</span> <span class="token constant">MEDIUM</span><span class="token punctuation">,</span> <span class="token constant">LARGE</span> <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Size</span> size<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Builder</span> <span class="token keyword">extends</span> <span class="token class-name">Pizza<span class="token punctuation">.</span>Builder</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Builder</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Size</span> size<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token class-name">Builder</span><span class="token punctuation">(</span><span class="token class-name">Size</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 这里更改了返回的类型为 MyPizza</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token class-name">MyPizza</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyPizza</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">protected</span> <span class="token class-name">Builder</span> <span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 注意这里不暴露类构造方法</span>
    <span class="token keyword">private</span> <span class="token class-name">MyPizza</span><span class="token punctuation">(</span><span class="token class-name">Builder</span> builder<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span>
        size <span class="token operator">=</span> builder<span class="token punctuation">.</span>size<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="item-3-强制单例构造方法私有或使用枚举类" tabindex="-1"><a class="header-anchor" href="#item-3-强制单例构造方法私有或使用枚举类" aria-hidden="true">#</a> Item 3: 强制单例构造方法私有或使用枚举类</h3><blockquote><p>Enforce the singleton property with a private constructor or an enum type.</p></blockquote><p>这在 Item 1 中也有简略说明, 即需要限制构造器的使用来保证该类有且只有一个单例. 单例的保证通常由类加载机制(枚举类/饿汉式单例)或者双重检查锁定来实现.</p><p>这里以较为复杂的懒汉式单例举例, 为防止因为被反射机制调用而产生多个实例, 可以设置构造方法调用时抛出异常:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">Singleton</span> <span class="token constant">SINGLETON</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">SINGLETON</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalInvokeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">SINGLETON</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">SINGLETON</span><span class="token punctuation">;</span>

        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 双重检查锁定.</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">SINGLETON</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token constant">SINGLETON</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> <span class="token constant">SINGLETON</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>建议将 <code>SINGLETON</code> 单例设置为 <code>private</code>, 限制通过 <code>getInstance()</code> 方法获取, 以此来掩盖内部实现. 同时, <code>getInstance()</code> 是一个良好的 <code>Supplier&lt;Singleton&gt;</code> 方法, 可以很好的应用于函数式编程工作. 当然, 如果你不需要这两个考虑因素, 那么设置为 <code>public</code> 也是可以的.</p><h3 id="item-4-强制非实例化类的构造方法私有" tabindex="-1"><a class="header-anchor" href="#item-4-强制非实例化类的构造方法私有" aria-hidden="true">#</a> Item 4: 强制非实例化类的构造方法私有</h3><blockquote><p>Enforce noninstantiability with a private constructor.</p></blockquote><p>通常地, 工具类提供的 API 都是静态方法, 不需要进行任何类实例. 此时, 需要将类地构造方法私有化. 可以在 JDK 中找到很多例子, 如: <code>java.util.Arrays</code>, <code>java.util.Collections</code>.</p><h3 id="item-5-使用依赖注入替代硬性资源引用" tabindex="-1"><a class="header-anchor" href="#item-5-使用依赖注入替代硬性资源引用" aria-hidden="true">#</a> Item 5: 使用依赖注入替代硬性资源引用</h3><blockquote><p>Prefer dependency injection to hardwiring resources.</p></blockquote><p>其实依赖注入(DI)在开发中很常见, 通过 <code>setter</code>/<code>constructor</code> 传入依赖的参数都属于依赖注入. 依赖注入相较于将依赖写死更具有灵活性, 也易于扩展.</p><p>同时, 依赖注入的方式很好的适配了函数式编程, 依赖可以通过 <code>Supplier&lt;?&gt;</code> 的方式通过函数来传递.</p><p>Spring 中大量使用的 IOC 就是很好的例子(IOC 使用了 DI 的思想, 是 DI 的一种实现方式).</p><h3 id="item-6-避免创建不必要的实例" tabindex="-1"><a class="header-anchor" href="#item-6-避免创建不必要的实例" aria-hidden="true">#</a> Item 6: 避免创建不必要的实例</h3><blockquote><p>Avoid creating unnecessary objects.</p></blockquote><p>内存是宝贵的, GC 带来的性能消耗让人烦恼. 我们更希望去重用已经创建的对象, 来节省堆/方法区的内存使用.</p><p>非常经典的, JVM 对 <code>String</code> 进行了非常多的优化, 使得很多的 <code>String</code> 对象在常量池中有一份实例, 我们应该尽可能去使用已经存在的实例, 而不是去新建.</p><p>例:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 这会在常量池保存一份 &quot;hello&quot; 的基础上, 在堆中额外创建一个 String 对象, 消耗额外的内存.</span>
<span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// DON&quot;T DO THIS</span>

<span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在开发中使用越是频繁的实例, 我们就就越应该想办法对其进行重用, 否则会导致很多不必要的性能开销.</p><p>这也可以通过使用静态工厂方法的方式来实现.</p><blockquote><p>You can often avoid creating unnecessary objects by using static factory methods(<a href="#item-1-%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E4%BB%A3%E6%9B%BF%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">Item 1</a>) in preference to constructors on immutable classes that provide both.</p></blockquote><p>在 Java 中, 还有一些会隐式产生对象的地方--自动装箱. 自动装箱会导致产生很多不必要的对象, 产生很高的性能损耗.</p><blockquote><p>Autoboxing blurs but does not erase the distinction between primitive and boxed primitive types.</p></blockquote><p>如:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Long</span> sum <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span>
    <span class="token comment">// 这会产生大约 2e31 个不必要的 Long 对象!!!</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们将上述的 <code>Long sum</code> 改为 <code>long sum</code>, 运行时间会从越 6s 降低至约 600 ms(数据来源: Effective Java).</p><blockquote><p>Prefer primitives to boxed primitives, and watch out for unintentional autoboxing.</p></blockquote><h3 id="item-7-消除过时的对象引用" tabindex="-1"><a class="header-anchor" href="#item-7-消除过时的对象引用" aria-hidden="true">#</a> Item 7: 消除过时的对象引用</h3><blockquote><p>Eliminate obsolete object references.</p></blockquote><p>不要觉得 Java 有自动垃圾回收机制, 就可以不用去关注对象的状态. 垃圾收集器并不能覆盖到所有的对象需要被回收的情况, 这时候需要我们手动将对象引用释放, 使得垃圾回收器能够对其进行回收.</p><p>非常经典的情况有两个:</p><ol><li><code>ThreadLocal</code> 中弱引用的使用和释放 <code>Entry</code> 的时机.</li><li><code>Stack</code> 栈收缩时释放元素的时机.</li></ol><p><code>ThreadLocalMap</code> 中, <code>Entry&lt;ThreadLocal, V&gt;</code> 是一个弱引用, 便于 <code>Entry</code> 不再使用时, GC 能够自动收集 <code>V</code> 对象. 但是, <code>ThreadLocal</code> 是一个强引用对象, 无法被收集, 所以需要使用 <code>ThreadLocal.remove()</code> 方法, 将 <code>ThreadLocal</code> 对应的 <code>Entry&lt;ThreadLocal, V&gt;</code> 的键/值都设置为 <code>null</code>.</p><p>对于 <code>Stack</code>, 我们用一个简单的例子(实现)来看:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyStack</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span> <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">MyStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        elements <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">Object</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">ensureCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        elements<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">EmptyStackException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> elements<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>elements<span class="token punctuation">.</span>length <span class="token operator">==</span> size<span class="token punctuation">)</span> elements <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> size <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意, 我们在 <code>pop()</code> 之后没有处理弹出元素在 <code>elements[]</code> 中的引用, GC 无法收集对应的对象, 可能导致 <code>OutOfMemoryError</code>.</p><p>因此可以做如下优化:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">EmptyStackException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">Object</span> result <span class="token operator">=</span> elements<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 擦除过时引用</span>
    elements<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>Nulling out object references should be the exception rather than the norm.</p><p>Whenever a class manages its own memory, the programmer should be alert for memory leaks.</p></blockquote><p>可能出现内存泄漏的情况还有:</p><ol><li>缓存. 开发者很容易忘记将缓存中不需要的/失效的对象引用释放. 可以通过使用 <code>WeakHashMap</code> 或者设置过期时间来解决.</li><li>监听器和回调函数. 已注册的监听器和回调函数没有被及时释放引用, 同样可以使用 <code>WeakHashMap</code> 来解决.</li></ol><blockquote><p><code>WeakHashMap</code>: 其 <code>Entry</code> 维持了指向 <code>Key</code> 的弱引用, 不会阻止 GC 对 <code>Key</code> 的回收.</p></blockquote><h3 id="item-8-避免使用-finalize-等方法" tabindex="-1"><a class="header-anchor" href="#item-8-避免使用-finalize-等方法" aria-hidden="true">#</a> Item 8: 避免使用 finalize() 等方法</h3><blockquote><p>Avoid finalizers and cleaners.</p></blockquote><p><code>Object#finalize()</code> 方法的执行结果是不确定的(可能会延迟执行, 也可能根本不执行), 这一点在 JavaGC 中讲解的很明确. 因此, 不应该将其作为一个可预期的功能/执行方式来使用, 尤其是对执行时机有要求的任务.</p><p>同时, <code>Object#finalize()</code> 方法的实现随虚拟机的不同可能不同, 更加不能保证在不同平台/环境上有让人安心的效果.</p><blockquote><p>Finalizers are unpredictable, often dangerous, and generally unnecessary.</p><p>Cleaner is the replacement of finalizer. Cleaners are less dangerous than finalizers, but still unpredictable, slow and generally unnecessary.</p><p>Never do anything time-critical in a finalizer or cleaner.</p><p>Never depend on a finalizer or cleaner to update persistent state as it may not be executed at all.</p></blockquote><p>但是, 有时候 <code>Object#finalize()</code> 方法是有用的--防止 <code>finalizer</code> 攻击.</p><p>如果我们想要在外界调用构造方法时抛出异常, 来阻止对象的创建. 但是如果一个类(通过反序列化等方式)实现了 <code>Object#finalize()</code> 方法, 那么其可能被执行, 然后造成一些预期之外的结果. 对此, 我们可以主动重写一个空的 <code>Object#finalize()</code> 方法, 使其不做任何事.</p><p>如果想要一个类/资源在使用结束后能够自动释放, 我们可以使用 <code>try-with-resources</code>, <code>try-finally</code> 或者实现 <code>AutoCloseable</code> 接口.</p><h3 id="item-9-使用-try-with-resources-替代-try-finally" tabindex="-1"><a class="header-anchor" href="#item-9-使用-try-with-resources-替代-try-finally" aria-hidden="true">#</a> Item 9: 使用 try-with-resources 替代 try-finally</h3><blockquote><p>Prefer try-with-resources to try-finally.</p></blockquote><p>对于实现了 <code>AutoCloseable</code> 接口的资源, 使用 <code>try-with-resources</code> 的方式更好, 它可以自动去释放资源, 而不需要在 <code>finally</code> 语句块中手动关闭.</p><h2 id="类共有方法" tabindex="-1"><a class="header-anchor" href="#类共有方法" aria-hidden="true">#</a> 类共有方法</h2><blockquote><p>Methods Common to All Objects.</p></blockquote><p>所有的类都继承自 <code>Object</code> 类, 它也为其子类提供了一系列通用的可重写的方法, 使得子类可以根据自身情况去重写这些方法, 来达到预期的目的. 比如, <code>HashMap</code> 中需要使用的 <code>Object#hashcode()</code> 和 <code>Object#equals()</code> 方法.</p><p>下面, 我们将讨论什么时候重写以及如何去重写这些共有方法, 当然, <code>Object#finalize()</code> 方法除外(详情见 <a href="#item-8-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8-finalize-%E7%AD%89%E6%96%B9%E6%B3%95">Item 8</a>). 我们还会给出一些也很通用的, 但是不属于 <code>Object</code> 类的方法, 如: <code>Comparable#compareTo()</code> 方法.</p><h3 id="item-10-遵循重写-equals-方法的共识" tabindex="-1"><a class="header-anchor" href="#item-10-遵循重写-equals-方法的共识" aria-hidden="true">#</a> Item 10: 遵循重写 equals() 方法的共识</h3><blockquote><p>Obey the general contract when overriding equals().</p></blockquote><p>当我们遇到以下情况时, <strong>不</strong>需要重写 <code>equals()</code> 方法:</p><ol><li>任何实例都是互异的.</li><li>该类不需要提供<strong>逻辑相等</strong>这个特性.</li><li>父类已经重写了 <code>equals()</code> 方法, 并且其行为与当前类相符.</li><li>该类被 <code>private</code> 或者 <code>default</code> 修饰, 并且确定不会使用到 <code>equals()</code> 方法.</li></ol><p>在重写 <code>equals()</code> 方法时, 需要注意保证以下几点离散数学中的知识:</p><ol><li>自反性(Reflexive): 如果 <code>x != null</code>, 那么 <code>x.equals(x) == true</code>.</li><li>对称性(Symmetric): 如果 <code>x != null &amp;&amp; y != null</code>, <code>x.equals(y) == true</code>, 那么 <code>y.equals(x) == true</code>.</li><li>传递性(Transitive): 如果 <code>x != null &amp;&amp; y != null &amp;&amp; z != null</code>, <code>x.equals(y) == true &amp;&amp; y.equals(z) == true</code>, 那么 <code>x.equals(z) == true</code>.</li><li>持久性(Consistent): 如果 <code>x != null &amp;&amp; y != null</code>, <code>x.equals(y)</code> 无论执行多少次, 结果应该一致.</li><li>任何 <code>x != null</code>, <code>x.equals(null)</code> 一定返回 <code>false</code>.</li></ol><p>但是这在重写时是很难完全兼顾的. 尤其是传递性, 因为我们可能比较的是父类的不同子类实例, 不同实例需要比较的内容不同, 导致无法做到上面的特性.</p><blockquote><p>There&#39;s no way to extend an instantiable class and add a value component while preserving the equals contract, unless you&#39;re willing to forgo the benefits of object-oriented abstraction.</p></blockquote><p>还有很重要的一点, <code>equals()</code> 方法中, 不要依赖不可靠对象(经常变动的)进行相等的判断.</p><blockquote><p>Whether or not a class is immutable, Do not write an equals method that depends on unreliable resources.</p></blockquote><p>以下是写好一个 <code>equals()</code> 方法的关键:</p><ol><li>使用 <code>==</code> 来判断两个对象的引用是否相同.</li><li>使用 <code>instanceof</code> 来判断参数类型是否正确.</li><li>将参数转换为正确的类型.</li><li>对每个&quot;标志&quot;属性, 检查是否相等.</li></ol><h3 id="item-11-总是同时重写-hashcode-和-equals-方法" tabindex="-1"><a class="header-anchor" href="#item-11-总是同时重写-hashcode-和-equals-方法" aria-hidden="true">#</a> Item 11: 总是同时重写 hashCode() 和 equals() 方法</h3><blockquote><p>Always(You must) override <code>hashCode()</code> when you override <code>equals()</code>.</p></blockquote><p>如果不能重写 <code>hashCode()</code> 方法, 那么必须要保证 <code>equals()</code> 的对象的 <code>hashCode()</code> 一定相同.</p><blockquote><p>The key provision is that is violated when you fail to override hashCode is the second one: equals objects must have equal hash codes.</p></blockquote><p>不要为了提高性能而忽略 <code>hashCode()</code> 中重要属性的计算.</p><blockquote><p>Do not be tempted to exclude significant fields from the hash code computation to improve performance.</p></blockquote><h3 id="item-12-总是重写-tostring-方法" tabindex="-1"><a class="header-anchor" href="#item-12-总是重写-tostring-方法" aria-hidden="true">#</a> Item 12: 总是重写 toString() 方法</h3><blockquote><p>Always override toString().</p></blockquote><p><code>toString()</code> 方法默认返回的是 <code>ClassName@hashcode</code> 的格式, 这并不便于让我们理解一个对象到底有什么内容. 所以推荐所有的类都重写 <code>toString()</code> 方法.</p><blockquote><p>Providing a good <code>toString()</code> implementation makes your class much more pleasant to use and makes systems using the class easier to debug.</p></blockquote><p>在重写 <code>toString()</code> 时, 选择输出哪些属性呢? 答案是输出我们想要的属性即可.</p><blockquote><p>When practical, the <code>toString()</code> method should return all of the interesting information contained in the object.</p></blockquote><p>同时, 我们最好注意以下 <code>toString()</code> 的输出格式, 尽量做到有过一个固定的标准格式, 并且不会引起歧义. 通过这样的方式我们可以很好的增加输出的可读性, 甚至可以通过反序列化的方式从输出恢复一个对象(通常会同时提供静态方法或者工厂方法来实现这一功能). 这一点在<strong>值类型</strong>的对象中更加重要.</p><p>同时, 注意在方法的文档中进行相关的说明.</p><blockquote><p>One important decision you&#39;ll have to make when implementing a <code>toString()</code> method is whether to specify the format of the return value in the documentation. It is recommended that you do this for <em>value classes</em>.</p></blockquote><p>那么我们可以使用哪些输出格式呢? 这里举一些例子:</p><ol><li>JSON</li><li>XML/YAML...(Marking Languages)</li><li>标准化日期格式.</li><li>Manually</li></ol><p>手动的话, 可以看一下 IDEA 的推荐格式:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ToStringClass</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> email<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;ToStringClass{&quot;</span> <span class="token operator">+</span>
                <span class="token string">&quot;id=&quot;</span> <span class="token operator">+</span> id <span class="token operator">+</span>
                <span class="token string">&quot;, name=&#39;&quot;</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token char">&#39;\&#39;&#39;</span> <span class="token operator">+</span>
                <span class="token string">&quot;, email=&#39;&quot;</span> <span class="token operator">+</span> email <span class="token operator">+</span> <span class="token char">&#39;\&#39;&#39;</span> <span class="token operator">+</span>
                <span class="token char">&#39;}&#39;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="item-13-谨慎地重写-clone-方法" tabindex="-1"><a class="header-anchor" href="#item-13-谨慎地重写-clone-方法" aria-hidden="true">#</a> Item 13: 谨慎地重写 clone() 方法</h3><blockquote><p>Override clone() judiciously.</p></blockquote><p>Java 的 <code>Cloneable</code> 接口处在一个很尬尴的位置--<code>Cloneable</code> 本身不提供任何的方法, 只是作为一种接口标志. 真正的 <code>clone()</code> 方法是由 <code>Object#clone()</code> 定义的. 因此, 即使一个类实现了 <code>Cloneable</code> 接口, 也不能保证能调用其 <code>clone()</code> 方法, 或者对其 <code>clone()</code> 方法的调用结果进行保证. 原因如下:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// Object 中的 clone() 方法</span>
<span class="token keyword">protected</span> <span class="token keyword">native</span> <span class="token class-name">Object</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果没有在子类中实现 <code>clone()</code> 方法, 我们无法调用 <code>Object#clone()</code>, 即使通过反射调用成功, 也只会抛出 <code>CloneNotSupportedException</code>.</p><p>因此, 当我们需要提供 <code>clone()</code> 的服务时, 需要实现 <code>Cloneable</code> 接口, 同时重写 <code>Object#clone()</code> 方法.</p><blockquote><p>In practice, a class implementing <code>Cloneable</code> is expected to provide a properly functioning public <code>clone()</code> method.</p></blockquote><p>即使是这样, 我们提供的 <code>clone()</code> 方法依然说不上完美, 因为我们无法保证父类一定实现了 <code>clone()</code> 方法.</p><p>下面来说一下 <code>clone()</code> 方法的使用规范:</p><ol><li>保证 <code>x.clone() != x</code>;</li><li>保证 <code>x.clone().getClass() == x.getClass()</code>.</li><li>通常情况下要求 <code>x.clone().equals(x)</code>.</li><li>不可变类禁止提供 <code>clone()</code> 方法.</li><li>对 <code>clone()</code> 出的类的修改尽可能不要影响被 <code>clone()</code> 的类.</li><li>调用 <code>clone()</code> 时, 通常先调用 <code>super.clone()</code>.</li><li>公开的 <code>clone()</code> 方法通常不要抛出异常.</li></ol><p>我们真的需要如此复杂的又脆弱的 <code>clone()</code> 方法吗, 只有 <code>clone()</code> 方法以及父类的 <code>clone()</code> 方法都写得很好的情况下, <code>clone()</code> 才会良好地发挥作用.</p><p>下面提供一种更好的替代方案--使用<strong>复制构造器</strong>或<strong>复制工厂方法</strong>.</p><blockquote><p>A better approach to object copying is to provide a copy constructor or copy factory.</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// Copy constructor</span>
<span class="token keyword">public</span> <span class="token class-name">Yum</span><span class="token punctuation">(</span><span class="token class-name">Yum</span> yum<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// Copy factory</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Yum</span> <span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在以上方法中我们可以完全地掌握复制的所有逻辑, 甚至是返回类型, 并且能够确保执行的结果.</p><p>不过, 如果一个类被 <code>final</code> 修饰了, 那么一般来说使用 <code>Cloneable</code> 是没有多大问题的.</p><p>对数组的拷贝也更推荐使用 <code>clone()</code> 方法.</p><blockquote><p>As a rule, copy functionality is best provided by constructor or factories. A notable exception to this rule is arrays, which are best copies with the <code>clone()</code> method.</p></blockquote><h3 id="item-14-考虑实现-comparable-接口" tabindex="-1"><a class="header-anchor" href="#item-14-考虑实现-comparable-接口" aria-hidden="true">#</a> Item 14: 考虑实现 Comparable 接口</h3><blockquote><p>Consider implementing <code>Comparable</code>.</p></blockquote><p><code>Comparable</code> 提供的 <code>compareTo()</code> 方法具有和 <code>Object#equals()</code> 方法类似的作用和性质, 不过多了更大还是更小的情况表达.</p><p>其具有的三大性质:</p><ol><li>Reflexive</li><li>Symmetric</li><li>Transitive</li></ol><p>Java 中大多数的值类型类都实现了 <code>Comparable</code> 接口.</p><p>大多数的集合类也都对 <code>Comparable</code> 接口进行了适配, 默认使用<strong>自然序</strong>进行排序. 如:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Stream</span>#<span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>不过, 我们对 <code>Comparable</code> 的实现就直接通过 <code>&gt;, &lt;, =</code> 来对各种属性进行比较吗? 答案是不建议这样做, 因为 Java 为我们提供了更好的方法--<code>Comparator</code>.</p><blockquote><p>Use of the relational operators <code>&lt;</code> and <code>&gt;</code> in <code>compareTo()</code> methods is verbose and error-prone and no longer recommended.</p></blockquote><p><code>Comparator</code> 类以及很多<strong>值类型类</strong>为我们提供了很多的快捷比较方法, 使用这些方法可以很大程度上减少错误, 增加代码可读性. 如:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">PhoneNumber</span> pn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token class-name">Short</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>areaCode<span class="token punctuation">,</span> pn<span class="token punctuation">.</span>areaCode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        result <span class="token operator">=</span> <span class="token class-name">Short</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>prefix<span class="token punctuation">,</span> pn<span class="token punctuation">.</span>prefix<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            result <span class="token operator">=</span> <span class="token class-name">Short</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>lineNum<span class="token punctuation">,</span> pn<span class="token punctuation">.</span>lineNum<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PhoneNumber</span><span class="token punctuation">&gt;</span></span> <span class="token constant">COMP</span> <span class="token operator">=</span>
    <span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparingInt</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">PhoneNumber</span> pn<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> pn<span class="token punctuation">.</span>areaCode<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">thenComparingInt</span><span class="token punctuation">(</span>pn <span class="token operator">-&gt;</span> pn<span class="token punctuation">.</span>prefix<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">thenComparingInt</span><span class="token punctuation">(</span>pn <span class="token operator">-&gt;</span> pn<span class="token punctuation">.</span>lineNum<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">PhoneNumber</span> pn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token constant">COMP</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> pn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的 <code>Comparator</code> API 每一个方法调用都会组合之前的 lambda 表达式, 并生成一个新的 lambda 表达式, 最终形成一个链式的比较器.</p><p>部分源码如下:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">T</span> o1<span class="token punctuation">,</span> <span class="token class-name">T</span> o2<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">comparing</span><span class="token punctuation">(</span>
        <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> keyExtractor<span class="token punctuation">,</span>
        <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> keyComparator<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>keyExtractor<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>keyComparator<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token operator">&amp;</span> <span class="token class-name">Serializable</span><span class="token punctuation">)</span>
        <span class="token punctuation">(</span>c1<span class="token punctuation">,</span> c2<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> keyComparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>keyExtractor<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span><span class="token punctuation">,</span>
                                          keyExtractor<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>c2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">comparingInt</span><span class="token punctuation">(</span><span class="token class-name">ToIntFunction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> keyExtractor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>keyExtractor<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token operator">&amp;</span> <span class="token class-name">Serializable</span><span class="token punctuation">)</span>
        <span class="token punctuation">(</span>c1<span class="token punctuation">,</span> c2<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>keyExtractor<span class="token punctuation">.</span><span class="token function">applyAsInt</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span><span class="token punctuation">,</span> keyExtractor<span class="token punctuation">.</span><span class="token function">applyAsInt</span><span class="token punctuation">(</span>c2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">default</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">thenComparingInt</span><span class="token punctuation">(</span><span class="token class-name">ToIntFunction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> keyExtractor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">thenComparing</span><span class="token punctuation">(</span><span class="token function">comparingInt</span><span class="token punctuation">(</span>keyExtractor<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">default</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">thenComparing</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token operator">&amp;</span> <span class="token class-name">Serializable</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>c1<span class="token punctuation">,</span> c2<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">compare</span><span class="token punctuation">(</span>c1<span class="token punctuation">,</span> c2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>res <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> res <span class="token operator">:</span> other<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>c1<span class="token punctuation">,</span> c2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="类与接口" tabindex="-1"><a class="header-anchor" href="#类与接口" aria-hidden="true">#</a> 类与接口</h2><h3 id="item-15-最小化类和成员可见性" tabindex="-1"><a class="header-anchor" href="#item-15-最小化类和成员可见性" aria-hidden="true">#</a> Item 15: 最小化类和成员可见性</h3><blockquote><p>Minimize the accessibility of classes and members.</p></blockquote><p>一个设计良好的组件对外隐藏了它所有的内部实现, 将其对外暴露的 API 和其内部实现清晰地隔离开. 组件之间都只通过他们提供的 API 进行交互, 对彼此 API 的内部实现没有感知, 也不需要了解内部是如何实现的.</p><blockquote><p>A well-designed component hides all its implementation details, cleanly separating its API from its implementation. Components then communicate only through their APIs and are oblivious to each other&#39;s inner workings.</p></blockquote><p>良好的封装带来的是组件间的解耦合, 使得他们能够被独立地开发, 测试, 优化, 使用, 理解和修改.</p><blockquote><p>It decouples the components that comprise s system, allowing them to be developed, tested, optimized, used, understood, and modified in isolation.</p></blockquote><p>Java 的访问修饰符为组件的可见性设置提供了很好的帮助. 通过合理地使用访问修饰符, 可以准确地限制类和成员的可见性, 实现良好的封装.</p><p>相较而言, Golang 的可见性设计就更加简单, 只存在可见和不可见两种状态, 虽然不如 Java 功能强大, 但是更容易理解.</p><p>在封装组件的过程中, 我们需要遵循一个原则: 尽可能让类或者类成员不访问.</p><blockquote><p>The rule of thumb is simple: make each class or member as inaccessible as possible.</p></blockquote><p>处于更高级别的类或者接口要尽量做到仅包内可见.</p><blockquote><p>If a top-level class or interface can be made package-private, it should be.</p></blockquote><p>如果一个仅包内可见的处于最高级别的类或接口只被某一个类使用, 可以考虑将其设置为使用它的类的内部私有静态类.</p><blockquote><p>If a package-private top-level class or interface is used by only one class, consider making the top-level class a <em>private static nested</em> class of the sole class that use it.</p></blockquote><p>在这里, 我们来回忆以下 Java 的访问修饰符:</p><ol><li><code>private</code>: 仅当前类中可见.</li><li><code>default/package-private</code>: 仅相同包中的类可见.</li><li><code>protected</code>: 仅相同包, 当前类及其子类(可以在不同的包中)可见.</li><li><code>public</code>: 公开可见.</li></ol><p>在类的继承中, 访问修饰符的范围只能变大, 不能变小. 因为必须保证满足里氏替换原则(the <em>Liskov substitution principle</em>), 所有子类能使用的地方, 其父类必须也能够使用(多态).</p><blockquote><p>If a method overrides a superclass method, it cannot have a more restrictive access level in the subclass than in the superclass.</p></blockquote><p>当我们在进行测试工作的时候, 可能需要访问一些被 <code>private</code> 修饰的属性或者方法, 因此需要扩展它的访问可见性. 推荐只将其提升到 <code>package-private</code>, 因为可以在同一个包中进行测试.</p><blockquote><p>It is acceptable to make a private member of a public class package-private in order to test it, but it is not acceptable to raise the accessibility any higher.</p></blockquote><p>公共类中的实例字段应该很少是公共的, 尤其是可变的属性或者指向可变对象的引用. 如果将其对外暴露, 我们就无法确保实例字段的值一定在我们的掌控中(可能会被外界调用者改变). 这样之后, 对应的实例字段也一定不能保证线程安全.</p><blockquote><p>Instance fields of public classes should rarely be public.</p><p>Classes with public mutable fields are not generally thread-safe.</p></blockquote><p>对于被 <code>public static final</code> 修饰的字段, 是可以对外暴露的, <em>除了数组或者可修改的集合</em>. 它们的命名应该遵循: <strong>全大写字母+下划线分隔</strong>的方式.</p><p>对于数组和可修改的集合, 如果想要对外暴露而不想其被外界更改, 我们可以使用不可变集合对其进行包装:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 注意将数组/集合设置为 private</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token constant">PRIVATE_VALUES</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> values <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">unmodifiableList</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token constant">PRIVATE_VALUES</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者提供一个访问方法也可以:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// return Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));</span>
    <span class="token keyword">return</span> <span class="token constant">PRIVATE_VALUES</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="item-16-在公共类中-使用访问方法-而不是公共字段" tabindex="-1"><a class="header-anchor" href="#item-16-在公共类中-使用访问方法-而不是公共字段" aria-hidden="true">#</a> Item 16: 在公共类中, 使用访问方法, 而不是公共字段</h3><blockquote><p>In public classes, use accessor methods, not public fields.</p></blockquote><p>也就是说, 我们通常推荐使用 <code>setter/getter</code> 方法来提供可公开字段的访问和修改功能, 而不直接将对应字段设置为 <code>public</code>.</p><blockquote><p>If a class is accessible outside its package, provide accessor methods.</p></blockquote><p>通过这样的设置, 我们可以将内部字段的实现和处理隐藏起来, 外界只能通过我们提供的方法来访问和修改, 更加符合面向对象的封装特性. 同时, 我们可以在方法中做更多的事情, 比如说记录/转换...</p><p>如果一个类是仅包内可见(<code>package-private</code>)或者私有(<code>private</code>)的,那么就没有必要像上面那样处理.</p><blockquote><p>If a class is <code>package-private</code> or is a <code>private</code> nested class, there is nothing inherently wrong with exposing its data fields.</p></blockquote><p>在 Java 9 之后, 可以使用 <code>record</code> 进行代替, 不过要注意一些兼容性调整, 如果要兼容之前的版本, 那么不推荐使用这种方式.</p><h3 id="item-17-最小化可变性" tabindex="-1"><a class="header-anchor" href="#item-17-最小化可变性" aria-hidden="true">#</a> Item 17: 最小化可变性</h3><blockquote><p>Minimize mutability.</p></blockquote><p>不可变类指的是一个类的实例无法被修改. 类实例包含的内容在整个声明周期不可变.</p><blockquote><p>An immutable class is simply a class whose instances cannot be modified. All of the information contained in each instance is fixed for the lifetime of the object, so no changes can ever be observed.</p></blockquote><p>不可变类在设计, 实现和使用上都比可变类更简单, 也更少出错, 更加安全.</p><blockquote><p>Immutable classes are easier to design, implement and use than mutable class.</p></blockquote><p>Java 中有很多不可变类, 比如: <code>String</code>, 基础数据类型的装箱类, <code>BigInteger</code>, <code>BigDecimal</code> 等.</p><p>要让一个类不可变, 需要做到以下几点:</p><ol><li>不要提供可以修改对象状态的方法, 如: <code>setter</code>.</li><li>保证类不可被继承, 即用 <code>final</code> 修饰, 或者使用静态工厂同时将所有的构造器设置为 <code>private/package-private</code>.</li><li>让所有的字段都不可变, 即使用 <code>final</code> 修饰所有字段.</li><li>让所有字段私有, 即使用 <code>private</code> 修饰所有字段.</li><li>保证所有指向可变对象的字段都不能被外界访问.</li></ol><p>在开发中, 可能一些字段无法被设置为 <code>final</code>, 那么就尽可能使它的可见性降到最低. 同时, 在构造一个不可变类时, 一定要保证构造出的是一个完整的类实例, 因为在构造器外我们不能对任何字段进行修改.</p><p>不可变类在线程安全上有天然的优势: 它们天生就是线程安全的, 不需要任何的同步措施.</p><p>ps: 不可变类的值不可被修改, 也就是没有并发修改的可能, 对其进行的只能是读操作, 读操作不需要任何并发保证.</p><blockquote><p>Immutable objects are inherently thread-safe; they require no synchronization.</p></blockquote><p>不可变类可以带来更多的好处:</p><p><strong>不可变类本身可以被共享, 甚至还可以在不可变类之间共享它们的内部实现</strong>. 如: <code>BigInteger</code> 的内部由两部分构成, <code>sign-magnitude</code>, 也就是 <code>符号-数值</code>. 当我们需要一个具有相同值的相反符号的 <code>BigInteger</code> 时, 只需要调用 <code>BigInteger#negate()</code> 方法, 将符号位取反, 数值数组的引用指向当前数值数组即可, 这样实现了数值数组的复用, 减少了空间和时间消耗.</p><p><strong>不可变类使得其他类的设计更加简便</strong>. 由于其不可变性, 它们在各种键值结构中提供了充分的稳定性, 无论是作为 key 还是作为 value 使用, 使用者都不需要担心它们的值发生改变, 从而影响键值结构的稳定性. 尤其是在各种排序集合中, 如: <code>PriorityQueue</code>, 如果对象在被添加到队列中后, 它的决定排序先后的值发生改变, 那么队列中就不再会具有稳定的排序结果, 导致不可预期的损失.</p><p><strong>不可变类永远是原子性的</strong>, 无论操作成功还是失败, 其不变性保证它们永远具有原子性, 在设计时不需要考虑由于不可变类带来的原子性损失.</p><p><strong>不可变类最大的缺点在于对于每一个不同的值, 都需要一个不同的实例去表征</strong>. 这样可能会带来很大的性能开销, 造成一些内存上的问题.</p><h3 id="item-18-使用组合替代继承" tabindex="-1"><a class="header-anchor" href="#item-18-使用组合替代继承" aria-hidden="true">#</a> Item 18: 使用组合替代继承</h3><blockquote><p>Favor composition over inheritance.</p></blockquote><p>继承是实现代码复用的一种很好的方式, 但是未必是最好的方式. 对继承的滥用可能导致系统变得很不稳定.</p><p>在同一个包中使用继承一般问题不大, 因为所有的父类和子类都被同一个开发者掌控与开发. 在对扩展支持很好的类中使用继承也是没有问题的. 但如果跨包对一般设计的类使用继承, 可能会带来一些意想不到的问题.</p><p><strong>与方法调用不同, 继承违反了封装性.</strong></p><blockquote><p>Unlike method invocation, inheritance violates encapsulation.</p></blockquote><p>在继承中, 子类需要依赖父类的方法实现, 这使得父类在每次迭代中需要考虑对子类的影响, 否则子类可能无法正常工作(子类不一定清除父类的实现细节). 正常情况下, 应该是父类依赖子类, 而不是子类依赖父类.</p><p>我们来看看如何使用组合替代继承:</p><p>需求: 我们提供如下的接口, 需要实现如下接口, 并且对统计输入的数量.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 可执行接口, 接收类型为 I 的输入, 输出类型为 R 的输出.
 */</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Executable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">I</span><span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

    <span class="token comment">// 将具体的执行逻辑单独提出来</span>
    <span class="token class-name">R</span> <span class="token function">doExecute</span><span class="token punctuation">(</span><span class="token class-name">I</span> input<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 对单个输入执行一次</span>
    <span class="token keyword">default</span> <span class="token class-name">R</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">I</span> input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">doExecute</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 对所有的输入都执行一次</span>
    <span class="token keyword">default</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token function">executeAll</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">I</span><span class="token punctuation">&gt;</span></span> input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> input<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">::</span><span class="token function">execute</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假定这个接口十分复杂, 我们对该接口的具体实现可能不清楚, 那么使用直接使用继承可能会写出如下的代码:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DirectInheritedExecutable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">I</span><span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Executable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">I</span><span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> executedCnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">doExecute</span><span class="token punctuation">(</span><span class="token class-name">I</span> input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">I</span> input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        executedCnt<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token class-name">Executable</span><span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token function">executeAll</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">I</span><span class="token punctuation">&gt;</span></span> input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        executedCnt <span class="token operator">+=</span> input<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token class-name">Executable</span><span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">executeAll</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getExecutedCnt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> executedCnt<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>乍一看感觉代码没有问题, 但是如果我们运行如下的代码测试一下:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">DirectInheritedExecutable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> die <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DirectInheritedExecutable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    die<span class="token punctuation">.</span><span class="token function">executeAll</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    die<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>die<span class="token punctuation">.</span><span class="token function">getExecutedCnt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 7</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>会发现输出竟然为 <code>7</code>. 这时候我们再去看源码, 会发现 <code>executeAll()</code> 还会调用 <code>execute()</code> 方法, 导致计数重复.</p><p>我们再来看看组合的方式呢?</p><p>如何组合? 我们将要继承的父类/接口作为私有变量进行维护, 然后继承/实现父类/接口, 重写方法时, 将所有的调用都<strong>转发</strong>(Forwarding)到私有变量的方法来执行. 我们称之为<strong>转发类</strong>. 转发类是用来进行重用的, 这样我们每次在继承的时候都不需要额外组合.</p><p>再基于转发类, 我们编写<strong>包装类</strong>(Wrapper) 继承转发类即可, 也可以称之为<strong>装饰器模式</strong>.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ForwardingExecutable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">I</span><span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Executable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">I</span><span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Executable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">I</span><span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> executable<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">ForwardingExecutable</span><span class="token punctuation">(</span><span class="token class-name">Executable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">I</span><span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        executable <span class="token operator">=</span> e<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">doExecute</span><span class="token punctuation">(</span><span class="token class-name">I</span> input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> executable<span class="token punctuation">.</span><span class="token function">doExecute</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">I</span> input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> executable<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token function">executeAll</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">I</span><span class="token punctuation">&gt;</span></span> input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> executable<span class="token punctuation">.</span><span class="token function">executeAll</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExeFunction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">I</span><span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">ForwardingExecutable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">I</span><span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> executedCnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">ExeFunction</span><span class="token punctuation">(</span><span class="token class-name">Executable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">I</span><span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">doExecute</span><span class="token punctuation">(</span><span class="token class-name">I</span> input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">doExecute</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">I</span> input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        executedCnt<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token function">executeAll</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">I</span><span class="token punctuation">&gt;</span></span> input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        executedCnt <span class="token operator">+=</span> input<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">executeAll</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getExecutedCnt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> executedCnt<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时我们再测试, 发现结果就没有问题, 为 <code>4</code>.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">ExeFunction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> ef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExeFunction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ForwardingExecutable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>i <span class="token operator">-&gt;</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ef<span class="token punctuation">.</span><span class="token function">executeAll</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ef<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ef<span class="token punctuation">.</span><span class="token function">getExecutedCnt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 4</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>组合实现继承的方式的缺点很少, 主要的缺点在于使用组合对回调函数的支持不是很好. 我们一般通过传递自身引用的方式为外部提供回调, 但是被包装的类并不了解其包装类的自身引用, 因此无法完成传递. 我们称之为 SELF problem.</p><p>那么就不用继承了吗? 在子类 <code>A</code> 的确是父类 <code>B</code> 的子类型的情况下, 使用继承是合适的. 如果不是, 那么最好就不要使用继承了, 而是使用组合来替代. 这种情况下更多是 <code>B</code> 希望使用 <code>A</code> 的 API 来完成某些任务, 并对外暴露自己的 API, 而不是暴露 A 的 API.</p><p>在 JDK 中就有这样的例子, <code>Stack</code> 没有继承 <code>Vector</code>, <code>Properties</code> 没有继承 <code>HashTable</code>, 而都是通过组合的方式实现的.</p><h3 id="item-19-要么为继承做好兼容和文档化-要么禁止继承" tabindex="-1"><a class="header-anchor" href="#item-19-要么为继承做好兼容和文档化-要么禁止继承" aria-hidden="true">#</a> Item 19: 要么为继承做好兼容和文档化, 要么禁止继承</h3><blockquote><p>Design and document for inheritances or else prohibit it.</p></blockquote><p>上文中我们就讨论了继承的缺点, 下面我们来讨论如何为继承做好兼容和文档化工作.</p><p>类方法的文档一定要写清楚继承可能导致的影响. <strong>类必须为它们会被自身调用的可重写方法编写完善的文档.</strong> 尤其是被 <code>public</code> 或者 <code>protected</code> 修饰的方法, 必须明确指出该方法可能调用哪些可重写方法, 以什么顺序, 以及每个调用的结果如何影响后续处理.</p><blockquote><p>The class must document its self-use of overridable methods.</p></blockquote><p>在文档的注释中, 我们推荐使用 <code>@implSpec</code> 注释来指明该方法对继承的要求和影响.</p><p><strong>为继承设计的类的唯一测试方式就是编写它的子类</strong>, 因此在发布该类之前, 一定要在测试中编写子类进行完善的测试.</p><p>还有一个要求是: <strong>不要在构造函数中调用可重写方法</strong>, 你不知道它们可能对类的构造产生什么样的影响. <strong>在 <code>Object#clone()</code> 和 <code>Serializable#readObject()</code> 这类类似构造器的方法中同样需要禁止.</strong></p><blockquote><p>Constructors must not invoke overridable methods, directly or indirectly.</p><p>Neither <code>clone()</code> or <code>readObject()</code> may invoke an overridable method, directly or indirectly.</p></blockquote><p><strong>如果你觉得你的类不需要被继承, 那么请将它设计为不可继承, 防止错误的继承导致不可预计的错误.</strong></p><p>有两个方法来实现:</p><ol><li>将该类设置为 <code>final</code>.</li><li>将该类的构造器设置为 <code>private</code> 或 <code>package-private</code>, 并提供静态工厂方法来创建实例.</li></ol><h3 id="item-20-使用接口替代抽象类" tabindex="-1"><a class="header-anchor" href="#item-20-使用接口替代抽象类" aria-hidden="true">#</a> Item 20: 使用接口替代抽象类</h3><blockquote><p>Prefer interfaces to abstract classes.</p></blockquote><p>Java 提供了两种制定类的规范的方式: 接口和抽象类. 在 1.8 之后, 它们都可以很好的定义抽象方法和默认方法. 那么我们在开发过程中如何在两者之间进行选择呢?</p><p>Java 是只支持<strong>单继承</strong>的语言, 这导致一个类最多只能有一个父类. 因此使用抽象类的方式会有很大的局限性. 相反, Java 中一个类可以实现多个接口, 使用接口会更加灵活和可扩展.</p><p><strong>现有类可以通过简单的改变来继承新的接口.</strong></p><blockquote><p>Existing classes can easily be retrofitted to implement a new interface.</p></blockquote><p><strong>接口是实现混合器的理想选择.</strong> 简单来说, 一个类在自己主类的基础上, 还能够实现的其他类型可以称作 <em>混合器</em>, 用其来提供一些额外的行为(功能). 如: <code>Comparable</code>, <code>Serializable</code> 等, 都可以称为混合器.</p><blockquote><p>Interfaces are ideal for defining mixins.</p></blockquote><p><strong>接口允许构建非分层类型框架.</strong></p><blockquote><p>Interfaces allow for the construction of nonhierarchical type frameworks.</p></blockquote><p>很多事物的抽象并不具有层级关系, 因此很难用类的继承来实现(类的继承表现了一种很强烈的层级关系--从属). 比如: 一名会写歌(<code>SongWriter</code>)的歌唱家(<code>Singer</code>), 这两者的抽象就没有层级关系, 因此不能使用继承实现. 相反的, 使用接口将其作为混合器的额外功能就很符合情况.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Singer</span> <span class="token punctuation">{</span>
    <span class="token class-name">AudioClip</span> <span class="token function">sing</span><span class="token punctuation">(</span><span class="token class-name">Song</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">SongWriter</span> <span class="token punctuation">{</span>
    <span class="token class-name">Song</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token class-name">Idea</span> idea<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们需要定义一个既会唱歌又会写歌的抽象, 那么可以按以下方式使用接口简单地实现:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">SongWriterSinger</span> <span class="token keyword">extends</span> <span class="token class-name">Singer</span><span class="token punctuation">,</span> <span class="token class-name">SongWriter</span> <span class="token punctuation">{</span>
    <span class="token class-name">AudioClip</span> <span class="token function">sing</span><span class="token punctuation">(</span><span class="token class-name">Song</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Song</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token class-name">Idea</span> idea<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以通过混合器接口的任意组合, 来添加我们需要的新功能, 就像搭建积木一样. 即:</p><p><strong>接口通过类似包装器的方式提供安全而强大的功能增强.</strong></p><blockquote><p>Interfaces enable safe, powerful functionality enhancements via the <em>wrapper</em> class idiom.</p></blockquote><p>不过, 接口也有一些缺点:</p><ol><li>有一些方法我们无法提供默认实现, 如: <code>equals()</code>, <code>hashCode()</code>.</li><li>不能定义静态变量之外的变量.</li><li>无法为其他接口额外添加默认方法.</li></ol><p>但是呢, 我们可以同时使用接口和抽象类来定义一个类的&quot;骨架&quot;来弥补这些缺点. 我们使用<strong>接口</strong>去定义<strong>类型</strong>和<strong>主要方法</strong>, 也包括一些默认方法; 然后使用<strong>抽象类</strong>去定义一些<strong>属性</strong>和<strong>非主要方法</strong>, 以此构成&quot;骨架&quot;.</p><p>这种方式我们也称之为<strong>模板方法模式</strong>.</p><p>以这种方式实现的&quot;骨架&quot;的命名一般为: <code>Abstract+InterfaceName</code>. 如: <code>AbstractCollection</code>, <code>AbstractMap</code> 等. 表示实现了目标接口的抽象类.</p><p>需要注意, 此时的接口不再是我们之前所说的混合器, 而是占主导地位的接口.</p><p>由于骨架涉及到很多的继承, 在编写&quot;骨架&quot;时, 务必做好文档化工作.</p><p>总结一下就是:</p><ol><li>能用接口尽量用接口.</li><li>不能用接口尽量使用接口+抽象类的混合&quot;骨架&quot;.</li><li>把接口看作一种动作, 可以作为抽象的主导, 也可以作为混合器进行功能增强.</li></ol><h3 id="item-21-为子类设计接口" tabindex="-1"><a class="header-anchor" href="#item-21-为子类设计接口" aria-hidden="true">#</a> Item 21: 为子类设计接口</h3><blockquote><p>Design interfaces for posterity.</p></blockquote><p>在设计接口时, 我们需要考虑到对子类的兼容情况, 因为我们可能会提供一些具有默认实现的模板方法. 比如: 我们在<strong>更新</strong>一个抽象为集合的接口时, 提供了一个非线程安全的删除元素的方法 <code>removeIf(Predicate&lt;?&gt; pre)</code>, 当 <code>pre</code> 的返回值为 <code>true</code> 时删除对应的元素. 但如果某一个子类需要保证线程安全, 并且在这个接口更新之前就提供了完整的 API. 当我们更新接口后, 该子类如果调用 <code>removeIf()</code> 方法, 就可能导致线程安全问题.</p><p>所以, 当我们在设计/更新一个接口时, 一定要先考虑一下未来的子类可能会出现的情况, 尽量设计地更完善.</p><blockquote><p>While it may be possible to correct some interface flaws after an interface is released, you cannot count on it.</p></blockquote><h3 id="item-22-只用接口来定义类型" tabindex="-1"><a class="header-anchor" href="#item-22-只用接口来定义类型" aria-hidden="true">#</a> Item 22: 只用接口来定义类型</h3><blockquote><p>Use interfaces only to define types.</p></blockquote><p>我们使用接口是用它来定义一种类型, 对应实现类的使用者可以通过接口获知该类能够做哪些事情. 接口只应该用于这一个目的.</p><p>有些开发者在接口中只定义常量, 而没有任何方法. 我们称这种接口为常量接口(<em>Constant Interface</em>). 这种方法是<strong>很不推荐</strong>的, 因为大多数人看到接口都会认为它可能具有某种动作, 而常量接口只维护了一些常量.</p><p>如果需要定义常量, 我们推荐使用一个单独的类进行定义, 而不是使用接口或者抽象类.</p><h3 id="item-23-使用类的层级结构代替类标签" tabindex="-1"><a class="header-anchor" href="#item-23-使用类的层级结构代替类标签" aria-hidden="true">#</a> Item 23: 使用类的层级结构代替类标签</h3><blockquote><p>Prefer class hierarchies to tagged class.</p></blockquote><p>有时候, 一个类的实例的同一属性可能有多种不同的属性值, 这些属性值通过一个<em>标签</em>属性维护, 以此来区分不同类型的实例. 如:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Figure</span> <span class="token punctuation">{</span>
    <span class="token keyword">enum</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span> <span class="token constant">RECTANGLE</span><span class="token punctuation">,</span> <span class="token constant">CIRCLE</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">final</span> <span class="token class-name">Shape</span> shape<span class="token punctuation">;</span>

    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种定义的方式具有很多的弊端, 它们的可读性和可扩展性都很差, 并且, 由于需要维护额外的 tag 标签, 也会带来性能上的损失.</p><blockquote><p>Tagged classes are verbose, error-prone, and inefficient.</p></blockquote><p>这种情况下, 我们更应该使用类的继承, 将不同 tag 的类抽象为父类的不同子类.</p><blockquote><p>A tagged class is just a pallid imitation of a class hierarchy.</p></blockquote><p>我们可以做如下更改:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Figure</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token keyword">extends</span> <span class="token class-name">Figure</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Circle</span> <span class="token keyword">extends</span> <span class="token class-name">Figure</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>并且, 我们可以在复用父类提供的方法的基础上, 对不同的子类进行不同的特殊处理.</p><h3 id="item-24-尽可能使用静态成员类" tabindex="-1"><a class="header-anchor" href="#item-24-尽可能使用静态成员类" aria-hidden="true">#</a> Item 24: 尽可能使用静态成员类</h3><blockquote><p>Favor static member classes to nonstatic.</p></blockquote><p>很多时候我们会在类中定义一些嵌套类, 这些内部类只会用来服务于他们的封装类.</p><p>常见的嵌套类有如下几种:</p><ol><li>静态成员类(static member classes).</li><li>非静态成员类(nonstatic member classes).</li><li>匿名类(anonymous classes).</li><li>局部类(local classes).</li></ol><p>除了第一种以外, 其他的都称之为<strong>内部类</strong>.</p><p>下面我们来看看这些嵌套类都用在什么情境下.</p><h4 id="静态成员类" tabindex="-1"><a class="header-anchor" href="#静态成员类" aria-hidden="true">#</a> 静态成员类</h4><p>静态成员类是最简单的嵌套类, 它可以被看作是一个恰巧被声明在了内部的普通类, <strong>具有对封装类中所有成员的访问权限, 即使是私有变量</strong>.</p><p><strong>静态成员类的一大用处是作为公共辅助类</strong>, 用于和其封闭类进行合作. 如: 在 <code>Calculator</code> 类中, 定义了一个枚举静态成员类来标志各种运算符: <code>Calculator.Operation.PLUS</code>, <code>Calculator.Operation.MINUS</code>, .etc.</p><p><strong>私有静态成员类主要用于定义封闭类中的一些组件</strong>. 如: <code>Map</code> 中的键值对结构, 使用 <code>Entry</code> 这个私有的静态成员类来表示.</p><h4 id="非静态成员类" tabindex="-1"><a class="header-anchor" href="#非静态成员类" aria-hidden="true">#</a> 非静态成员类</h4><p>在语言层面上, 非静态成员类和静态成员类的主要区别就在于静态成员类可以访问它们定义域中的静态变量, 而非静态成员类不行.</p><p>在语言层面之外, 就有很多的不同了. 每个非静态成员类的实例都是其封闭类的封闭实例. 在非静态成员类的方法中, 可以通过使用 <code>this</code> 的方式来持有对其封闭类的引用.</p><p><strong>如果一个嵌套类的类实例能够不依赖于其封闭类的实例而存在, 那么这个嵌套类应该被定义为静态成员类.</strong></p><blockquote><p>If an instance of a nested class can exist in isolation class: it is impossible to create an instance of a nonstatic member class without an enclosing instance.</p></blockquote><p>非静态成员类和其封闭类的关系建立发生在成员类实例被创建时, 并且在这之后无法被更改. 一般来说, 这种关系的建立会发生在在封闭类实例调用一个非静态成员类的构造方法时, 当然, 我们也可以通过封闭类手动调用非静态成员类的构造方法: <code>enclosingInstance.new MemberClass(args)</code>.</p><p>非静态成员类会在封闭类实例中占用更多的空间, 带来性能消耗.</p><p><strong>非静态成员类的一大用处就是提供封闭类的适配器(<em>Adaptor</em>)</strong>, 使得封闭类实例可以被看做某些不相关的类.</p><p>如: <code>Map</code> 接口中使用了非静态成员类 <code>Iterator</code> 来实现他们为 <code>Collections</code> 接口提供的方法.</p><p><strong>如果你定义的成员类不需要获取封闭类的实例, 那么将其设置为静态的.</strong></p><blockquote><p>If you declare a member class that does not require access to an enclosing instance, <em>always</em> put the <code>static</code> modifier in its declaration, making it a static rather than a nonstatic class.</p></blockquote><h4 id="匿名内部类" tabindex="-1"><a class="header-anchor" href="#匿名内部类" aria-hidden="true">#</a> 匿名内部类</h4><p>匿名内部类没有名称, 不是其封闭类的成员.</p><p>匿名内部类并不和其他成员一同声明, 而是在使用时被声明和实例化.</p><blockquote><p>Rather than being declared with other members, it is simultaneously declared and instantiated at the point of use.</p></blockquote><p>只有在非静态的上下文中, 匿名内部类才能持有其封闭类的实例引用. 但是即使他们处于静态上下文中, 也没有对其他静态成员(除常量外)的访问权限.</p><p>在 Lambda 表达式被加入前, 匿名内部类通常用于创建一些运行时的小型的函数对象(<em>function objects</em>)和处理对象(<em>process objects</em>). 在 Lambda 之后, 匿名内部类被广泛用于 Lambda 表达式的定义和<strong>函数式编程</strong>中. 另外, 匿名内部类也被用于<strong>静态工厂方法</strong>中(应该也属于函数式编程的一部分).</p><h4 id="局部内部类" tabindex="-1"><a class="header-anchor" href="#局部内部类" aria-hidden="true">#</a> 局部内部类</h4><p>局部内部类使用很少.</p><p>局部内部类可以被定义在任何局部变量能够能被定义的地方, 并且遵循同样的作用域范围. 局部内部类具有名称, 可以被重复使用, 也持有其封闭类的实例的引用(在非静态上下文中), 但是无法持有静态变量. 局部内部类最好和匿名内部类一样简洁精炼, 以提高可读性.</p><p>当一个类只需要存在于一个方法中, 并且已经有类型定义了这个类的行为, 那么就将其作为匿名内部类使用; 否则, 将其作为局部内部类使用.</p><h3 id="item-25-一个源文件中只应该有一个主类" tabindex="-1"><a class="header-anchor" href="#item-25-一个源文件中只应该有一个主类" aria-hidden="true">#</a> Item 25: 一个源文件中只应该有一个主类</h3><blockquote><p>Limit source files to a single top-level class.</p></blockquote><p>虽然 Java 编译器允许我们在一个源文件中定义多个主类(<em>top-level class</em>, 被 <code>public</code> 修饰的 class), 但是我们非常不建议这样去做, 因为这会带来很多问题: 我们可能会在不同的源文件中定义同名的类, 这时候加载哪一个类就要看编译器了, 这样就会带来很大的不确定性.</p><h2 id="泛型" tabindex="-1"><a class="header-anchor" href="#泛型" aria-hidden="true">#</a> 泛型</h2><blockquote><p>Generics</p></blockquote><h3 id="item-26-不要使用原始类型" tabindex="-1"><a class="header-anchor" href="#item-26-不要使用原始类型" aria-hidden="true">#</a> Item 26: 不要使用原始类型</h3><blockquote><p>Do not use raw types.</p></blockquote><p>先介绍一下泛型类和接口的的定义: 声明具有一个或者多个参数类型的类或者接口.</p><blockquote><p>A class or interface whose declaration has one or more <em>type parameters</em> is a <em>generic</em> class or interface.</p></blockquote><p>每个泛型类型都定义了一组&quot;参数化类型&quot;, 其中包含类或接口名称, 后跟与泛型类型的形式类型参数相对应的尖括号中的&quot;实际类型参数&quot;列表.</p><blockquote><p>Each generic type defines a set of <em>parameterized types</em>, which consist of the class or interface name followed by an angle-bracketed list of <em>actual type parameters</em> corresponding to the generic type&#39;s formal type parameters.</p></blockquote><p>每个泛型类型都定义了一个原始类型, 即不带有任何类型参数的泛型类型的名称. 如: <code>List&lt;String&gt;</code> 中, <code>List</code> 就是原始类型. 它们的存在主要是为了兼容没有泛型时的代码.</p><blockquote><p>Each generic type defines a <em>raw type</em>, which is the name of the generic type used without any accompanying type parameters.</p></blockquote><p>泛型相较于原始类型是类型安全的, 它可以保证参数一定是能够被使用的类型, 同时在类型转换时不会出现异常.</p><p>这里展示一个使用原始类型导致的错误:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Collection</span> stamps <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>

<span class="token comment">//Note that Coin is not a subtype of Stamp</span>
stamps<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Coin</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Raw type leads raw iterator type</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Iterator</span> i <span class="token operator">=</span> stamp<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Stamp</span> stamp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Stamp</span><span class="token punctuation">)</span> i<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Throws ClassCastException</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们使用泛型接口 <code>Collection&lt;Stamp&gt;</code>, 那么在执行到添加语句 <code>stamp.add(new Coin(...))</code> 时, 编译器就会报错, 将运行时错误转移到编译器, 保证程序运行时的安全.</p><p>当我们想要在 <code>List&lt;E&gt;</code> 中存放任意类型的变量时, 也不要使用原始类型 <code>List</code>, 而是使用 <code>List&lt;Object&gt;</code> 的方式. 因为 <code>List&lt;Object&gt;</code> 是泛型支持的, 可以有安全性保证. 如: <code>List&lt;String&gt;</code> 是 <code>List</code> 的子类型, 但不是 <code>List&lt;Object&gt;</code> 的子类型, 因此, 泛型为 <code>List&lt;String&gt;</code> 元素无法放入泛型为 <code>List&lt;Object&gt;</code> 的集合中.</p><p>我们使用一个更形象的例子, 如:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Number</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> objListsList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
objListsList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// wrong, can not cast</span>

<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> numListsList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
numListsList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// right</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>当我们不知道集合中的泛型是什么的时候, 可以使用通配符 <code>&lt;?&gt;</code> 表示任意的</strong>. 更高级的, 可以使用 <code>? extends A</code>, 表示 <code>A</code> 及其子类的泛型.</p><p>如:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">numElementsInCommon</span><span class="token punctuation">(</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> s1<span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Object</span> o1 <span class="token operator">:</span> s1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>o1<span class="token punctuation">)</span><span class="token punctuation">)</span> res<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>但是, 除了 <code>null</code> 外, 不能将任何元素放入 <code>Collection&lt;?&gt;</code> 中</strong>.</p><blockquote><p>You can&#39;t put any element(other then <code>null</code>) into a <code>Collection&lt;?&gt;</code>.</p></blockquote><p><strong>在类字面量中, 只能使用原始类型</strong>.</p><p>如: <code>List.class</code>, <code>String[].class</code>, <code>int.class</code>, 而 <code>List&lt;String&gt;.class</code>, <code>List&lt;?&gt;.class</code> 是错误的.</p><blockquote><p>You must use raw types in class literals.</p></blockquote><p><strong>由于泛型信息会在运行时擦除, 因此对除 <code>&lt;?&gt;</code> 之外的泛型类型使用 <code>instanceOf</code> 是非法的</strong>. 使用 <code>&lt;?&gt;</code> 代替原始类型不会影响任何 <code>instanceOf</code> 的行为.</p><p><strong>我们通常利用这个特性来限制原始类型的使用, 也是最推荐的的在 <code>instanceOf</code> 中使用泛型的方式</strong>:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>o instanceOf <span class="token class-name">Set</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> o<span class="token punctuation">;</span> <span class="token comment">//cast raw type to wildcard type</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="item-27-排除未检查警告" tabindex="-1"><a class="header-anchor" href="#item-27-排除未检查警告" aria-hidden="true">#</a> Item 27: 排除未检查警告</h3><blockquote><p>Eliminate unchecked warnings.</p></blockquote><p>Java 开发中可能会遇到很多的未检查警告, 如: <code>unchecked cast warnings</code>, <code>unchecked method warnings</code>, <code>unchecked method invocation warnings</code> ... 越合理地使用泛型, 就能越好地避免此类警告.</p><p>很多未检查警告是很好避免的, 比如: <code>Set&lt;String&gt; s = new HashSet();</code> 会抛出 <code>unchecked conversion</code> 警告, 此时我们只需要将其改为: <code>Set&lt;String&gt; s = new HashSet&lt;&gt;();</code> 即可.</p><p><strong>如果有些警告无法排除, 但是我们可以肯定代码不会出现任何问题, 此时(也只有此时)应该使用 <code>@SuppressWarnings(&quot;unchecked&quot;)</code> 注解来消除警告.</strong></p><blockquote><p>If you can&#39;t eliminate a warning, but you can prove that the code that provoked the warning is typesafe, then (and only then) suppress the warning with an <code>@SuppressWarnings(&quot;unchecked&quot;)</code> annotation.</p></blockquote><p><code>@SuppressWarnings</code> 注解可以用在任何声明处, 从单个的变量的声明, 到整个类都可以使用. 不过, <strong>我们要求将 <code>@SuppressWarnings</code> 的作用范围限制到最小. 同时, 永远不要在整个类上使用</strong>, 这会隐藏很多严重问题.</p><blockquote><p>Always use the <code>@SuppressWarnings</code> annotation on the smallest scope possible.</p></blockquote><p><strong>每次使用 <code>@SuppressWarnings(&quot;unchecked&quot;)</code> 时, 都要通过注释写明为什么这样做是安全的.</strong></p><blockquote><p>Every time you use a <code>@SuppressWarnings(&quot;unchecked&quot;)</code> annotation, add a comment saying why it is safe to do so.</p></blockquote><h3 id="item-28-使用-list-替代-array" tabindex="-1"><a class="header-anchor" href="#item-28-使用-list-替代-array" aria-hidden="true">#</a> Item 28: 使用 List 替代 Array</h3><blockquote><p>Prefer lists to arrays.</p></blockquote><p>数组和泛型类型(这里指泛型类集合)有两大差异.</p><h4 id="数组是协变的-泛型类型是不变的" tabindex="-1"><a class="header-anchor" href="#数组是协变的-泛型类型是不变的" aria-hidden="true">#</a> 数组是协变的, 泛型类型是不变的</h4><blockquote><p>Arrays are covariant, while generics are invariant.</p></blockquote><p><strong>协变</strong>: 如果 <code>Sub</code> 是 <code>Super</code> 的子类, 那么数组 <code>Sub[]</code> 是数组 <code>Super[]</code> 的子类.</p><p><strong>不变</strong>: 任何两个不同的 <code>Type1</code>, <code>Type2</code>, <code>List&lt;Type1&gt;</code> 和 <code>List&lt;Type2&gt;</code> 没有任何继承关系.</p><p><em>协变导致数组在开发上效率更低.</em></p><p>如:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> objArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Long</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
objArray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;I don&#39;t fit in&quot;</span><span class="token punctuation">;</span> <span class="token comment">// Throws ArrayStoreException, runtime</span>

<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> ol <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Incompatible types, compile time</span>
ol<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;I don&#39;t fit in&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="数组是具体化的" tabindex="-1"><a class="header-anchor" href="#数组是具体化的" aria-hidden="true">#</a> 数组是具体化的</h4><blockquote><p>Arrays are reified.</p></blockquote><p>具体化导致数组在运行时必须直到它们的元素类型. 而泛型在运行时会有类型擦除(<em>erase</em>), 只在编译期限制元素类型, 在运行时擦除类型. 类型擦除使得泛型可以随意与不使用泛型的合法代码合作.</p><p>上面两点差异导致数组和泛型的兼容性很差. 如: 我们不能使用泛型去创建任何数组.</p><p>因此, 我们建议, 在数组和泛型集合中, 优先使用泛型集合.</p><h3 id="item-29-使用泛型类" tabindex="-1"><a class="header-anchor" href="#item-29-使用泛型类" aria-hidden="true">#</a> Item 29: 使用泛型类</h3><blockquote><p>Favor generic types.</p></blockquote><p><strong>相较于使用 <code>Object</code> 之类的很宽泛的类去限制元素类型, 我们更推荐使用泛型.</strong></p><p>在之前(<a href="#item-7-%E6%B6%88%E9%99%A4%E8%BF%87%E6%97%B6%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">Item 7</a>), 我们自己设计了一个 <code>MyStack</code>, 我们用泛型来进行重构:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericStack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span> <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>

    <span class="token comment">// This elements array will contain only E instances from push(E).</span>
    <span class="token comment">// This is sufficient to ensure type safety,</span>
    <span class="token comment">// but the runtime type of the array won&#39;t be E[];</span>
    <span class="token comment">// it will always be Object[], as a result of type erase.</span>
    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">GenericStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        elements <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">ensureCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        elements<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">EmptyStackException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">E</span> result <span class="token operator">=</span> elements<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>

        elements<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>elements<span class="token punctuation">.</span>length <span class="token operator">==</span> size<span class="token punctuation">)</span> elements <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> size <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在使用时, 如果想让我们的 <code>GenericStack</code> 存储 <code>Number</code> 及其子类型, 可以使用如下声明:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">GenericStack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> numStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="item-30-优先使用泛型方法" tabindex="-1"><a class="header-anchor" href="#item-30-优先使用泛型方法" aria-hidden="true">#</a> Item 30: 优先使用泛型方法</h3><blockquote><p>Favor generic methods.</p></blockquote><p>Java 中泛型也能够使用泛型. 静态工具方法通常都是基于泛型的, 各种的&quot;算法&quot;方法都是基于泛型的, 如: <code>Collections.sort()</code>.</p><p>方法中使用泛型和使用泛型类类似.</p><p>比如我们想要将两个集合合并, 使用泛型如下:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> s1<span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>在静态方法中, 我们需要声明方法是泛型的</strong>, 即 <code>public static &lt;E&gt; ...</code>. 因为静态方法无法从类定义中获取到泛型信息(泛型信息对于每个类实例可能是不同的, 因此在静态上下文中无法获取).</p><p><strong>泛型的定义在方法的修饰符和返回值之间.</strong></p><blockquote><p>The type parameter list, which declares the type parameters, goes between a method&#39;s modifiers and its return type.</p></blockquote><p>由于泛型在运行时会进行擦除, 也就是在运行时是无状态的, 我们只需要编写一次泛型方法来兼容各种类型的元素, 极大地减少了工作量.</p><p>有时候, 一个类型参数可能会被绑定到另一个包含自己的表达式中, 我们称之为<strong>循环类型绑定</strong>. 如:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">T</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">E</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中的 <code>&lt;E extends Comparable&lt;E&gt;&gt;</code> 读作 <em>any type E that can be compared to itself</em>.</p><h3 id="item-31-使用有界通配符来提高-api-的灵活性" tabindex="-1"><a class="header-anchor" href="#item-31-使用有界通配符来提高-api-的灵活性" aria-hidden="true">#</a> Item 31: 使用有界通配符来提高 API 的灵活性</h3><blockquote><p>Use bounded wildcards to increase API flexibility.</p></blockquote><p>在 <a href="#item-28-%E4%BD%BF%E7%94%A8-list-%E6%9B%BF%E4%BB%A3-array">Item 28</a> 中, 我们说过泛型是不变的(<em>invariant</em>), 也就意味着<strong>泛型参数不同的泛型类是不同的</strong>, 即使它们的泛型参数具有继承关系, 泛型类本身也不会具有任何的继承关系.</p><p>但是我们有时候在 API 中需要更加良好的灵活性, 而不变式(<em>invariant</em>)不能够提供. 比如在 <a href="#item-29-%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%B1%BB">Item 29</a> 中的 <code>GenericStack</code> 类, 我们抽离以下它的 API:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericStack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假定我们想要添加一个输入为一系列元素, 并且将他们都添加到 <code>stack</code> 中的 API, 我们可能会这样写:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pushAll</span><span class="token punctuation">(</span><span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> src<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">E</span> e <span class="token operator">:</span> src<span class="token punctuation">)</span> <span class="token function">push</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个代码看上去可以良好的运行, 但是如果我们定义了 <code>GenericStack&lt;Number&gt;</code>, 而我们想要将一系列 <code>Integer</code> 类型的值加入其中, 就会发现这个 API 会报错了. 因为虽然 <code>Integer</code> 是 <code>Number</code> 的子类, 但是 <code>Iterable&lt;Integer&gt;</code> 不是 <code>Integer&lt;Number&gt;</code> 的子类.</p><p>此时, 我们可以使用有界通配符(<em>bounded wildcard</em>, <code>&lt;? extends/super Type&gt;</code>) 来接收更大范围的参数.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pushAll</span><span class="token punctuation">(</span><span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> src<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">E</span> e <span class="token operator">:</span> src<span class="token punctuation">)</span> <span class="token function">push</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们在加入以下 <code>popAll()</code> 方法:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">popAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> dst<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> dst<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样的, <code>popAll(Collection&lt;E&gt;)</code> 方法只接受泛型参数与当前泛型类泛型参数相同的集合, 而不支持任何泛型参数 <code>E</code> 的父类的方法, 我们使用有界通配符进行优化:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">popAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> dst<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> dst<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>为了最大程度的灵活性, 在作用为生产者或者消费者的参数中使用带有的通配符泛型参数类型.</strong></p><blockquote><p>For maximum flexibility, use wildcard types on input parameters that represent producers or consumers.</p></blockquote><p>这里提供一个简单的口诀:</p><blockquote><p><strong>PECS: producer-extends, consumer-super.</strong></p></blockquote><p>比如, 在 <a href="#item-30-%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95">Item 30</a> 中, 有如下的方法声明:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> s1<span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们发现 <code>s1</code>, <code>s2</code> 都作为生产者参数传入, 需要使用通配符来扩展.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> s1<span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>注意, 这里的返回值类型还是 <code>Set&lt;E&gt;</code>, 而不是 <code>Set&lt;? super E&gt;</code>.</p><p><strong>永远不要在返回值类型中使用通配符.</strong></p><p>同样的在 <code>max()</code> 方法中, 使用通配符进行优化:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用两次 PECS:</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>Comparables are always consumers, you should generally use <code>Comparable&lt;? super T&gt;</code> in preference to <code>Comparable&lt;T&gt;</code>. The same is to <code>Comparator&lt;? super T&gt;</code>.</strong></p></blockquote><p><strong>为什么在 <code>Comparable</code> 中使用 <code>&lt;? super T&gt;</code>?</strong></p><p><code>&lt;T extends Comparable&lt;? super T&gt;&gt;</code> 表示可以使用任何超类的比较器, 这样可以使得所有的子类去使用父类的比较器, 或者所有的子类都使用相同的比较器. 如果只是用 <code>T extends Comparable&lt;T&gt;</code> 的话, 就只能使用当前类的比较器, 很不灵活.</p><p>当静态方法中只有一个泛型参数时, 有两种写法:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这两种写法都是可行的. 我们推荐使用第二种.</p><p><strong>如果一个泛型参数只在方法声明中只出现以此, 那么将它替换为通配符.</strong></p><blockquote><p>If a type parameter appears only once in a method declaration, replace it with a wildcard.</p></blockquote><p>但是第二种方式也可能出现一些问题, 如:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    list<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时编译器会报错, 因为我们无法将任何非空的值放入 <code>List&lt;?&gt;</code> 中. 那么怎么解决呢?</p><p><em>使用一个私有的方法去捕获泛型参数.</em></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">swapHelper</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">swapHelper</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    list<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="item-32-明智地组合泛型和可变参数" tabindex="-1"><a class="header-anchor" href="#item-32-明智地组合泛型和可变参数" aria-hidden="true">#</a> Item 32: 明智地组合泛型和可变参数</h3><blockquote><p>Combine generics and varargs judiciously.</p></blockquote><p>我们首先要明确什么是可变参数, 这里举一个例子:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">of</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> elements<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>可变参数, 可以成为变长参数, 是 Java 提供的一种语法糖, 只能在参数列表末尾声明, 用于接收任意长度的参数, 使用 <code>Type... argName</code> 表示.</strong></p><p><strong>编译器会将可变参数使用一个数组接收, 使用时, <code>argName</code> 就是一个包含所有输入参数的数组, 即: <code>Type[] argName</code>.</strong></p><p>到这里, 我们就已经可以明白为什么不推荐泛型和可变参数进行组合了. 泛型在运行期会进行类型擦除, 包含的信息很少, 而数组在运行期会掌握所有元素的类型, 它们之间很可能导致各种转换错误, 以 <code>ClassCastException</code> 为典型.</p><p>当参数化类型的变量引用不属于该类型的对象时，就会发生<strong>堆污染(<em>heap pollution</em>)</strong>.</p><blockquote><p>Heap pollution occurs when a variable of a parameterized type refers to an object that is not of that type.</p></blockquote><p>如:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">dangerous</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> stringLists<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// List&lt;String&gt;[] stringLists;</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> intList <span class="token operator">=</span> <span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> objects <span class="token operator">=</span> stringLists<span class="token punctuation">;</span>
    objects<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> intList<span class="token punctuation">;</span>               <span class="token comment">// Heap pollution</span>
    <span class="token class-name">String</span> s <span class="token operator">=</span> stringLists<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// ClassCastException</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>堆污染可能会导致由编译器自动生成的类型转换失败, 导致泛型编程的基础被破坏.</p><p><strong>向泛型可变参数数组中写入数据是不安全的</strong>. 上面的例子中, 我们向泛型可变参数数组中写入了一个与其泛型类型不同的值, 导致它的泛型系统被破坏, 再从数组中取出元素可能就会发生 <code>ClassCastException</code>.</p><p>但是我们又会有疑惑, 既然说泛型和可变参数组合是不安全的, 那么为什么 JDK 中的很多 API 还在这样使用呢? 就像我们看到的 <code>public static &lt;E&gt; List&lt;E&gt; List.of(E... elements)</code> 一样. 因为和上面的 <code>dangerous()</code> 方法不同, JDK 中的方法是类型安全的.</p><p>再 JDK 7 之后, 提供了一个用于表示使用了泛型可变参数的方法是泛型安全的注解--<code>@SafeVarargs</code>. <strong><code>@SaveVarargs</code> 表示由 API 作者保证的该方法是类型安全的.</strong></p><p>当我们在 IDEA 中编写泛型可变参数方法时, IDEA 会提示我们需要保证泛型安全, 防止堆污染, 在确认后, 使用 <code>@SafeVarargs</code> 来消除这一个警告.</p><p><strong>只有当我们确认方法是类型安全的时候, 才能够使用 <code>@SafeVarargs</code> 注解!</strong></p><p>那么我们如何保证泛型可变参数方法是安全的呢?</p><ol><li><strong>在方法中不向泛型可变参数数组中写入任何数据.</strong></li><li><strong>不允许泛型可变参数数组的引用从方法中逃逸.</strong></li></ol><p>当方法满足以上条件时, 它就是类型安全的.</p><p><strong>如果不想使用 <code>@SafeVarargs</code> 这种依赖作者进行安全性检查的注解, 还有一种方法--<a href="#item-28-%E4%BD%BF%E7%94%A8-list-%E6%9B%BF%E4%BB%A3-array">Item 28: 使用 List 替代 Array</a>.</strong></p><p>当使用 <code>List</code> 替代数组之后, 就可以使用 JDK 提供的一些安全的方法来传递参数了, 如: <code>List.of(E... elements)</code>, <code>Set.of(E... elements)</code>, 相当于我们把可变参数的接收和封装交给了 JDK 的官方包, 而不是第三方开发者或者自己提供的不能确保一定安全的接收方法.</p><h4 id="总结-32" tabindex="-1"><a class="header-anchor" href="#总结-32" aria-hidden="true">#</a> 总结-32</h4><ol><li><p>要使用泛型可变参数方法, 就一定要保证方法的类型安全性--对泛型可变参数数组做到: <strong>不写入, 不传出</strong>.</p></li><li><p>要么就不使用泛型可变参数方法, 使用 <code>List</code> 替代数组, 使用 JDK 中的 API 来处理可变参数.</p></li></ol><h3 id="item-33-使用各种类型安全的容器" tabindex="-1"><a class="header-anchor" href="#item-33-使用各种类型安全的容器" aria-hidden="true">#</a> Item 33: 使用各种类型安全的容器</h3><blockquote><p>Consider typesafe heterogeneous containers.</p></blockquote><p>毫无疑问的, JDK 中支持泛型的容器都是类型安全的, 我们平时也会用到很多. 如果它们能够支持我们所需的功能, 就尽量使用它们而不是自己去写一个新的.</p><p>那么如果有些官方包无法实现的功能, 一定需要自己来进行编写或者封装呢? 那就需要我们来保证容器的类型安全了.</p><p>我们用一个需求来举例讲解:</p><p><em>我们对每一个类都一个最喜欢的实例, 使用 <code>Favorites</code> 来表示, 需要能够向其中存放或者取出对应的最喜欢的实例.</em></p><p>如何来设计 API 呢? 对于这种需要兼容很多类的容器, 我们自然地想要使用泛型来进行设计. 那么用泛型来限制什么呢? 是限制容器吗?</p><p><strong>对于容器中不同的类型实例, 我们选择使用泛型来限制 <em>key</em> 而不是 <em>container</em>.</strong></p><p>如果限制 <em>container</em>, 那么容器中的所有实例都是同一个泛型类型, 限制 <em>key</em> 的话, 就可以使得容器中有多种类型的实例, 但是 <em>key</em> 和 <em>value</em> 的泛型类型都是相同的.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Favorites</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Class</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> favorites <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> type<span class="token punctuation">,</span> <span class="token class-name">T</span> instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        favorites<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">,</span> instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// dynamically cast using type.cast(...)</span>
        <span class="token keyword">return</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">cast</span><span class="token punctuation">(</span>favorites<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// JDK source code</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token class-name">T</span> <span class="token function">cast</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们使用了 <code>Class&lt;T&gt;</code> 来使用泛型对 <em>key</em> 进行限制, <code>Class&lt;T&gt;</code> 即 <code>T.class</code>. 这样, 我们的容器就是类型安全的了.</p><p>为什么是安全的呢? 在 <code>put()</code> 方法中, 一定是安全的, 它由 <code>Class&lt;T&gt; type, T instance</code> 约束; 在 <code>favorites</code> 字段中, 它丢失了 <em>key</em> 和 <em>value</em> 的类型约束, 所以 <em>value</em> 的类型只能使用 <code>Object</code> 进行约束, 因为我们无从得知 <em>value</em> 的类型; 但是在 <code>get()</code> 方法中, 我们又通过 <code>Class&lt;T&gt; type</code> 进行了类型约束, 使得取出的值一定是对应的类型, 不会出现类型安全问题.</p><p>如果一个类字面量同时在编译期和运行期都在方法间用于通信被传递时, 就称之为 <strong>类字面量</strong>.</p><p>但是上面的代码还有一些问题, 因为我们不能保证 API 的使用者一定会传递具有泛型的参数, 使用者可以传递一个原始类型的 <code>Class</code> 对象, 这时候 <code>put()</code> 方法在泛型上就无法确定 <em>value</em> 的类型了. 那么如何优化呢?--使用动态类型转换(<em>dynamically cast</em>)--<code>type.cast(...)</code>.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> type<span class="token punctuation">,</span> <span class="token class-name">T</span> instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    favorites<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">,</span> type<span class="token punctuation">.</span><span class="token function">cast</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还有一个缺陷就是我们无法将非具体化类型(或者说泛化类型, <em>reified</em>)存入我们的容器中(<a href="#item-28-%E4%BD%BF%E7%94%A8-list-%E6%9B%BF%E4%BB%A3-array">Item 28</a>). 我们能够存储各种具体化类型, 比如 <code>String</code>, <code>String[]</code>; 但是无法存储泛化类型, 比如 <code>List&lt;String&gt;</code>, <code>Set&lt;Integer&gt;</code> 之类的数据.</p><p>像我们在 <code>put(Class&lt;T&gt; type, T instance)</code> 中的用法一样, 使用类型标记(<em>type token</em>)作为参数类型的限制参数, 这中类型标记称为有界类型标记(<em>bounded type token</em>).</p><h4 id="总结-33" tabindex="-1"><a class="header-anchor" href="#总结-33" aria-hidden="true">#</a> 总结-33</h4><p>尽量使用类型安全的容器.</p><p>可以通过有界类型标记(<em>bounded type token</em>)的方式, 来限制容器中的 <em>key</em>, 而不是容器本身, 使得容器能够容纳多种不同类型的键值, 同时保证其类型安全性.</p><h2 id="枚举和注解" tabindex="-1"><a class="header-anchor" href="#枚举和注解" aria-hidden="true">#</a> 枚举和注解</h2><blockquote><p>Enums and Annotations</p></blockquote><h3 id="item-34-使用枚举而不是-int-常量" tabindex="-1"><a class="header-anchor" href="#item-34-使用枚举而不是-int-常量" aria-hidden="true">#</a> Item 34: 使用枚举而不是 int 常量</h3><blockquote><p>Use enums instead of <code>int</code> constants.</p></blockquote><p>枚举类(<em>enumerated type</em>)是一种能够包含固定的一系列常量的类型, 如: 一年的四个季节, 太阳系的各大行星等.</p><p>在枚举类出现前, 开发者一般使用有名 <code>int</code> 常量(<em>named int constants</em>)来表达枚举的意义.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Seasons</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">SPRING</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">SUMMER</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">AUTUMN</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">WINTER</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>使用有名 <code>int</code> 常量的方式使得程序很脆弱.</strong> 这主要是由于 Java 平台的原因: 由于 <code>int</code> 常量会在编译期进行优化, 在程序中使用对应的值去替换其名称引用, 这样就相当于我们对代码进行了硬编码, 每一次修改常量的值都需要重新进行编译, 否则程序会运行失败.</p><p>同时, <strong>我们很难将 <code>int</code> 常量转换为可打印字符串</strong>, 这导致我们在 debug 或者进行日志记录时, 无法良好的展示枚举的意义.</p><p>再者, <strong>用 <code>int</code> 常量来代替的枚举类自身没有提供任何的可遍历方法或者获取枚举值集合大小的方法</strong>.</p><p>那使用 <code>String</code> 常量来代替呢? 那就更不推荐了, 虽然我能够通过直接打印的方式获取枚举值对应的意义, 但是这样可能导致有些开发者不重视属性名称的规范. 并且, <code>String</code> 类的比较消耗高得多, 会带来很多性能上的问题.</p><p>Java 提供了功能完备的枚举类, 我们来看一看.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Seasons</span> <span class="token punctuation">{</span>
    <span class="token constant">SPRING</span><span class="token punctuation">,</span> <span class="token constant">SUMMER</span><span class="token punctuation">,</span> <span class="token constant">AUTUMN</span><span class="token punctuation">,</span> <span class="token constant">WINTER</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Java 中的枚举类实例是实实在在的类实例, 而不是某些语言中的 <code>int</code> 常量的封装(如: C, C++, C#).</p><p>Java 的枚举类在底层通过 <code>public static final</code> 的字段的方式暴露枚举实例, 每个枚举实例都是单例的, 外部无法创建任何的枚举类实例. 枚举类的单例创建发生在类加载阶段, 通过类加载器的方式保证加载是线程安全的, 因此有时也使用枚举类作为饿汉式的单例实现.</p><p><strong>枚举类保证了编译期类型安全</strong>. 如果传递枚举类型的参数, 那么编译器能够保证参数一定是枚举类型的实例, 如果不是, 那么编译器会报错. 同时, 我们也可以使用 <code>==</code> 的方式来对枚举类进行比较.</p><p><strong>枚举类型不会被编译器优化为硬编码代码, 因此对枚举类实例定义顺序的更改或者增删实例不会导致不可预计的问题.</strong></p><p>枚举类还可以通过重写 <code>toString()</code> 方法来便捷地定义打印格式.</p><p><strong>为了提高枚举类的效率, Java 允许枚举类添加自己的方法和字段, 或者实现必要的接口. 枚举类自身已经实现了 <code>Comparable</code> 和 <code>Serializable</code> 接口.</strong></p><p>公共方法:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Operation</span> <span class="token punctuation">{</span>
    
    <span class="token constant">PLUS</span><span class="token punctuation">,</span> <span class="token constant">MINUS</span><span class="token punctuation">,</span> <span class="token constant">TIMES</span><span class="token punctuation">,</span> <span class="token constant">DIVIDE</span><span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">case</span> <span class="token constant">PLUS</span> <span class="token operator">-&gt;</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token constant">MINUS</span> <span class="token operator">-&gt;</span> x <span class="token operator">-</span> y<span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token constant">TIMES</span> <span class="token operator">-&gt;</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token constant">DIVIDE</span> <span class="token operator">-&gt;</span> x <span class="token operator">/</span> y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了在枚举类中为所有的实例都提供相同逻辑的公共方法, 我们还可以通过设置抽象方法的方式, 使不同的实例可以具有不同的方法实现, 我们可以将以上的方法改写为:</p><p>抽象方法:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Operation</span> <span class="token punctuation">{</span>

    <span class="token constant">PLUS</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token constant">MINUS</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> x <span class="token operator">-</span> y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token constant">TIMES</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token constant">DIVIDE</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> x <span class="token operator">/</span> y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们发现没有将枚举实例和对应的算符符号联系起来, 并且在 API 的提供和抽象上还不够完善, 因此我们做出如下的优化:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Operation</span> <span class="token punctuation">{</span>
    <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">BaseOperation</span> <span class="token keyword">implements</span> <span class="token class-name">Operation</span> <span class="token punctuation">{</span>

    <span class="token function">PLUS</span><span class="token punctuation">(</span><span class="token string">&quot;+&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">MINUS</span><span class="token punctuation">(</span><span class="token string">&quot;-&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> x <span class="token operator">-</span> y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">TIMES</span><span class="token punctuation">(</span><span class="token string">&quot;*&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">DIVIDE</span><span class="token punctuation">(</span><span class="token string">&quot;/&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> x <span class="token operator">/</span> y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> symbol<span class="token punctuation">;</span>

    <span class="token class-name">BaseOperation</span><span class="token punctuation">(</span><span class="token class-name">String</span> symbol<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>symbol <span class="token operator">=</span> symbol<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> symbol<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们需要添加新的算符的时候, 就很方便扩展了:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">ExtendedOperation</span> <span class="token keyword">implements</span> <span class="token class-name">Operation</span> <span class="token punctuation">{</span>
    
    <span class="token function">EXP</span><span class="token punctuation">(</span><span class="token string">&quot;^&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">REMAINDER</span><span class="token punctuation">(</span><span class="token string">&quot;%&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> x <span class="token operator">%</span> y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> symbol<span class="token punctuation">;</span>
    
    <span class="token class-name">ExtendedOperation</span><span class="token punctuation">(</span><span class="token class-name">String</span> symbol<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>symbol <span class="token operator">=</span> symbol<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> symbol<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们再来考虑一个问题: 泛型参数如何和枚举类相结合呢?</p><p>上面的示例中, 我们希望在能够使用 <code>BaseOperation</code> 枚举类型的地方, 我们也能够使用 <code>ExtendedOperation</code> 枚举类型(注意, 是只能使用枚举类型); 同时, 还能够不局限于传递单一枚举实例, 而是可以传递一个枚举类的所有实例. 这时候就需要使用泛型了:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">double</span> x <span class="token operator">=</span> <span class="token number">1.2</span><span class="token punctuation">;</span>
        <span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token number">2.5</span><span class="token punctuation">;</span>
        <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">BaseOperation</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">ExtendedOperation</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Enum</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span> <span class="token operator">&amp;</span> <span class="token class-name">Operation</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> opEnumType<span class="token punctuation">,</span> <span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Operation</span> op <span class="token operator">:</span> opEnumType<span class="token punctuation">.</span><span class="token function">getEnumConstants</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%f %s %f = %f%n&quot;</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> op<span class="token punctuation">,</span> y<span class="token punctuation">,</span> op<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Enum</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span> <span class="token operator">&amp;</span> <span class="token class-name">Operation</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> opSet<span class="token punctuation">,</span> <span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Operation</span> op <span class="token operator">:</span> opSet<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%f %s %f = %f%n&quot;</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> op<span class="token punctuation">,</span> y<span class="token punctuation">,</span> op<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们在这同样能在这里看到有界类型标记(<em>bounded type token</em>)(<a href="#item-33-%E4%BD%BF%E7%94%A8%E5%90%84%E7%A7%8D%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%B9%E5%99%A8">Item 33</a>)的使用. <code>&lt;T extends Enum&lt;T&gt; &amp; Operation&gt;</code> 保证 <code>T</code> 是枚举类型, 并且实现了 <code>Operation</code> 接口.</p><p><code>Enum&lt;T&gt;</code> 与 <code>Class&lt;T&gt;</code> 类似, <code>Enum</code> 是对 <code>Class</code> 的封装. <code>Enum&lt;T&gt;#getDeclaringClass()</code> 即 <code>Class&lt;T&gt;</code> 的实例.</p><p>我们再来看一下在枚举类中使用枚举类的示例:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">PayrollDay</span> <span class="token punctuation">{</span>

    <span class="token constant">MONDAY</span><span class="token punctuation">,</span> <span class="token constant">TUESDAY</span><span class="token punctuation">,</span> <span class="token constant">WEDNESDAY</span><span class="token punctuation">,</span> <span class="token constant">THURSDAY</span><span class="token punctuation">,</span> <span class="token constant">FRIDAY</span><span class="token punctuation">,</span>
    <span class="token function">SATURDAY</span><span class="token punctuation">(</span><span class="token class-name">PayType</span><span class="token punctuation">.</span><span class="token constant">WEEKEND</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">SUNDAY</span><span class="token punctuation">(</span><span class="token class-name">PayType</span><span class="token punctuation">.</span><span class="token constant">WEEKEND</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">PayType</span> payType<span class="token punctuation">;</span>

    <span class="token class-name">PayrollDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// default</span>
        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token class-name">PayType</span><span class="token punctuation">.</span><span class="token constant">WEEKDAY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token class-name">PayrollDay</span><span class="token punctuation">(</span><span class="token class-name">PayType</span> payType<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>payType <span class="token operator">=</span> payType<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">int</span> <span class="token function">pay</span><span class="token punctuation">(</span><span class="token keyword">int</span> minsWorked<span class="token punctuation">,</span> <span class="token keyword">int</span> payRate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> payType<span class="token punctuation">.</span><span class="token function">pay</span><span class="token punctuation">(</span>minsWorked<span class="token punctuation">,</span> payRate<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">enum</span> <span class="token class-name">PayType</span> <span class="token punctuation">{</span>
        <span class="token constant">WEEKDAY</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">int</span> <span class="token function">overtimePay</span><span class="token punctuation">(</span><span class="token keyword">int</span> minsWorked<span class="token punctuation">,</span> <span class="token keyword">int</span> payRate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> minsWorked <span class="token operator">&lt;=</span> <span class="token constant">MINS_PER_SHIFT</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>minsWorked <span class="token operator">-</span> <span class="token constant">MINS_PER_SHIFT</span><span class="token punctuation">)</span> <span class="token operator">*</span> payRate <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token constant">WEEKEND</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">int</span> <span class="token function">overtimePay</span><span class="token punctuation">(</span><span class="token keyword">int</span> minsWorked<span class="token punctuation">,</span> <span class="token keyword">int</span> payRate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> minsWorked <span class="token operator">*</span> payRate <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        
        <span class="token keyword">abstract</span> <span class="token keyword">int</span> <span class="token function">overtimePay</span><span class="token punctuation">(</span><span class="token keyword">int</span> minsWorked<span class="token punctuation">,</span> <span class="token keyword">int</span> payRate<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MINS_PER_SHIFT</span> <span class="token operator">=</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">;</span>
        
        <span class="token keyword">int</span> <span class="token function">pay</span><span class="token punctuation">(</span><span class="token keyword">int</span> minsWorked<span class="token punctuation">,</span> <span class="token keyword">int</span> payRate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> basePay <span class="token operator">=</span> minsWorked <span class="token operator">*</span> payRate<span class="token punctuation">;</span>
            <span class="token keyword">return</span> basePay <span class="token operator">+</span> <span class="token function">overtimePay</span><span class="token punctuation">(</span>minsWorked<span class="token punctuation">,</span> payRate<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>枚举类的常量特性在 <code>switch</code> 语句中也有很好的发挥空间, 这里不再赘述.</p><h4 id="总结-34" tabindex="-1"><a class="header-anchor" href="#总结-34" aria-hidden="true">#</a> 总结-34</h4><p>枚举类型就是 Java 专门提供给开发者对各种常量枚举的实现, 它作为一个类又提供了很好的灵活性, 因此尽量使用枚举类型.</p><h3 id="item-35-使用实例字段而不是序数" tabindex="-1"><a class="header-anchor" href="#item-35-使用实例字段而不是序数" aria-hidden="true">#</a> Item 35: 使用实例字段而不是序数</h3><blockquote><p>Use instance fields instead of ordinals.</p></blockquote><p>枚举实例中包含自身在枚举集合中的位置, 是一个 <code>int</code> 类型的值, 使用 <code>ordinal()</code> 方法获取.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Ensemble</span> <span class="token punctuation">{</span>
    <span class="token constant">SOLO</span><span class="token punctuation">,</span> <span class="token constant">DUET</span><span class="token punctuation">,</span> <span class="token constant">TRIO</span><span class="token punctuation">,</span> <span class="token constant">QUARTET</span><span class="token punctuation">,</span> <span class="token constant">QUINTET</span><span class="token punctuation">,</span> 
    <span class="token constant">SEXTET</span><span class="token punctuation">,</span> <span class="token constant">SEPTET</span><span class="token punctuation">,</span> <span class="token constant">OCTET</span><span class="token punctuation">,</span> <span class="token constant">NONET</span><span class="token punctuation">,</span> <span class="token constant">DECTET</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numberOfMusicians</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是我们非常不推荐使用这个方法来将枚举类实例和 <code>int</code> 值进行绑定, 因为当我们每次打乱枚举实例的声明顺序, 其对应的 <code>int</code> 值都会改变, 导致不可预估的错误.</p><p>我们更推荐在枚举类中定义一个 <code>int</code> 类型的实例字段的方式来进行绑定, 如:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Ensemble</span> <span class="token punctuation">{</span>
    <span class="token function">SOLO</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">DUET</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">TRIO</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> numberOfMusicians<span class="token punctuation">;</span>

    <span class="token class-name">Ensemble</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>numberOfMusicians <span class="token operator">=</span> size<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numberOfMusicians</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> numberOfMusicians<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="总结-35" tabindex="-1"><a class="header-anchor" href="#总结-35" aria-hidden="true">#</a> 总结-35</h4><p>永远不要将枚举类实例中的一个值和实例的序数绑定; 应该将其存储到一个实例字段中.</p><blockquote><p>Never derive a value associated with an enum from its ordinal; store it in an instance field instead.</p></blockquote><p>枚举实例的序数只用于在 <code>EnumMap</code>, <code>EnumSet</code> 等集合中起辅助作用.</p><h3 id="item-36-使用-enumset-代替位字段" tabindex="-1"><a class="header-anchor" href="#item-36-使用-enumset-代替位字段" aria-hidden="true">#</a> Item 36: 使用 EnumSet 代替位字段</h3><blockquote><p>Use <code>EnumSet</code> instead of bit field.</p></blockquote><p>如果一个枚举类型的元素主要用在集合中, 传统的方式是将其定义成 <code>int</code> 常量枚举, 使每个元素都是 <code>2</code> 的不同次幂.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Text</span> <span class="token punctuation">{</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">STYLE_BOLD</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">STYLE_ITALIC</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">STYLE_UNDERLINED</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">STYLE_STRIKETHROUGH</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">applyStyles</span><span class="token punctuation">(</span><span class="token keyword">int</span> styles<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方式使得我们可以使用 <code>|</code> 或者 <code>&amp;</code> 的方式去将多个枚举常量组合为一个集合, 也称作<strong>位字段</strong>(<em>bit field</em>).</p><p>通过如下方式使用:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>text<span class="token punctuation">.</span><span class="token function">applyStyles</span><span class="token punctuation">(</span><span class="token constant">STYLE_BOLE</span> <span class="token operator">|</span> <span class="token constant">STYLE_ITALIC</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但是这种方式不够直观, 而且扩展性不好, 我们在之前就已经分析过了.</p><p>Java 为我们提供了对枚举类型进行集合操作的类--<code>EnumSet</code>.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Text</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Style</span> <span class="token punctuation">{</span> <span class="token constant">BOLD</span><span class="token punctuation">,</span> <span class="token constant">ITALIC</span><span class="token punctuation">,</span> <span class="token constant">UNDERLINE</span><span class="token punctuation">,</span> <span class="token constant">STRIKETHROUGH</span> <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">applyStyles</span><span class="token punctuation">(</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Style</span><span class="token punctuation">&gt;</span></span> styles<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>   
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>API 的调用也很简单:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>text<span class="token punctuation">.</span><span class="token function">applyStyles</span><span class="token punctuation">(</span><span class="token class-name">EnumSet</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token class-name">Style</span><span class="token punctuation">.</span><span class="token constant">BOLD</span><span class="token punctuation">,</span> <span class="token class-name">Style</span><span class="token punctuation">.</span><span class="token constant">ITALIC</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="总结-36" tabindex="-1"><a class="header-anchor" href="#总结-36" aria-hidden="true">#</a> 总结-36</h4><p>Java 为枚举类的集合操作提供了便捷的 <code>EnumSet</code> API, 因此不再需要使用位字段的方式来处理.</p><h3 id="item-37-使用-enummap-而不是序数索引" tabindex="-1"><a class="header-anchor" href="#item-37-使用-enummap-而不是序数索引" aria-hidden="true">#</a> Item 37: 使用 EnumMap 而不是序数索引</h3><blockquote><p>Use <code>EnumMap</code> instead of ordinal indexing.</p></blockquote><p>有时候我们会看到一些在数组中使用枚举实例的序数作为索引的代码, 如:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Plant</span> <span class="token punctuation">{</span>
    <span class="token keyword">enum</span> <span class="token class-name">LifeCycle</span> <span class="token punctuation">{</span> <span class="token constant">ANNUAL</span><span class="token punctuation">,</span> <span class="token constant">PERENNIAL</span><span class="token punctuation">,</span> <span class="token constant">BIENNIAL</span> <span class="token punctuation">}</span>

    <span class="token keyword">final</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">LifeCycle</span> lifeCycle<span class="token punctuation">;</span>

    <span class="token class-name">Plant</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">LifeCycle</span> lifeCycle<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>lifeCycle <span class="token operator">=</span> lifeCycle<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">LifeCycle</span> <span class="token function">getLifeCycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> lifeCycle<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假设我们想要使用一个 <code>Plant</code> 数组来表示一个花园中的植物, 并且希望这些植物按照它们的 <code>LifeCycle</code> 进行划分. 可能会有如下的代码:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Plant</span><span class="token punctuation">&gt;</span></span> garden <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// add some plants to garden</span>
        
<span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">)</span>
<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Plant</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> plantsByLifeCycle <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Plant</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">[</span><span class="token class-name">Plant<span class="token punctuation">.</span>LifeCycle</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> plantsByLifeCycle<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    plantsByLifeCycle<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Plant</span> p <span class="token operator">:</span> garden<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    plantsByLifeCycle<span class="token punctuation">[</span>p<span class="token punctuation">.</span>lifeCycle<span class="token punctuation">.</span><span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码能正常运行, 但是有一些缺点:</p><ol><li>泛型和数组不能很好兼容.</li><li><strong>使用枚举实例的序数并不能很好地代表枚举实例, 不提供类型安全保证, 并且可能会因为 <code>int</code> 值的不确定性导致数组越界.</strong></li></ol><p>对于这种情况(以枚举实例作为划分的 key), 我们有更好的实现方式--使用 <code>EnumMap</code>:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Plant</span><span class="token punctuation">&gt;</span></span> garden <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// add some plants to garden</span>

<span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LifeCycle</span><span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token punctuation">&lt;</span><span class="token class-name">Plant</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> plantsByLifeCycle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EnumMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">Plant<span class="token punctuation">.</span>LifeCycle</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">LifeCycle</span> lc <span class="token operator">:</span> <span class="token class-name">LifeCycle</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> plantsByLifeCycle<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>lc<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Plant</span> p <span class="token operator">:</span> garden<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    plantsByLifeCycle<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>lifeCycle<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 <code>EnumMap</code> 的代码更加简洁, 并且能够保证类型安全, 而且不会在计算索引时出现各种错误.</p><p>需要注意的是, <code>EnumMap</code> 在构造时, 传入了 <em>key</em> 的泛型类信息 <code>Class&lt;K&gt; keyType</code>, 用于运行时获取泛型信息. 这种方式称为有界类型标记(<em>bounded type token</em>).</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">EnumMap</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> keyType<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果我们使用 <code>Stream</code> API, 上面的代码会更加简洁:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LifeCycle</span><span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token punctuation">&lt;</span><span class="token class-name">Plant</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> plantsByLifeCycle <span class="token operator">=</span> garden<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">Plant</span><span class="token operator">::</span><span class="token function">getLifeCycle</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">EnumMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">LifeCycle</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">toSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr><p>有些情况下我们可能想要使用二维数组的方式来表达从一个枚举状态到另一个枚举状态的转换, 如:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Phase</span> <span class="token punctuation">{</span>

    <span class="token constant">SOLID</span><span class="token punctuation">,</span> <span class="token constant">LIQUID</span><span class="token punctuation">,</span> <span class="token constant">GAS</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Transition</span> <span class="token punctuation">{</span>
        <span class="token constant">MELT</span><span class="token punctuation">,</span> <span class="token constant">FREEZE</span><span class="token punctuation">,</span> <span class="token constant">BOIL</span><span class="token punctuation">,</span> <span class="token constant">CONDENSE</span><span class="token punctuation">,</span> <span class="token constant">SUBLIME</span><span class="token punctuation">,</span> <span class="token constant">DEPOSIT</span><span class="token punctuation">;</span>

        <span class="token comment">// Rows indexed by from-ordinal, cols by to-ordinal</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Transition</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token constant">TRANSITIONS</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
                <span class="token punctuation">{</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token constant">MELT</span><span class="token punctuation">,</span> <span class="token constant">SUBLIME</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
                <span class="token punctuation">{</span><span class="token constant">FREEZE</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token constant">BOIL</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
                <span class="token punctuation">{</span><span class="token constant">DEPOSIT</span><span class="token punctuation">,</span> <span class="token constant">CONDENSE</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        
        <span class="token comment">// Returns the phase transition from one phase to another</span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Transition</span> <span class="token function">from</span><span class="token punctuation">(</span><span class="token class-name">Phase</span> from<span class="token punctuation">,</span> <span class="token class-name">Phase</span> <span class="token keyword">to</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token constant">TRANSITIONS</span><span class="token punctuation">[</span>from<span class="token punctuation">.</span><span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">to</span><span class="token punctuation">.</span><span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还是相同的问题, 不要在代码中使用枚举实例的序数来代表枚举实例, 它们很不方便扩展, 并且会有很多问题.</p><p>我们还是能够使用 <code>EnumMap</code> 进行优化:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Phase</span> <span class="token punctuation">{</span>

    <span class="token constant">SOLID</span><span class="token punctuation">,</span> <span class="token constant">LIQUID</span><span class="token punctuation">,</span> <span class="token constant">GAS</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Transition</span> <span class="token punctuation">{</span>
        <span class="token function">MELT</span><span class="token punctuation">(</span><span class="token constant">SOLID</span><span class="token punctuation">,</span> <span class="token constant">LIQUID</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">FREEZE</span><span class="token punctuation">(</span><span class="token constant">LIQUID</span><span class="token punctuation">,</span> <span class="token constant">SOLID</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">BOIL</span><span class="token punctuation">(</span><span class="token constant">LIQUID</span><span class="token punctuation">,</span> <span class="token constant">GAS</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">CONDENSE</span><span class="token punctuation">(</span><span class="token constant">GAS</span><span class="token punctuation">,</span> <span class="token constant">LIQUID</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">SUBLIME</span><span class="token punctuation">(</span><span class="token constant">SOLID</span><span class="token punctuation">,</span> <span class="token constant">GAS</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">DEPOSIT</span><span class="token punctuation">(</span><span class="token constant">GAS</span><span class="token punctuation">,</span> <span class="token constant">SOLID</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Phase</span> from<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Phase</span> <span class="token keyword">to</span><span class="token punctuation">;</span>

        <span class="token class-name">Transition</span><span class="token punctuation">(</span><span class="token class-name">Phase</span> from<span class="token punctuation">,</span> <span class="token class-name">Phase</span> <span class="token keyword">to</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>from <span class="token operator">=</span> from<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">to</span> <span class="token operator">=</span> <span class="token keyword">to</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Phase</span><span class="token punctuation">,</span> <span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">Phase</span><span class="token punctuation">,</span> <span class="token class-name">Transition</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> m <span class="token operator">=</span>
                <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span>t <span class="token operator">-&gt;</span> t<span class="token punctuation">.</span>from<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">EnumMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">Phase</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                        <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toMap</span><span class="token punctuation">(</span>t <span class="token operator">-&gt;</span> t<span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">,</span> t <span class="token operator">-&gt;</span> t<span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> y<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">EnumMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">Phase</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Transition</span> <span class="token function">from</span><span class="token punctuation">(</span><span class="token class-name">Phase</span> from<span class="token punctuation">,</span> <span class="token class-name">Phase</span> <span class="token keyword">to</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Map&lt;Phase, Map&lt;Phase, Transition&gt;&gt;</code> 很好的表达了: 从 <code>Phase from</code> 到 <code>Phase to</code> 的 <code>Transition</code> 的意义.</p><p>使用 <code>EnumMap</code> 有一个巨大的优点, 就是它的可扩展性非常好. 比如我们想要增加一些数据:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Phase</span> <span class="token punctuation">{</span>
    <span class="token constant">SOLID</span><span class="token punctuation">,</span> <span class="token constant">LIQUID</span><span class="token punctuation">,</span> <span class="token constant">GAS</span><span class="token punctuation">,</span> <span class="token constant">PLASMA</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Transition</span> <span class="token punctuation">{</span>
        <span class="token function">MELT</span><span class="token punctuation">(</span><span class="token constant">SOLID</span><span class="token punctuation">,</span> <span class="token constant">LIQUID</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">FREEZE</span><span class="token punctuation">(</span><span class="token constant">LIQUID</span><span class="token punctuation">,</span> <span class="token constant">SOLID</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">BOIL</span><span class="token punctuation">(</span><span class="token constant">LIQUID</span><span class="token punctuation">,</span> <span class="token constant">GAS</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">CONDENSE</span><span class="token punctuation">(</span><span class="token constant">GAS</span><span class="token punctuation">,</span> <span class="token constant">LIQUID</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">SUBLIME</span><span class="token punctuation">(</span><span class="token constant">SOLID</span><span class="token punctuation">,</span> <span class="token constant">GAS</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">DEPOSIT</span><span class="token punctuation">(</span><span class="token constant">GAS</span><span class="token punctuation">,</span> <span class="token constant">SOLID</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">IONIZE</span><span class="token punctuation">(</span><span class="token constant">GAS</span><span class="token punctuation">,</span> <span class="token constant">PLASMA</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">DEIONIZE</span><span class="token punctuation">(</span><span class="token constant">PLASMA</span><span class="token punctuation">,</span> <span class="token constant">GAS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Remainder unchanged</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>只需要新声明 <code>Phase</code> 和 <code>Transition</code> 的枚举实例即可.</p><h4 id="总结-37" tabindex="-1"><a class="header-anchor" href="#总结-37" aria-hidden="true">#</a> 总结-37</h4><p><strong>当需要在映射集合中使用枚举类实例作为 <em>key</em> 的时候, 不要使用它的序数(<code>ordinal()</code>), 而是使用更好的 <code>EnumMap</code> 配合 <code>Stream</code> API 进行处理.</strong></p><p>其实总的来说就是, 我们尽量去使用集合类, 而不是去使用各种基础的数组等类型. 集合类一方面可以更好地进行扩展, 另一方面一些特定的还能为特定的类提供更安全, 更有效率的 API.</p><h3 id="item-38-使用接口模拟可继承枚举类" tabindex="-1"><a class="header-anchor" href="#item-38-使用接口模拟可继承枚举类" aria-hidden="true">#</a> Item 38: 使用接口模拟可继承枚举类</h3><blockquote><p>Emulate extensible enums with interfaces.</p></blockquote><p>Java 的枚举类是不可继承的, 这对可扩展性带来了一定的影响. <strong>不过我们可以是枚举类都实现相同的接口来模拟继承.</strong></p><p>以我们在 <a href="#item-34-%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E8%80%8C%E4%B8%8D%E6%98%AF-int-%E5%B8%B8%E9%87%8F">Item 34</a> 的例子来说, 我们想要 <em>Operation</em> 这个枚举类的抽象 是可以扩展的, 能够添加新的具有其他功能的 <em>Operation</em>. 那么就将 <em>Operation</em> 的功能抽象为一个接口 <code>Operation</code>, 并要求与 <em>Operation</em> 相关的所有的枚举类都需要实现 <code>Operation</code> 接口. 如:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Operation</span> <span class="token punctuation">{</span>
    <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">BaseOperation</span> <span class="token keyword">implements</span> <span class="token class-name">Operation</span> <span class="token punctuation">{</span>

    <span class="token function">PLUS</span><span class="token punctuation">(</span><span class="token string">&quot;+&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">MINUS</span><span class="token punctuation">(</span><span class="token string">&quot;-&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> x <span class="token operator">-</span> y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">TIMES</span><span class="token punctuation">(</span><span class="token string">&quot;*&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">DIVIDE</span><span class="token punctuation">(</span><span class="token string">&quot;/&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> x <span class="token operator">/</span> y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> symbol<span class="token punctuation">;</span>

    <span class="token class-name">BaseOperation</span><span class="token punctuation">(</span><span class="token class-name">String</span> symbol<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>symbol <span class="token operator">=</span> symbol<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> symbol<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">ExtendedOperation</span> <span class="token keyword">implements</span> <span class="token class-name">Operation</span> <span class="token punctuation">{</span>
    
    <span class="token function">EXP</span><span class="token punctuation">(</span><span class="token string">&quot;^&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">REMAINDER</span><span class="token punctuation">(</span><span class="token string">&quot;%&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> x <span class="token operator">%</span> y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> symbol<span class="token punctuation">;</span>
    
    <span class="token class-name">ExtendedOperation</span><span class="token punctuation">(</span><span class="token class-name">String</span> symbol<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>symbol <span class="token operator">=</span> symbol<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> symbol<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用时, 只需要限制传入的参数是枚举类型的实例, 并且实现了对应的接口.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Enum</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span> <span class="token operator">&amp;</span> <span class="token class-name">Operation</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> opEnumType<span class="token punctuation">,</span> <span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Operation</span> op <span class="token operator">:</span> opEnumType<span class="token punctuation">.</span><span class="token function">getEnumConstants</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Enum</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span> <span class="token operator">&amp;</span> <span class="token class-name">Operation</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Operation</span><span class="token punctuation">&gt;</span></span> opSet<span class="token punctuation">,</span> <span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Operation</span> op <span class="token operator">:</span> opSet<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="总结-38" tabindex="-1"><a class="header-anchor" href="#总结-38" aria-hidden="true">#</a> 总结-38</h4><p><strong>使用接口来模拟可继承的枚举类以增加扩展性.</strong></p><blockquote><p>While you cannot write an extensible enum type, you can emulate it by writing an interface to accompany a basic enum type that implements the interface.</p></blockquote><ol><li>将枚举类的方法抽象到接口中.</li><li>所有的具有类似功能的枚举类都实现抽象出的接口.</li><li>使用 <code>&lt;T extends Enum&lt;T&gt; &amp; InterfaceName&gt;</code> 来限定实现了对应接口的枚举类.</li><li>使用 <code>Class&lt;T&gt;</code> 或者 <code>Collection&lt;? extends InterfaceName&gt;</code> 的方式限制参数的类型(<em>type token</em>).</li></ol><h3 id="item-39-使用注解替代命名模式" tabindex="-1"><a class="header-anchor" href="#item-39-使用注解替代命名模式" aria-hidden="true">#</a> Item 39: 使用注解替代命名模式</h3><blockquote><p>Prefer annotations to naming patterns.</p></blockquote><p>在没有注解之前, 通常使用命名模式(<em>naming pattern</em>)来标志一些会被某些工具或者框架特殊处理的类. 以 <em>JUnit</em> 为例, <em>JUnit</em> 是一个经典的测试框架, 在早期, 它是通过检测方法的名称中是否含有 <code>test</code> 前缀来判断是否需要测试的.</p><p>如: <code>testSafetyOverride</code>, 但是这样很容易因为拼写错误而出现问题. 只要 <em>JUnit</em> 没有检测到 <code>test</code> 前缀, 它就不会去自动执行测试方法. 同时, 我们也不能很方便地将一整个类的方法都定义为需要测试的方法. 它的测试范围也是很局限的, 我们无法对参数或者返回值进行很细化的测试, 比如说需要测试一个方法抛出异常是否正常.</p><p>Java 的注解很好地解决了这个问题. 我们只需要定义如下的注解:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * Indicates that the annotated method is a test method.
 * Use only on parameterless static methods.
 * 
 * <span class="token keyword">@author</span> Riicarus
 * <span class="token keyword">@create</span> 2023-10-22 14:34
 * <span class="token keyword">@since</span> 1.0.0
 */</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">METHOD</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们在这里定义了一个空注解(其中不包含任何方法), 也称之为标记注解(<em>marker annotation</em>), 它的作用是标志需要被测试的方法, 并且该方法应该是静态无参(<em>static parameterless methods</em>)的.</p><blockquote><p>It&#39;s called a <em>marker annotation</em> because it has no parameters but simply &quot;marks&quot; the annotated element.</p></blockquote><p>我们发现在注解上还能够使用注解, 这种作用于注解上的注解称为<strong>元注解(<em>meta-annotation</em>)</strong>.</p><blockquote><p>Such annotations on annotation type declarations are known as <em>meta-annotations</em>.</p></blockquote><p><code>@Retention</code> 注解定义了该注解能够被保留到哪一个阶段(源码/编译期/运行期).</p><p><code>@Target</code> 注解定义了该注解能够作用于哪些地方(类/方法/实例...).</p><p>在需要测试的类中, 我们去使用这个注解:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Sample</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">m1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">m2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    
    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">m3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;Boom&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">m4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    
    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">m5</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Invalid, it&#39;s no-static</span>
    <span class="token punctuation">}</span>   
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然注解能够在方法上进行使用了, 但是还不能自动进行测试, 因为我们没有对被注解标记的方法进行任何的操作.</p><p>下面我们对注解标记的方法进行处理, 需要使用到 Java 的反射:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestAnnotationHandler</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> tests <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> passed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> testClass <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// Get methods of the target class</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Method</span> method <span class="token operator">:</span> testClass<span class="token punctuation">.</span><span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// judge if annotated by @Test</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span><span class="token class-name">Test</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                tests<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token comment">// invoke static, the non-static methods will throw exceptions.</span>
                    method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    passed<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InvocationTargetException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">Throwable</span> exc <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getCause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>method <span class="token operator">+</span> <span class="token string">&quot; failed: &quot;</span> <span class="token operator">+</span> exc<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Invalid @Test: &quot;</span> <span class="token operator">+</span> method<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Passed: %d, Failed: %d%n&quot;</span><span class="token punctuation">,</span> passed<span class="token punctuation">,</span> tests <span class="token operator">-</span> passed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>
        <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Sample</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果如下:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>public static void riicarus.github.io.effective.annotations.Sample.m3() failed: java.lang.RuntimeException: Boom
Invalid @Test: public void riicarus.github.io.effective.annotations.Sample.m5()
public static void riicarus.github.io.effective.annotations.Sample.m7() failed: java.lang.RuntimeException: Crash
Passed: 1, Failed: 3
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们想要测试一个方法抛出的异常是否正确呢?</p><p>那就需要给注解传递参数了, 注解需要直到要检测的异常类型.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">METHOD</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Throwable</span><span class="token punctuation">&gt;</span></span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Sample</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Test</span><span class="token punctuation">(</span><span class="token class-name">ArithmeticException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">m1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">m2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Test</span><span class="token punctuation">(</span><span class="token class-name">RuntimeException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">m3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;Boom&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">m4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Test</span><span class="token punctuation">(</span><span class="token class-name">RuntimeException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">m5</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Invalid, it&#39;s no-static</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">m6</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Test</span><span class="token punctuation">(</span><span class="token class-name">ArithmeticException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">m7</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;Crash&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestAnnotationHandler</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> tests <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> passed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> testClass <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Method</span> method <span class="token operator">:</span> testClass<span class="token punctuation">.</span><span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span><span class="token class-name">Test</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                tests<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    passed<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InvocationTargetException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">Throwable</span> exc <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getCause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Throwable</span><span class="token punctuation">&gt;</span></span> excType <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span><span class="token class-name">Test</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>excType<span class="token punctuation">.</span><span class="token function">isInstance</span><span class="token punctuation">(</span>exc<span class="token punctuation">)</span><span class="token punctuation">)</span> passed<span class="token operator">++</span><span class="token punctuation">;</span>
                    <span class="token keyword">else</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Test %s failed: expected %s, got %s%n&quot;</span><span class="token punctuation">,</span> method<span class="token punctuation">,</span> excType<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exc<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Invalid @Test: &quot;</span> <span class="token operator">+</span> method<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Passed: %d, Failed: %d%n&quot;</span><span class="token punctuation">,</span> passed<span class="token punctuation">,</span> tests <span class="token operator">-</span> passed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>
        <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Sample</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试结果:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Invalid @Test: public void riicarus.github.io.effective.annotations.Sample.m5()
Test public static void riicarus.github.io.effective.annotations.Sample.m7() failed: expected java.lang.ArithmeticException, got java.lang.RuntimeException: Crash
Passed: 2, Failed: 2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样就能够指定需要测试的异常类型了. 那如果我们想要测试可能抛出的一系列异常呢?</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">METHOD</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Throwable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Test</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">ArithmeticException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">m7</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;Crash&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestAnnotationHandler</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> tests <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> passed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> testClass <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Method</span> method <span class="token operator">:</span> testClass<span class="token punctuation">.</span><span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span><span class="token class-name">Test</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                tests<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    passed<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InvocationTargetException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">Throwable</span> exc <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getCause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">int</span> oldPassed <span class="token operator">=</span> passed<span class="token punctuation">;</span>
                    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Throwable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> excTypes <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span><span class="token class-name">Test</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Throwable</span><span class="token punctuation">&gt;</span></span> excType <span class="token operator">:</span> excTypes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>excType<span class="token punctuation">.</span><span class="token function">isInstance</span><span class="token punctuation">(</span>exc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            passed<span class="token operator">++</span><span class="token punctuation">;</span>
                            <span class="token keyword">break</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>passed <span class="token operator">==</span> oldPassed<span class="token punctuation">)</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Test %s failed: %s%n&quot;</span><span class="token punctuation">,</span> method<span class="token punctuation">,</span> exc<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Invalid @Test: &quot;</span> <span class="token operator">+</span> method<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Passed: %d, Failed: %d%n&quot;</span><span class="token punctuation">,</span> passed<span class="token punctuation">,</span> tests <span class="token operator">-</span> passed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>
        <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Sample</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试结果:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Invalid @Test: public void riicarus.github.io.effective.annotations.Sample.m5()
Passed: 3, Failed: 1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>以上的功能还有另一种实现方式:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">METHOD</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Repeatable</span><span class="token punctuation">(</span><span class="token class-name">ExceptionTestContainer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Throwable</span><span class="token punctuation">&gt;</span></span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">METHOD</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">ExceptionTestContainer</span> <span class="token punctuation">{</span>
    <span class="token class-name">ExceptionTest</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当一个方法上有多个 <code>ExceptionTest</code> 注解时, 会被视作被 <code>ExceptionTestContainer</code> 注解注释, 而不是被 <code>ExceptionTest</code> 注解注释. <strong>所以在处理可重复注解时, 需要同时判断是否被单个可重复注解 <code>ExceptionTest</code> 或者多个可重复注解的包装类 <code>ExceptionTestContainer</code> 注释, 否则可能会忽略某些情况.</strong></p><p>不过 <code>getAnnotationsByType()</code> 方法不会涉及这个问题.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">isAnnotationPreset</span><span class="token punctuation">(</span><span class="token class-name">ExceptionTest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token operator">||</span> method<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span><span class="token class-name">ExceptionTestContainer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    test<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> wrappedExc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Throwable</span> exc <span class="token operator">=</span> wrappedExc<span class="token punctuation">.</span><span class="token function">getCause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> oldPasses <span class="token operator">=</span> passed<span class="token punctuation">;</span>
        <span class="token class-name">ExceptionTest</span><span class="token punctuation">[</span><span class="token punctuation">]</span> excTests <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getAnnotationByType</span><span class="token punctuation">(</span><span class="token class-name">ExceptionTest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="总结-39" tabindex="-1"><a class="header-anchor" href="#总结-39" aria-hidden="true">#</a> 总结-39</h4><p><strong>如果能够使用注解解决, 就不要把标记的事情放到命名模式中解决.</strong></p><blockquote><p>There is simply no reason to use naming patterns when you can use annotations instead.</p></blockquote><p><strong>应该多使用 Java 提供的注解.</strong></p><blockquote><p>All programmers should use the predefined annotation types that Java provides.</p></blockquote><h3 id="item-40-总是使用-override-注解" tabindex="-1"><a class="header-anchor" href="#item-40-总是使用-override-注解" aria-hidden="true">#</a> Item 40: 总是使用 Override 注解</h3><blockquote><p>Consistently use the <code>Override</code> annotation.</p></blockquote><p>Java 官方为我们提供了一些可用的注解类型, 其中最重要的是 <code>@Override</code> 注解. <code>Override</code> 注解只能被用于方法声明上, 表示被注释的方法重写了一个父类的方法. 总是使用 <code>@Override</code> 注解可以避免很多继承上的问题, 保证子类对父类方法的重写/实现不会出现问题.</p><blockquote><p>Use the <code>Override</code> annotation on every method declaration that you believe to override a superclass declaration.</p></blockquote><h4 id="总结-40" tabindex="-1"><a class="header-anchor" href="#总结-40" aria-hidden="true">#</a> 总结-40</h4><p>只要重写了父类的方法, 就在对应方法上 <code>@Override</code> 注解.</p><h3 id="item-41-使用标记接口来定义类型" tabindex="-1"><a class="header-anchor" href="#item-41-使用标记接口来定义类型" aria-hidden="true">#</a> Item-41: 使用标记接口来定义类型</h3><blockquote><p>Use marker interfaces to define types.</p></blockquote><p>标记接口是不包含任何方法声明的接口, 只用来指定(或者说标记)实现类该接口的类具有某些属性. 比如说 <code>Serializable</code> 接口, 它自身不包含任何方法声明, 只是标记实现了这个接口的类实例可以被写入到 <code>ObjectOutputStream</code> 中, 即可以被序列化.</p><p>单从标记这个功能看, 可能标记接口和标记注解的功能类似, 但是标记接口在下面两个方面更有优势:</p><p><strong>标记接口定义了一种类型, 所有实现这个接口的类实例都会被标记; 标记注解不行.</strong> 我们可以通过标记接口在编译期发现一些错误, 而不需要像标记注解那样要等到运行期.</p><blockquote><p>Marker interfaces define a type that is implements by instance of the marked class; marker annotations do not.</p></blockquote><p><strong>标记接口的另一个优点是他们能被精确地定位到.</strong> 如果使用被元注解 <code>@Target(ElementType.TYPE)</code> 修饰的标记注解去标记类, 那我们需要在所有的类中寻找被标记的类; 但是使用标记接口实现就不需要, 因为我们可以确定传入的一定是实现了对应标记接口的实例. Java 中的 <code>Set</code> 就是一个很好的例子, 它是一个限制标记接口(<em>restricted marker interface</em>), 只继承了 <code>Collection</code> 接口, 没有增加任何的方法, 只用于限定其子类都是 <code>Set</code> 类型的(但是 <code>Set</code> 接口重写了部分 <code>Collection</code> 接口中方法的实现).</p><blockquote><p>Another advantage of marker interfaces over marker annotations is that they can be targeted more precisely.</p></blockquote><p><strong>标记注解的主要优点在于它们是基于注解注解的设施的一部分.</strong> 使用标记注解可以在基于注解的框架中获得更好的功能支持, 比如 <em>Spring</em> 框架.</p><blockquote><p>The chief advantage of marker annotations over marker interfaces is that they are part of the larger annotation facility.</p></blockquote><p>那我们如何在两者间进行选择呢?</p><p><strong>如果需要对类或接口以外的元素进行标记, 如: 字段, 方法等, 只能使用标记注解.</strong></p><p><strong>如果是对类或者接口进行标记, 那么考虑是否有方法需要限制只接受被标记的类或接口的实例? 如果是, 使用标记接口; 如果不是, 都可以选择.</strong></p><h4 id="总结-41" tabindex="-1"><a class="header-anchor" href="#总结-41" aria-hidden="true">#</a> 总结-41</h4><p>当我们在设计对类或者接口进行标记的功能时, 优先考虑使用标记接口.</p><blockquote><p>If you find yourself writing a marker annotation type whose target is <code>ElementType.TYPE</code>, take time to figure out whether it really should be an annotation type or whether a marker interface would be more appropriate.</p></blockquote><h2 id="lambdas-与-streams" tabindex="-1"><a class="header-anchor" href="#lambdas-与-streams" aria-hidden="true">#</a> Lambdas 与 Streams</h2><blockquote><p>Lambdas and Streams</p></blockquote><p>在 Java 8 中, <strong>函数式接口</strong>, <strong>Lambda 表达式</strong>和<strong>方法引用</strong>是避不开的话题.</p><h3 id="item-42-使用-lambda-表达式替代匿名类" tabindex="-1"><a class="header-anchor" href="#item-42-使用-lambda-表达式替代匿名类" aria-hidden="true">#</a> Item 42: 使用 Lambda 表达式替代匿名类</h3><blockquote><p>Prefer lambdas to anonymous classes.</p></blockquote><p>在 Java 8 之前, 我们通常使用匿名类来实现函数式类型(<em>functional type</em>, 只有一个抽象方法的接口), 这种匿名类的实例一般称为函数式对象(<em>functional object</em>).</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>words<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">String</span> s1<span class="token punctuation">,</span> <span class="token class-name">String</span> s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>匿名类在策略模式(<em>Strategy Pattern</em>)中被广泛使用. <code>Comparator</code> 接口作为排序的抽象策略, 基于抽象策略的匿名类作为排序的具体策略</strong>.</p><p>但是我们可以看到, 使用匿名类很繁琐, 可读性不是很好.</p><p>好在在 Java 8 之后, 我们可以使用使用 Lambda 表达式了:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>words<span class="token punctuation">,</span> <span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在上面的代码中, 我们甚至不需要为 Lambda 表达式的形参声明类型, 因为这能够从上下文中获取. 但是有些情况可能不行, 就需要我们手动指定形参的类型.</p><blockquote><p>Omit the types of all lambda parameter unless their presence makes your program clearer.</p></blockquote><p>在使用 Lambda 表达式时, 更需要注意泛型的使用. Lambda 表达式的形参类型很多时候都是通过上下文中的泛型类型获取的.</p><p>如果使用方法引用, 上文中的 Lambda 表达式还能够更加简单:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>words<span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparingInt</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">length</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// shorter using List.sort() interface after Java 8.</span>
words<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparingInt</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">length</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>回想在 <a href="#item-34-%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E8%80%8C%E4%B8%8D%E6%98%AF-int-%E5%B8%B8%E9%87%8F">Item 34</a> 中我们设计的 <code>Operation</code> 类, 是不是也可以使用 Lambda 表达式来定义 <code>apply()</code> 方法呢?</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">BaseOperation</span> <span class="token keyword">implements</span> <span class="token class-name">Operation</span> <span class="token punctuation">{</span>

    <span class="token function">PLUS</span><span class="token punctuation">(</span><span class="token string">&quot;+&quot;</span><span class="token punctuation">,</span> <span class="token class-name">Double</span><span class="token operator">::</span><span class="token function">sum</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">MINUS</span><span class="token punctuation">(</span><span class="token string">&quot;-&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> x <span class="token operator">-</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">TIMES</span><span class="token punctuation">(</span><span class="token string">&quot;*&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> x <span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">DIVIDE</span><span class="token punctuation">(</span><span class="token string">&quot;/&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> x <span class="token operator">/</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> symbol<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">DoubleBinaryOperator</span> op<span class="token punctuation">;</span>

    <span class="token class-name">BaseOperation</span><span class="token punctuation">(</span><span class="token class-name">String</span> symbol<span class="token punctuation">,</span> <span class="token class-name">DoubleBinaryOperator</span> op<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>symbol <span class="token operator">=</span> symbol<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>op <span class="token operator">=</span> op<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> symbol<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> left<span class="token punctuation">,</span> <span class="token keyword">double</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> op<span class="token punctuation">.</span><span class="token function">applyAsDouble</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们使用了 JDK 提供的 <code>DoubleBinaryOperator</code>, 是一个函数式接口, 接收两个 <code>double</code> 类型的参数, 返回一个 <code>double</code> 类型的参数.</p><p>既然可以使用 Lambda 表达式代替, 那是不是说明使用匿名类的实现方法已经过时了呢? 其实不然.</p><p><strong>Lambda 表达式没有名称和文档, 如果一个表达式需要解释, 或者它需要好几行才能够完成, 那么不要使用 Lambda 表达式.</strong></p><blockquote><p>Lambdas lack names and documentation; if a computation isn&#39;t self-explanatory, or exceeds a few lines, don&#39;t put it in a lambda.</p></blockquote><p>Lambda 表达式的最佳实现就是一行代码描述清楚, 最多不要超过三行代码, 否则可能带来很差的可读性和可维护性.</p><p>并且, <strong>Lambda 表达式只能用于实现只有一个抽象方法的接口</strong>. 如果是抽象类或者有多个抽象方法需要重写, 那么只能使用匿名类的方式实现.</p><p><strong>Lambda 表达式是没有状态的, 无法通过 <code>this</code> 获取自身引用, 也不能在其中使用外部的变量.</strong></p><p>还有很重要的一点: <strong>不要序列化 Lambda 表达式</strong>.</p><blockquote><p>You should rarely, if ever, serialize a lambda(or an anonymous class).</p></blockquote><p>如果需要, 请将它使用私有静态内部类(<em>private static nested class</em>)实现.</p><h4 id="总结-42" tabindex="-1"><a class="header-anchor" href="#总结-42" aria-hidden="true">#</a> 总结-42</h4><p>使用 Lambda 表达式去替代不需要创建多个实例的函数式对象.</p><blockquote><p>Don&#39;t use anonymous class for function objects unless you have to create instances of types that aren&#39;t functional interfaces.</p></blockquote><h3 id="item-43-使用方法引用替代-lambda-表达式" tabindex="-1"><a class="header-anchor" href="#item-43-使用方法引用替代-lambda-表达式" aria-hidden="true">#</a> Item 43: 使用方法引用替代 Lambda 表达式</h3><blockquote><p>Prefer <em>method reference</em> to lambdas.</p></blockquote><p>其实我们在上一个 Item 中就已经有过例子了, 使用方法引用的代码更加简洁.</p><p><strong>如果一个 Lambda 表达式能够被方法引用替代, 那就使用方法引用</strong>. 当然, 如果一个地方没法使用 Lambda 表达式, 那方法引用也没有任何作用.</p><p>emmmm, 这里有一个特例...</p><p>如果方法引用的名称太长了, 那还是用 Lambda 吧(:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">WellThisIsAVeryLongName</span><span class="token operator">::</span><span class="token function">action</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// not so good</span>

service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// shorter and more readable</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><p>刚开始接触方法引用可能会觉得很不好理解, 这里有一个方法引用的表单:</p><table><thead><tr><th style="text-align:left;">Method Ref Type</th><th style="text-align:left;">Example</th><th style="text-align:left;">Lambda Equivalent</th></tr></thead><tbody><tr><td style="text-align:left;">Static</td><td style="text-align:left;"><code>Integer::parseInt</code></td><td style="text-align:left;"><code>str -&gt; Integer.parseInt(str)</code></td></tr><tr><td style="text-align:left;">Bound</td><td style="text-align:left;"><code>Instant.now()::isAfter</code></td><td style="text-align:left;"><code>Instant then = Instant.now(); t -&gt; then.isAfter(t)</code></td></tr><tr><td style="text-align:left;">Unbound</td><td style="text-align:left;"><code>String::toLowerCase</code></td><td style="text-align:left;"><code>str -&gt; str.toLowerCase()</code></td></tr><tr><td style="text-align:left;">Class Constructor</td><td style="text-align:left;"><code>TreeMap&lt;K, V&gt;::new</code></td><td style="text-align:left;"><code>() -&gt; new TreeMap&lt;K, V&gt;()</code></td></tr><tr><td style="text-align:left;">Array Constructor</td><td style="text-align:left;"><code>int[]::new</code></td><td style="text-align:left;"><code>len -&gt; new int[len]</code></td></tr></tbody></table><h4 id="总结-43" tabindex="-1"><a class="header-anchor" href="#总结-43" aria-hidden="true">#</a> 总结-43</h4><p><strong>如果方法引用更加简洁, 那就用; 否则还是乖乖用 Lambda.</strong></p><blockquote><p>Where <em>method references</em> are shorter and clearer, use them; where they aren&#39;t, stick with lambdas.</p></blockquote><h3 id="item-44-使用标准的函数式接口" tabindex="-1"><a class="header-anchor" href="#item-44-使用标准的函数式接口" aria-hidden="true">#</a> Item 44: 使用标准的函数式接口</h3><blockquote><p>Favor the use of standard functional interfaces.</p></blockquote><p>函数式接口的引入导致 Java 中一些编程的最佳实践也在发生改变. 就拿<strong>模板方法模式</strong>来说, 我们在抽象类中定义模板方法, 提供抽象方法; 子类实现抽象方法. 我们现在更倾向于子类通过提供静态工厂方法或者构造方法的方式接收一个函数式对象来达到相同的效果.</p><p>比如如果我们希望将 <code>LinkedHashMap</code> 作为 <strong>LRUCache</strong> 来使用, 我们需要重写它的一些方法:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LRUCache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> size<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样做没有任何问题, 但是我们可以用 Lambda 来实现. 如果 <code>LinkedHashMap</code> 将来要被重写, 应该会使用静态工厂方法或者构造方法接收一个函数式对象. 那我们如何在 Lambda 中判断集合的大小呢? 在我们定义 Lambda 的时候, 无法获取到 <code>Map.Entry&lt;K, V&gt;</code> 对象, 因为我们传递的 Lambda 对象不是 <code>LinkedHashMap</code> 的实例, 无法调用它的 <code>size()</code> 方法. 因此 <code>LinkedHashMap</code> 必须在调用时传递自身引用, 以及集合中最近最少使用的 <code>Map.Entry&lt;K, V&gt;</code> 实例.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">EldestEntryRemovalFunction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">,</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> eldest<span class="token punctuation">)</span><span class="token punctuation">;</span>   
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不过, 最好不要在代码中使用这个方法, 因为 <code>java.util.function</code> 包提供了标准函数式接口 <code>BiPredicate&lt;T, U&gt;</code>, 我们只需要传递 <code>BiPredicate&lt;Map&lt;K, V&gt;, Map.Entry&lt;K, V&gt;&gt;</code> 类型的 Lambda 变量即可.</p><p><strong>思考</strong>: 为什么这里需要传递 <code>Map.Entry&lt;K, V&gt;</code> 对象?</p><p>直接看 JavaDoc:</p><blockquote><p>Returns true if this map should remove its eldest entry. This method is invoked by put and putAll after inserting a new entry into the map. It provides the implementor with the opportunity to remove the eldest entry each time a new one is added. This is useful if the map represents a cache: it allows the map to reduce memory consumption by deleting stale entries.</p><p>Sample use: this override will allow the map to grow up to 100 entries and then delete the eldest entry each time a new entry is added, maintaining a steady state of 100 entries.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAX_ENTRIES</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>

    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token constant">MAX_ENTRIES</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>This method typically does not modify the map in any way, instead allowing the map to modify itself as directed by its return value. It is permitted for this method to modify the map directly, but if it does so, it must return false (indicating that the map should not attempt any further modification). The effects of returning true after modifying the map from within this method are unspecified.</strong></p><p>This implementation merely returns false (so that this map acts like a normal map - the eldest element is never removed).</p></blockquote><hr><p>Java 提供了很多标准的函数式接口, 我们可以来看看一些常用的:</p><table><thead><tr><th style="text-align:left;">Interface</th><th style="text-align:left;">Function Signature</th><th style="text-align:left;">Example</th></tr></thead><tbody><tr><td style="text-align:left;"><code>UnaryOperator&lt;T&gt;</code></td><td style="text-align:left;"><code>T apply(T t)</code></td><td style="text-align:left;"><code>String::toLowerCase</code></td></tr><tr><td style="text-align:left;"><code>BinaryOperator&lt;T&gt;</code></td><td style="text-align:left;"><code>T apply(T t1, T t2)</code></td><td style="text-align:left;"><code>BigInteger::add</code></td></tr><tr><td style="text-align:left;"><code>Predicate&lt;T&gt;</code></td><td style="text-align:left;"><code>boolean test(T t)</code></td><td style="text-align:left;"><code>Collection::isEmpty</code></td></tr><tr><td style="text-align:left;"><code>Function&lt;T, R&gt;</code></td><td style="text-align:left;"><code>R apply(T t)</code></td><td style="text-align:left;"><code>Arrays::asList</code></td></tr><tr><td style="text-align:left;"><code>Supplier&lt;T&gt;</code></td><td style="text-align:left;"><code>T get()</code></td><td style="text-align:left;"><code>Instant::now</code></td></tr><tr><td style="text-align:left;"><code>Consumer&lt;T&gt;</code></td><td style="text-align:left;"><code>void accept(T t)</code></td><td style="text-align:left;"><code>System.out::println</code></td></tr></tbody></table><hr><p>在使用函数式接口的时候, 如果能够使用基础类型, 就尽量不要使用包装类型.</p><blockquote><p>Don&#39;t be tempted to use basic functional interfaces with boxed primitives instead of primitive functional interfaces.</p></blockquote><p>如果我们自己定义函数式接口, 需要在接口上使用 <code>@FunctionalInterface</code> 注解, 指定它是一个函数式的接口.</p><blockquote><p>Always annotate your functional interfaces with the <code>@FunctionalInterface</code> annotation.</p></blockquote><p>还有一点需要注意, <strong>当我们在设计使用函数式接口的 API 时, 尽量不要重载接口</strong>, 这样可能会导致编译器无法判断使用哪一个接口. 如: <code>ExecutorService#submit()</code> 方法既可以接收 <code>Callable&lt;T&gt;</code> 类型的参数, 也可以接收 <code>Runnable</code> 类型的参数, 这会带来一些困扰.</p><h4 id="总结-44" tabindex="-1"><a class="header-anchor" href="#总结-44" aria-hidden="true">#</a> 总结-44</h4><p>当我们需要函数式接口的时候, 优先考虑有没有标准函数式接口能够实现, 再考虑自己新建一个接口的问题.</p><h3 id="item-45-明智地使用-stream-api" tabindex="-1"><a class="header-anchor" href="#item-45-明智地使用-stream-api" aria-hidden="true">#</a> Item 45: 明智地使用 Stream API</h3><blockquote><p>Use streams judiciously.</p></blockquote><p>Stream API 是 Java 8 提供的一个语法糖. Stream API 提供了两种抽象:</p><ol><li>流(<em>stream</em>): 一个包含有限或者无限个元素的序列.</li><li>流管道(<em>stream pipeline</em>): 对流中元素进行不同的处理.</li></ol><p>一个流管道包含了一个数据源以及一系列的中间操作, 还有一个终止操作.</p><blockquote><p>A stream pipeline consists of a source stream followed by zero or more <em>intermediate operations</em> and <strong>one</strong> <em>terminal operation</em>.</p></blockquote><ul><li>中间操作: 对流中的元素进行某种转换, 如: <code>map()</code>, <code>filter()</code> 等. <strong>中间操作会将一个流转换成另一个流.</strong></li><li>终止操作: 对流进行最终计算的过程, 获取一个结果. 结果可以是一个新的集合, 某个元素, 或者某些分析对象.</li></ul><p>流管道的计算是延迟的: <strong>结果的计算只会发生在终止操作被调用时; 流中的数据项不需要按照顺序去被处理, 因此流管道可以处理无限流.</strong></p><blockquote><p>Stream pipelines are evaluated <em>lazily</em>: evaluation doesn&#39;t start until the terminal operation is invoked, and data elements that aren&#39;t required in order to complete the terminal operation that are never computed.</p></blockquote><p>注意, 如果一个流的处理没有终止操作, 那么对流不会有任何的处理动作. 所以一定要在一次流处理中使用终止操作.</p><p>Stream API 的调用是很平滑的, 它允许各个 API 之间进行链式调用, 从而组合成一个单一的表达式. 如:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>w <span class="token operator">-&gt;</span> w<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toMap</span><span class="token punctuation">(</span>o <span class="token operator">-&gt;</span> o<span class="token punctuation">,</span> o <span class="token operator">-&gt;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token operator">++</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Stream API 的链式调用是有序的, 但是也可以使用 <code>parallel()</code> 方法使其并行计算, 不过一般不使用.</p><hr><p>Stream API 的使用不是必须的. 合理使用 Stream 可以使得代码更简洁; 反之, 代码可读性会很差. 我们会给出一些 tips.</p><p>我们考虑以下的需求:</p><p><em>我们想要一个程序能够从字典文件中读取文件词语, 并且打印大小达到用户指定大小的字母异位词集合.</em></p><p>我们可以写出以下的代码:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Anagrams</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">FileNotFoundException</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> fileName <span class="token operator">=</span> <span class="token string">&quot;words.txt&quot;</span><span class="token punctuation">;</span>
        <span class="token class-name">File</span> dictionary <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> minGroupSize <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> groups <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">Scanner</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>dictionary<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">String</span> word <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                groups<span class="token punctuation">.</span><span class="token function">computeIfAbsent</span><span class="token punctuation">(</span><span class="token function">alphabetize</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>unused<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> group <span class="token operator">:</span> groups<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>group<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> minGroupSize<span class="token punctuation">)</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>group<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;: &quot;</span> <span class="token operator">+</span> group<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">alphabetize</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码中我们没有使用任何的 Stream API, 下面我们可以将其加入:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Anagrams</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> fileName <span class="token operator">=</span> <span class="token string">&quot;words.txt&quot;</span><span class="token punctuation">;</span>
        <span class="token class-name">Path</span> dictionary <span class="token operator">=</span> <span class="token class-name">Paths</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> minGroupSize <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> words <span class="token operator">=</span> <span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">lines</span><span class="token punctuation">(</span>dictionary<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            words<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token function">groupingBy</span><span class="token punctuation">(</span>word <span class="token operator">-&gt;</span> word<span class="token punctuation">.</span><span class="token function">chars</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">StringBuilder</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">,</span>
                            <span class="token punctuation">(</span>sb<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> c<span class="token punctuation">)</span><span class="token punctuation">,</span>
                            <span class="token class-name">StringBuilder</span><span class="token operator">::</span><span class="token function">append</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>group <span class="token operator">-&gt;</span> group<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> minGroupSize<span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>group <span class="token operator">-&gt;</span> group<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;: &quot;</span> <span class="token operator">+</span> group<span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们把所有的数据操作都融合到了一个表达式中, 但是我们发现代码变得很难理解了, 非常复杂.</p><blockquote><p>Overusing streams makes programs hard to read and maintain.</p></blockquote><p>那再来优化一下:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Anagrams</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        <span class="token class-name">Path</span> dictionary <span class="token operator">=</span> <span class="token class-name">Paths</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;words.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> minGroupSize <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
        
        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> words <span class="token operator">=</span> <span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">lines</span><span class="token punctuation">(</span>dictionary<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            words<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">Anagrams</span><span class="token operator">::</span><span class="token function">alphabetize</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>group <span class="token operator">-&gt;</span> group<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> minGroupSize<span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>group <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>group<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;: &quot;</span> <span class="token operator">+</span> group<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">alphabetize</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们只是把判断一个词是否是字母异位词的逻辑抽离到了一个方法中, 就可以使表达式简洁很多. 还要注意, 参数的命名在 Stream API 和 Lambda 表达式中非常重要, 会对代码的可读性产生很大的影响. <strong>尽量使 Lambda 表达式的参数具有良好的可读性.</strong></p><blockquote><p>In the absence of explicit types, careful naming of lambda parameters is essential to the readability of stream pipelines.</p></blockquote><p>在 Stream API 中使用辅助方法(<em>help method</em>)对代码的可读性提升更好. 因为 Lambda 中的参数没有清楚的类型定义信息和变量名称.</p><blockquote><p>Using helper methods is even more important for readability in stream pipelines than in iterative code because pipelines lack explicit type information and named temporary variables.</p></blockquote><p>注意, 对于 <code>char</code> 类型的值, 我们最好不要使用 Stream API.</p><blockquote><p>You should refrain from using streams to process <code>char</code> values.</p></blockquote><p>我们给一个例子:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token string">&quot;Hello world!&quot;</span><span class="token punctuation">.</span><span class="token function">chars</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">print</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 721011081081113211911111410810033</span>

<span class="token string">&quot;Hello world!&quot;</span><span class="token punctuation">.</span><span class="token function">chars</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>c <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hello world!</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在我们重构代码时, 可以将旧代码使用 Stream API 来优化, 并在新代码中合理使用 Stream API.</p><blockquote><p>Refactor existing code to use streams and use them in new code only where it makes sense to do so.</p></blockquote><h4 id="总结-45" tabindex="-1"><a class="header-anchor" href="#总结-45" aria-hidden="true">#</a> 总结-45</h4><p>合理使用 Stream API 能够使代码更加简洁, 但是使用时需要注意代码的可读性.</p><p>当我们不能确定是否使用 Stream API 时, 可以用两种方式都实现一下, 看一看哪一个代码更好.</p><blockquote><p>If you&#39;re not sure whether a task is better served by streams or iteration, try both and see which works better.</p></blockquote><h3 id="item-46-在流中使用无副作用函数" tabindex="-1"><a class="header-anchor" href="#item-46-在流中使用无副作用函数" aria-hidden="true">#</a> Item-46: 在流中使用无副作用函数</h3><blockquote><p>Prefer side-effect-free functions in streams.</p></blockquote><p><em>Stream 不只为我们提供了 API, 更重要的是为我们提供了一个函数式编程的范式(paradigm).</em></p><p>我们需要思考的是如何在每一步对流中的元素进行变换, 然后得到我们想要的结果. 函数式编程的范式就是尽量使得每个阶段(一次 API 调用)都是一个纯函数(<em>pure function</em>, 结果只依赖输出, 不依赖状态).</p><p><strong>所以说, 我们在中间操作和终止操作的逻辑中都应该保证没有副作用.</strong></p><p>这里举一个反例:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> freq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> words <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">tokens</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    words<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>word <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        freq<span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>word<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1L</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token operator">::</span><span class="token function">sum</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码能够正常运行, 但是它并不是 Stream API 想要我们使用的方式. <code>forEach()</code> 应该只是一个用来呈现最终计算结果的终止操作, 而不应该用来做其他的事情. 上面的代码中我们还更改了 <code>freq</code> 的状态, 导致这并不是无副作用的操作.</p><p>可以对上面的代码进行优化:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> freq<span class="token punctuation">;</span>

<span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> words <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">tokens</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    freq <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">toLowerCase</span><span class="token punctuation">,</span> <span class="token function">counting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样之后, 代码更加简洁, 也更符合 Stream API 的范式.</p><p><strong><code>forEach()</code> 操作只应该被用来呈现 Stream 的计算结果, 而不应该作为计算的一部分.</strong></p><blockquote><p>The <code>forEach()</code> operation should be used only to report the result of a stream computation, not to perform the computation.</p></blockquote><p>如果读者完全按照上文中的代码进行复现时, 会发现很多方法都不能被 IDEA 识别, 因为我们通过静态导包(<em>static import</em>)的方式隐藏了调用他们的类.</p><p><strong>在使用 <code>Collectors</code> 的 API 时, 我们通常都会将其静态导包, 因为这样代码可可读性更好.</strong></p><blockquote><p>It is customary and wise to statically import all members of <code>Collectors</code> because it makes stream pipelines more readable.</p></blockquote><h4 id="总结-46" tabindex="-1"><a class="header-anchor" href="#总结-46" aria-hidden="true">#</a> 总结-46</h4><p>在 Stream API 中, 尽量使用无副作用的函数式方法. 注意理解 Stream API 提供的函数式编程的范式.</p><h3 id="item-47-使用-collection-作为-stream-api-的返回类型-而不是-stream" tabindex="-1"><a class="header-anchor" href="#item-47-使用-collection-作为-stream-api-的返回类型-而不是-stream" aria-hidden="true">#</a> Item 47: 使用 Collection 作为 Stream API 的返回类型, 而不是 Stream</h3><blockquote><p>Prefer <code>Collection</code> to <code>Stream</code> as a return type.</p></blockquote><p><code>Stream</code> 并没有为使用者提供非常好的迭代器支持, 而 <code>Collection</code> 提供了. <code>Stream</code> 只能通过 <code>forEach()</code> 方法进行遍历迭代, 而不能通过 <code>Iterable</code> 的方式. 但是 <code>Collection</code> 提供了 <code>Iterable</code> 方式的迭代, 使用更加灵活.</p><p><strong>使用者通常会希望 Stream API 的计算结果能够很好地被迭代遍历, 因此更推荐使用 <code>Collection</code> 作为返回值.</strong></p><p><strong><code>Collection</code> 或者它的合适的子类总是公开的, 返回值有序的方法的首选返回类型.</strong></p><blockquote><p><code>Collection</code> or an appropriate subtype is generally the best return type for a public, sequence-returning method.</p></blockquote><p><strong>但是不要为了能够返回集合而把很大的一个序列保存在内存中.</strong></p><blockquote><p>But do not store a large sequence in memory just to return it as a collection.</p></blockquote><h4 id="总结-47" tabindex="-1"><a class="header-anchor" href="#总结-47" aria-hidden="true">#</a> 总结-47</h4><p>尽量方法的结果通过 <code>Collection</code> 返回, 因为我们不知道用户想要将结果用作 Stream 的处理还是想要使用迭代器去迭代其中的元素. 如果不方便使用 <code>Collection</code> 返回时, 才使用 <code>Stream</code> 作为返回类型.</p><h3 id="item-48-谨慎使用并行流" tabindex="-1"><a class="header-anchor" href="#item-48-谨慎使用并行流" aria-hidden="true">#</a> Item 48: 谨慎使用并行流</h3><blockquote><p>Use caution when making streams parallel.</p></blockquote><p><strong>如果流的源来自于 <code>Stream.iterate()</code>, 或者在中间过程中使用了 <code>limit()</code> 方法, 那么并行流并不能提升性能.</strong></p><blockquote><p>Parallelizing a pipeline is unlikely to increase its performance if the source is from <code>Stream.iterate()</code>, or the intermediate operation <code>limit()</code> is used.</p></blockquote><p><strong>不要不加区别地并行化管道.</strong></p><blockquote><p>Do not parallelize stream pipelines indiscriminately.</p></blockquote><p>有一个经验规律:</p><p><strong>能从并行流中得到较大提升的流的源通常是 <code>ArrayList</code>, <code>HashMap</code>, <code>HashSet</code> 和 <code>ConcurrentHashMap</code> 实例, 以及数组和 <code>int</code>, <code>long</code> 类型的区间.</strong></p><blockquote><p>Performance gains from parallelism are best on streams over <code>ArrayList</code>, <code>HashMap</code>, <code>HashSet</code> and <code>ConcurrentHashMap</code> instances; arrays; int ranges; long ranges.</p></blockquote><p>因为这些数据结构都能够很简单地被分成任意大小的子集, 很容易并行化. 还有一个原因就是这些数据结构在内存中都是存储在同一块内存区域的, 不需要为了并行而去多次加载内存.</p><p><strong>流管道的终止操作也会对并行的效率造成很大的影响.</strong> 如果在终止操作中需要进行大量的计算, 那么并行的效率提升时很少的. 通常, 对 Stream 的**规约(<em>reduce</em>)<strong>操作, 或者封装后的规约操作(<code>min()</code>, <code>max()</code>, <code>count()</code>, <code>sum()</code>, .etc)能够很好地利用并行性能. 类似 <code>anyMatch()</code>, <code>allMatch()</code> 之类的</strong>短路(<em>short-circuiting</em>)**操作也和并行流配合地很好.</p><p>相反, 类似 <code>collect()</code> 之类的<strong>动态规约</strong>(<em>mutable reduction</em>)操作和并行流就不是很适配, 因为合并集合的性能消耗是很大的.</p><p><strong>对并行流的不当使用不只会造成低性能, 还可能导致运行失败或者得到错误的结果.</strong></p><blockquote><p>Not only can parallelizing a stream lead to poor performance, including liveness failures; it can lead to incorrect results and unpredictable behavior.</p></blockquote><p>在合理使用下, 通过 <code>parallel()</code> 使用并行流可以带来基于 CPU 核数的近乎线性的性能提升.</p><blockquote><p>User the right circumstances, it is possible to achieve near-line speedup in the number of processor cores simply by adding a <code>parallel()</code> call to a stream pipeline.</p></blockquote><h4 id="总结-48" tabindex="-1"><a class="header-anchor" href="#总结-48" aria-hidden="true">#</a> 总结-48</h4><p>只有在确定能够提升性能的前提下才使用并行流.</p><h2 id="方法" tabindex="-1"><a class="header-anchor" href="#方法" aria-hidden="true">#</a> 方法</h2><blockquote><p>Methods</p></blockquote><h3 id="item-49-检查参数有效性" tabindex="-1"><a class="header-anchor" href="#item-49-检查参数有效性" aria-hidden="true">#</a> Item 49: 检查参数有效性</h3><blockquote><p>Check parameters for validity.</p></blockquote><p>我们在很多方法中都需要对参数进行某些限制, 也就是需要进行参数校验. 我们在为这些方法编写文档时, 需要清除地写明参数的校验需求; 并在方法逻辑的开始就进行参数的校验. 如果不对参数进行正确的校验, 可能会导致整个服务都出现错误.</p><p><strong>当校验到无效参数时, 需要及时(尽可能早)地抛出异常.</strong></p><p>在参数校验中我们通常会抛出的方法有: <code>IllegalArgumentException</code>, <code>IndexOutOfBoundsException</code>, <code>NullPointerException</code>, <code>ArithmeticException</code> 等. 我们需要在方法的文档中使用 <code>@throws</code> 来标明这些错误出现的情况. 如:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * Returns a BigInteger whose value is (this mod m). This method 
 * differs from the remainder method in that it always returns a non-negative BigInteger.
 * 
 * <span class="token keyword">@param</span> <span class="token parameter">m</span> the modulus, which must be positive
 * <span class="token keyword">@return</span> this mod m
 * <span class="token keyword">@throws</span> <span class="token reference"><span class="token class-name">ArithmeticException</span></span> if m is less then or equal to 0
 */</span>
<span class="token keyword">public</span> <span class="token class-name">BigInteger</span> <span class="token function">mod</span><span class="token punctuation">(</span><span class="token class-name">BigInteger</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">signum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ArithmeticException</span><span class="token punctuation">(</span><span class="token string">&quot;Modulus &lt;= 0: &quot;</span> <span class="token operator">+</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Do the computation</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在我们校验参数不为 <code>null</code> 时, 可以使用 <code>Objects.requireNonNull()</code> 方法, 它会在参数为 <code>null</code> 时自动抛出 <code>NullPointerException</code>; 如果不为 <code>null</code>, 就返回传入的参数.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">requireNonNull</span><span class="token punctuation">(</span><span class="token class-name">T</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">requireNonNull</span><span class="token punctuation">(</span><span class="token class-name">T</span> obj<span class="token punctuation">,</span> <span class="token class-name">String</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Java 9 之后, <code>java.util.Objects</code> 中加入了很多参数检查的工具方法, 因此, 如果官方包有实现, 那么我们就没有必要自己去写.</p><p>对于不需要对外暴露的方法, 开发者可以使用 <code>assert</code> 断言来检查参数.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">assert</span> a <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">assert</span> offset <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> offset <span class="token operator">&lt;=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">assert</span> length <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> length <span class="token operator">&lt;=</span> a<span class="token punctuation">.</span>length <span class="token operator">-</span> offset<span class="token punctuation">;</span>
    
    <span class="token comment">// Do the computation</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果出错, 断言 <code>assert</code> 抛出的异常是 <code>AssertionError</code>. 我们可以选择开启/关闭断言功能, 如果关闭, 断言不会生效. 使用 <code>-ea</code>/<code>-enableassertions</code> 参数来开启断言功能.</p><p><strong>如果一个参数不会立刻在方法中被使用, 而是被存储起来, 那么一定要对参数进行检查.</strong> 比如 <code>List</code>, <code>HashMap</code> 等集合类就会对参数进行检查.</p><p>如果参数的检查消耗太大, 或者对参数的检查在计算过成功隐式进行了, 那么可以不对参数进行检查. 比如 <code>Collections#sort(List)</code> 方法就不会对传入的 <code>List</code> 实例中的元素进行检查.</p><p>不过, 我们在设计方法时应该尽量做到通用性, 所以对参数的检查不是越多越好.</p><h4 id="总结-49" tabindex="-1"><a class="header-anchor" href="#总结-49" aria-hidden="true">#</a> 总结-49</h4><p>当设计方法时, 一定要注意是否需要对参数进行检查. 如果需要, 尽量使用官方已经提供的包进行检查, 并且提供完善的文档.</p><h3 id="item-50-在需要时制作防御性副本" tabindex="-1"><a class="header-anchor" href="#item-50-在需要时制作防御性副本" aria-hidden="true">#</a> Item 50: 在需要时制作防御性副本</h3><blockquote><p>Make defensive copies when needed.</p></blockquote><p><strong>在编程时, 必须假定程序的使用者会尽最大的努力破坏其不变性.</strong></p><blockquote><p>You must program defensively, with the assumption that clients of your class will do their best to destroy its invariants.</p></blockquote><p>我们在编写程序时, 有时候希望类中的字段是不变(<em>invariant</em>)的, 通常使用 <code>final</code> 关键字修饰字段, 来保证它的引用不能发生改变. 如:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Period</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Date</span> start<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Date</span> end<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Period</span><span class="token punctuation">(</span><span class="token class-name">Date</span> start<span class="token punctuation">,</span> <span class="token class-name">Date</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>start<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>start <span class="token operator">+</span> <span class="token string">&quot; after &quot;</span> <span class="token operator">+</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> start<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> end<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Date</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> start<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Date</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> end<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然 <code>start</code> 和 <code>end</code> 字段的引用确实无法被更改, 但是 <code>Date</code> 的值本身是可变的.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Date</span> start <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Date</span> end <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Period</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Period</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
end<span class="token punctuation">.</span><span class="token function">setYear</span><span class="token punctuation">(</span><span class="token number">78</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 更改了 p 中的 end 的值.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Java 8 之后, 使用 <code>Instant</code> 代替 <code>Date</code>, 因为 <code>Instant</code> 是不可变的, 不会出现上面的情况.</p><p>处理用这个方法, 我们还可以使用**防御性拷贝(<em>defensive copy</em>)**的方式来解决:</p><blockquote><p>It is essential to make a <em>defensive copy</em> of each mutable parameter to the constructor.</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Period</span><span class="token punctuation">(</span><span class="token class-name">Date</span> start<span class="token punctuation">,</span> <span class="token class-name">Date</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>start<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>end<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
    <span class="token comment">// 先复制, 再比较</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>start<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>start <span class="token operator">+</span> <span class="token string">&quot; after &quot;</span> <span class="token operator">+</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>对参数的检查一定要在防御性拷贝之后, 避免在检查后-拷贝前这段时间内参数的值被改变; 并且应该检查拷贝后的值, 而不是拷贝对象的值.</strong></p><blockquote><p>Defensive copies are mode <em>before</em> checking the validity of the parameters, and the validity check is performed on the copies rather than on the originals.</p></blockquote><p><code>clone()</code> 方法在我们之前就说过, 可能存在复制出的实例与源实例中存在相同的引用的情况. 因此, <strong>只有对信任的类才能使用 <code>clone()</code> 方法作为防御性复制的手段</strong>.</p><blockquote><p>Do not use the <code>clone()</code> method to make a defensive copy of a parameter whose type is subclassable by untrusted parties.</p></blockquote><p>通过上面的一个分析我们大致了解了可能出现不可变引用对象的值被更改的情况, 就会发现, 上文的程序还有一些问题:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Date</span> start <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Date</span> end <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Period</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Period</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span>end<span class="token punctuation">.</span><span class="token function">setYear</span><span class="token punctuation">(</span><span class="token number">78</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 更改了 p 中的 end 的值.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>所以我们需要对所有可能对外暴露不可变对象引用的方法都进行分析处理.</strong></p><p>返回可变内部字段的防御性副本.</p><blockquote><p>Return defensive copies of mutable internal fields.</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Date</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>start<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token class-name">Date</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>end<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="总结-50" tabindex="-1"><a class="header-anchor" href="#总结-50" aria-hidden="true">#</a> 总结-50</h4><p>为了使得类中的所有不可变字段都维持其不可变性, 在所有需要的地方都使用防御性副本.</p><p>当然, 如果能够直接使用不可变类是最好的.</p><h3 id="item-51-仔细设计方法签名" tabindex="-1"><a class="header-anchor" href="#item-51-仔细设计方法签名" aria-hidden="true">#</a> Item 51: 仔细设计方法签名</h3><blockquote><p>Design method signatures carefully.</p></blockquote><p>良好的方法签名能够使我们的 API 更加易于理解与使用.</p><p><strong>仔细选择方法名.</strong></p><blockquote><p>Choose method names carefully.</p></blockquote><p>方法的命名总是应该遵循基础命名规则(<a href="#item-68-%E9%81%B5%E5%AE%88%E6%99%AE%E9%81%8D%E6%8E%A5%E5%8F%97%E7%9A%84%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A">Item 68</a>). 方法名称一定要易于理解, 并且和包中的其他方法在含义上连贯. 同时, 不要让方法名称太长. 可以多学习 JDK 中方法的命名技巧.</p><hr><p><strong>不要过多提供简化方法.</strong></p><blockquote><p>Don&#39;t go overboard in providing convenience methods.</p></blockquote><p>方法应当有一定的复杂度, 不要为了可能的情况一味地提供很多的简化方法, 这会使得方法太多, 难以理解和使用. <strong>只提供确实会被经常使用的简化方法.</strong> 如果你在犹豫是否要提供, 那么就不提供.</p><hr><blockquote><p>When in doubt, leave it out.</p></blockquote><p><strong>方法要避免过长的参数列表.</strong></p><blockquote><p>Avoid long parameter lists.</p></blockquote><p>四个参数已经是能够容忍的上限了. 很多使用者无法记住很长的参数列表, 就对方法的文档有很高的依赖性, 但是文档里对参数的解释也会很多, 非常不方便. 很长的方法参数列表是有害的.</p><blockquote><p>Long sequences of identically types parameters are especially harmful.</p></blockquote><p>我们会在下文给出三个缩短参数列表的方案:</p><ol><li>将一个方法切分成很多的小方法.</li><li>使用辅助类(<em>helper class</em>)维护过多的参数.</li><li>结合(1)(2), 使用构造器(<em>builder</em>)(<a href="#item-2-%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E4%BB%A3%E6%9B%BF%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">Item 2</a>).</li></ol><hr><p><strong>优先使用接口限制参数类型, 而不是类.</strong></p><blockquote><p>For parameter types, favor interfaces over classes.</p></blockquote><p><strong>使用只有两个枚举实例的枚举类代替 <code>boolean</code> 类型.</strong></p><blockquote><p>Prefer two-element enum types to <code>boolean</code> parameters.</p></blockquote><p>还是那个原因, 枚举类能够更好地表意, 还能够有一定的功能扩展性.</p><h4 id="总结-51" tabindex="-1"><a class="header-anchor" href="#总结-51" aria-hidden="true">#</a> 总结-51</h4><p>方法的设计上要注意简洁性和易读性.</p><ol><li>方法名称要简洁.</li><li>简化方法数量不要过多.</li><li>方法参数不要过多.</li><li>方法参数应该尽量抽象, 提高兼容性和扩展性.</li></ol><h3 id="item-52-谨慎重载方法" tabindex="-1"><a class="header-anchor" href="#item-52-谨慎重载方法" aria-hidden="true">#</a> Item 52: 谨慎重载方法</h3><blockquote><p>Use overloading judiciously.</p></blockquote><p>我们先来看一段代码:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CollectionClassifier</span> <span class="token punctuation">{</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">classify</span><span class="token punctuation">(</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;Set&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">classify</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;List&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">classify</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;Unknown Collection&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Collection</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> collections <span class="token operator">=</span> <span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>
                <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BigInteger</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">:</span> collections<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">classify</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你可能觉得最后会输出:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Set
List
Unknown Collection
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但实际上是:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Unknown Collection
Unknown Collection
Unknown Collection
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为使用哪一个重载方法是在编译期确定的, 而不是在运行期. 在编译期中, 所有的元素都是 <code>Collection&lt;?&gt;</code>, 因此都使用了同一个重载方法.</p><p><strong>重载方法的确定是静态的, 而重写方法的确定是动态的.</strong></p><blockquote><p>Selection among overloaded methods is static, while selection among overridden methods is dynamic.</p></blockquote><p>重写方法需要在运行期根据当前对象的类型判断使用哪一个重写方法, 但是重载方法只需要在编译期根据传递参数的类型就能唯一确定.</p><p>上面的代码应该改为如下的格式:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">classify</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> c <span class="token keyword">instanceof</span> <span class="token class-name">Set</span> <span class="token operator">?</span> <span class="token string">&quot;Set&quot;</span> <span class="token operator">:</span>
            c <span class="token keyword">instanceof</span> <span class="token class-name">List</span> <span class="token operator">?</span> <span class="token string">&quot;List&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;Unknown Collection&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>我们需要避免令人迷惑的方法重载.</strong></p><blockquote><p>Avoid confusing uses of overloading.</p></blockquote><p>重载方法的设计有一个安全且保守的原则: <strong>永远不要暴露两个具有相同参数数量的重载方法</strong>. 因为你<strong>可以通过不同的方法命名将其改为不同的方法</strong>, 这样更便于理解.</p><blockquote><p>A safe, conservative policy is never to export two overloadings with the same number of parameters. You can always give methods different names instead of overloading them.</p></blockquote><p><strong>不要为了在相同的位置接收不同的函数式接口而重载方法.</strong></p><blockquote><p>Do not overload methods to take different functional interfaces in the same argument position.</p></blockquote><h4 id="总结-52" tabindex="-1"><a class="header-anchor" href="#总结-52" aria-hidden="true">#</a> 总结-52</h4><p>重载方法并不是一个很好的推荐, 尤其是重载具有相同参数数量的方法. 但是在构造方法中我们无法避免, 这时候需要避免可能一个参数列表会有多个可匹配的重载方法的情况.</p><h3 id="item-53-谨慎使用可变参数" tabindex="-1"><a class="header-anchor" href="#item-53-谨慎使用可变参数" aria-hidden="true">#</a> Item 53: 谨慎使用可变参数</h3><blockquote><p>Use varargs judiciously.</p></blockquote><p>我们之前了解过, Java 的可变参数是通过一个数组进行接收的. 如:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> arg <span class="token operator">:</span> args<span class="token punctuation">)</span> sum <span class="token operator">+=</span> arg<span class="token punctuation">;</span>

    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是有时候我们需要接收的是 <em>一个或者多个</em> 参数, 如果只接受一个可变参数, 就需要额外的参数检查了.</p><p>那么可以通过先接收一个参数, 再接收一个可变参数的方式进行:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span> first<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> others<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> min <span class="token operator">=</span> first<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> arg <span class="token operator">:</span> others<span class="token punctuation">)</span> min <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> min<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> min<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Varargs 设计之初是用来支持 <code>printf()</code> 方法和反射的. 相较于接收定长参数, 接收可变参数由于需要使用数组接收, 会带来一定的性能消耗问题, 如果有一些对性能敏感的方法, 但是又想要使用可变参数, 可以考虑如下的方式:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> a1<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> a1<span class="token punctuation">,</span> <span class="token keyword">int</span> a2<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> a1<span class="token punctuation">,</span> <span class="token keyword">int</span> a2<span class="token punctuation">,</span> <span class="token keyword">int</span> a3<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> a1<span class="token punctuation">,</span> <span class="token keyword">int</span> a2<span class="token punctuation">,</span> <span class="token keyword">int</span> a3<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> rest<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样主要就是会创建较多的方法, 只在需要较好的性能的时候使用. <code>EnumSet</code> 就使用了类似的方法.</p><h4 id="总结-53" tabindex="-1"><a class="header-anchor" href="#总结-53" aria-hidden="true">#</a> 总结-53</h4><p>在使用可变参数时, 注意是否需要为性能考虑.</p><h3 id="item-54-返回空集合或数组-而不是-null-对象" tabindex="-1"><a class="header-anchor" href="#item-54-返回空集合或数组-而不是-null-对象" aria-hidden="true">#</a> Item 54: 返回空集合或数组, 而不是 null 对象</h3><blockquote><p>Return empty collections or arrays, not nulls.</p></blockquote><p>尽量少使用 <code>null</code> 作为返回值来表示空集合或者数组, 这会带来多余的对 <code>null</code> 值的检查, 并且不利于理解.</p><p>我们可能会担心每次返回空集合或者数组会带来额外的内存开销, 其实大可不必. 只有在分析后确定性能消耗确实是由申请内存导致的时候, 才去考虑这种问题. 而且, 我们也有相对应的解决方案--<strong>使用不可变对象</strong>.</p><p>不可变对象可以通过自己定义, 也可以使用包中的实现:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// JDK 包</span>
<span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">emptyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 手动</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token constant">EMPTY_STRING_ARRAY</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="总结-54" tabindex="-1"><a class="header-anchor" href="#总结-54" aria-hidden="true">#</a> 总结-54</h4><p>不要返回 <code>null</code> 来代表空集合或者空数组.</p><blockquote><p>Never return null in place of an empty array or collection.</p></blockquote><h3 id="item-55-谨慎返回-optional-对象" tabindex="-1"><a class="header-anchor" href="#item-55-谨慎返回-optional-对象" aria-hidden="true">#</a> Item 55: 谨慎返回 Optional 对象</h3><blockquote><p>Return optionals judiciously.</p></blockquote><p>Java 8 引入了 <code>Optional</code> 对象来作为<strong>一个不可变对象实例</strong>的容器. 我们通常可以使用 <code>Optional&lt;T&gt;</code> 实例作为方法的返回值, 代替返回值可能为 <code>null</code> 的方法.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">E</span> result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">E</span> e <span class="token operator">:</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> e<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> result <span class="token operator">=</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意, 返回值类型为 <code>Optional&lt;T&gt;</code> 方法永远不要返回 <code>null</code> 值.</strong></p><blockquote><p>Never return a null value from an Optional-returning method.</p></blockquote><p><code>Optional</code> 可以和 Stream API 进行良好的配合:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">naturalOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果需要在值为 <code>null</code> 时抛出异常, <code>Optional</code> 也能很好的支持:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> lastWordInLexicon <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElseThrow</span><span class="token punctuation">(</span><span class="token class-name">TemperTantrumException</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果我们尝试从值为空的 <code>Optional</code> 对象中获取值时, 会抛出异常--<code>NoSuchElementException</code>.</p><p>虽然 <code>Optional</code> 和 Stream API 配合良好, 不过我们一般不会使用 <code>Stream&lt;Optional&lt;T&gt;&gt;</code> 这样的实例, 因为 <code>Stream</code> 希望其中的元素都是非空值的. 但是有一种情况例外--<code>Stream#flatMap()</code>.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>streamOfOptionals<span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token class-name">Optional</span><span class="token operator">::</span><span class="token function">stream</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在什么时候使用 <code>Optional</code> 作为返回类型呢?</p><p>当方法可能返回 <code>null</code> 值, 并且调用者需要对 <code>null</code> 值的情况进行特殊处理的时候, 就应该使用 <code>Optional&lt;T&gt;</code> 作为返回值.</p><blockquote><p>You should declare a method to return <code>Optional&lt;T&gt;</code> if it might not be able to return a result <em>and</em> clients will have to perform special processing if no result is returned.</p></blockquote><p><strong>不要在 <code>Optional&lt;T&gt;</code> 中使用其他的容器类型, 数组或者基础类型的装箱类. 对于基础类型, 应该使用对应的 <code>OptionalInt</code>, <code>OptionalLong</code> 类型.</strong></p><p><strong>不要将 <code>Optional&lt;T&gt;</code> 作为集合或者数组的 <em>key</em>, <em>value</em> 或者元素.</strong></p><p><strong>最好要将 <code>Optional&lt;T&gt;</code> 实例作为字段存储.</strong></p><h4 id="总结-55" tabindex="-1"><a class="header-anchor" href="#总结-55" aria-hidden="true">#</a> 总结-55</h4><p><code>Optional</code> 主要用于各种返回值的封装, 可以对返回值的各种处理进行增强. 不过在使用时也需要注意一些需要避免的地方.</p><h3 id="item-56-为所有暴露的-api-中的元素编写文档注释" tabindex="-1"><a class="header-anchor" href="#item-56-为所有暴露的-api-中的元素编写文档注释" aria-hidden="true">#</a> Item 56: 为所有暴露的 API 中的元素编写文档注释</h3><blockquote><p>Write doc comments for all exposed API elements.</p></blockquote><p><strong>我们需要为 API 暴露的所有类, 接口, 构造器, 方法和字段声明进行完善的注释.</strong> 不过为了更好地开发, 合作和维护, 我们同样对于未暴露的元素也应该编写完善的接口.</p><blockquote><p>To document your API properly, you must precede <em>every</em> exported class, interface, constructor, method, and field declaration with a doc comment.</p></blockquote><p><strong>方法的文档应该简明扼要地指出调用者需要遵守的规范.</strong> 比如: 在什么时候使用, 使用后会有什么影响等.</p><blockquote><p>The doc comment for a method should describe succinctly the contract between the method and its client.</p></blockquote><p>在使用时, 注意使用不同的 <em>tag</em> 来标记不同的元素.</p><ul><li><code>@param</code>: 参数</li><li><code>@return</code>: 返回值</li><li><code>@throws</code>: 可能抛出的异常</li></ul><p>其他的 <em>tag</em> 可以参考官方文档.</p><p><strong>文档应该保证在源码和生成的文档中都有很好的可读性, 如果不能兼顾, 优先保证生成的文档的可读性.</strong></p><blockquote><p>Doc comments should be readable both in the source code and in the generated documentation. If you can&#39;t achieve both, the readability of the generated documentation trumps that of the source code.</p></blockquote><p><strong>对于枚举类, 文档应该对每个枚举实例进行注释. 对注解类型也类似, 需要为每一个成员(方法)进行注释.</strong></p><blockquote><p>When documenting an enum type, be sure to document the constants as well as the type and any public methods.</p><p>When documenting an annotation type, be sure to document any members as well as the type itself.</p></blockquote><p><strong>无论方法是否是类型安全的, 都应该在文档中标明方法的类型安全等级.</strong></p><blockquote><p>Whether or not a class or static method is thread-safe, you should document its thread-safety level.</p></blockquote><p><strong>对于可序列化的类, 应该在文档中标明序列化的格式.</strong></p><h4 id="总结-56" tabindex="-1"><a class="header-anchor" href="#总结-56" aria-hidden="true">#</a> 总结-56</h4><p>文档编写是编码环节很重要的一环, 我们需要对文档进行完善的编写, 保证使用者能够很好地理解和调用.</p><h2 id="通用编程事项" tabindex="-1"><a class="header-anchor" href="#通用编程事项" aria-hidden="true">#</a> 通用编程事项</h2><blockquote><p>General programming.</p></blockquote><h3 id="item-57-最小化局部变量的作用域" tabindex="-1"><a class="header-anchor" href="#item-57-最小化局部变量的作用域" aria-hidden="true">#</a> Item 57: 最小化局部变量的作用域</h3><blockquote><p>Minimize the scope of local variables.</p></blockquote><p>Java 允许在任何合法的地方定义局部变量, 因此不用像 C 那样要求在一个块的开始处定义所有的变量. 在 Java 编程中, 尽量使局部变量的作用域最小化.</p><p><strong>最小化局部变量的作用域的最佳实现方式就是在需要变量时才声明它.</strong></p><blockquote><p>The most powerful technique for minimizing the scope of a local variable is to declare it where it is first used.</p></blockquote><p><strong>几乎所有的局部变量在声明时都应该被赋一个初始值.</strong> 有一个例外就是在使用 <code>try-catch</code> 块时, 需要在块外声明, 在块内赋值与使用.</p><blockquote><p>Nearly every local variable declaration should contain an initializer.</p></blockquote><p><strong>相较于 <code>while</code>, 优先使用 <code>for</code>.</strong> 因为 <code>for</code> 可以在它的括号中进行局部变量的声明, 确保局部变量作用域最小.</p><blockquote><p>Prefer <code>for</code> loops to <code>while</code> loops.</p></blockquote><p><strong>最后, 让方法更精简也可以让局部变量的作用域更小.</strong></p><blockquote><p>A final technique to minimize the scope of local variables is to keep methods small and focused.</p></blockquote><h3 id="item-58-使用-for-each-代替-for-循环" tabindex="-1"><a class="header-anchor" href="#item-58-使用-for-each-代替-for-循环" aria-hidden="true">#</a> Item 58: 使用 for-each 代替 for 循环</h3><blockquote><p>Prefer <code>for-each</code> loops to traditional <code>for</code> loops.</p></blockquote><p><code>for-each</code> 循环是 Java 提供的一个语法糖, 在对集合/数组/流之类的元素进行循环遍历时更加简洁, 可读性更高.</p><p><strong><code>for-each</code> 的使用需要集合实现 <code>Iterable&lt;E&gt;</code> 接口.</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// Returns an iterator over the elements in this iterable.</span>
    <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="item-59-了解并使用库" tabindex="-1"><a class="header-anchor" href="#item-59-了解并使用库" aria-hidden="true">#</a> Item 59: 了解并使用库</h3><blockquote><p>Know and use the libraries.</p></blockquote><p><strong>使用库可以让我们从专家的知识和之前的使用经验中受益.</strong></p><blockquote><p>By using a standard library, you take advantage of the knowledge of the experts who wrote it and the experience of those who used it before you.</p></blockquote><p>在官方库中, 我们需要注意使用更新的 API. 比如: 在 Java 7 之前, 我们使用 <code>Random</code> 类生成随机数, 但在这之后, 使用 <code>ThreadLocalRandom</code> 更好.</p><blockquote><p>Numerous features are added to the libraries in every major release, and it pays to keep abreast of these additions.</p></blockquote><p>官方库的性能通常是很高的, 我们不仅可以从中获得更好的性能, 还能够通过源码学习的方式, 了解设计的思路和原因.</p><p><strong>JDK 中, 我们至少需要熟悉 <code>java.lang</code>, <code>java.util</code>, <code>java.io</code> 这几个包及其子包的使用.</strong></p><blockquote><p>Every programmer should be familiar with the basics of <code>java.lang</code>, <code>java.util</code>, <code>java.io</code>, and their subpackages.</p></blockquote><p>总之, 不要重复造轮子, 多去使用和学习官方库的 API 和实现.</p><h3 id="item-60-不要在需要精确结果的地方使用-float-或-double" tabindex="-1"><a class="header-anchor" href="#item-60-不要在需要精确结果的地方使用-float-或-double" aria-hidden="true">#</a> Item 60: 不要在需要精确结果的地方使用 float 或 double</h3><blockquote><p>Avoid float and double if exact answers are required.</p></blockquote><p><strong>在开发中, <code>float</code> 和 <code>double</code> 非常不适合进行货币计算.</strong> 它们可能会有额外的溢出, 带来一些不可预计的问题.</p><blockquote><p>The <code>float</code> and <code>double</code> types are particularly ill-suited fro monetary calculations.</p></blockquote><p><strong>应该用 <code>BigDecimal</code>, <code>int</code> 或者 <code>long</code> 来进行货币计算.</strong></p><blockquote><p>Use <code>BigDecimal</code>, <code>int</code>, or <code>long</code> for monetary calculations.</p></blockquote><h3 id="item-61-使用原始类型而不是装箱类型" tabindex="-1"><a class="header-anchor" href="#item-61-使用原始类型而不是装箱类型" aria-hidden="true">#</a> Item 61: 使用原始类型而不是装箱类型</h3><blockquote><p>Prefer primitive types to boxed primitives.</p></blockquote><p>我们在 <a href="#item-6-%E9%81%BF%E5%85%8D%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%AE%9E%E4%BE%8B">Item 6</a> 中说过, 使用装箱类型会创建很多不必要的实例, 也会带来很多的拆箱和装箱的消耗.</p><p>同时, 装箱类型的比较是对象实例的比较, 不是值的比较. 考虑如下代码:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> naturalOrder <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> i <span class="token operator">&lt;</span> j <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

naturalOrder<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果是 <code>false</code>! 因为 <code>==</code> 会比较两个 <code>Integer</code> 对象的内存地址是否相同.</p><p><strong>当原始类型和装箱类型混合使用时, 装箱类型会被自动拆箱.</strong></p><blockquote><p>When you mix primitives and boxed primitives in an operation, the boxed primitives is auto-unboxed.</p></blockquote><h3 id="item-62-避免在其他类型更合适时使用-string" tabindex="-1"><a class="header-anchor" href="#item-62-避免在其他类型更合适时使用-string" aria-hidden="true">#</a> Item 62: 避免在其他类型更合适时使用 String</h3><blockquote><p>Avoid strings where other types are more appropriate.</p></blockquote><p>记住 <code>String</code> 只是用来存储字符串(文本)的, 不要给它附加太多的功能.</p><p><strong><code>String</code> 是其他值类型的糟糕替代.</strong> 我们从控制台获取的各种输入都是 <code>String</code> 类型的, 但是不意味着我们就要在后续使用 <code>String</code> 类型, 而是需要将他们转化为 <code>int</code>, <code>boolean</code> 等其他值类型.</p><blockquote><p>Strings are poor substitutes for other value types.</p></blockquote><p><strong><code>String</code> 是枚举类型的糟糕替代.</strong> 这在 <a href="#item-34-%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E8%80%8C%E4%B8%8D%E6%98%AF-int-%E5%B8%B8%E9%87%8F">Item 34</a> 中我们就已经谈过了.</p><blockquote><p>Strings are poor substitutes for enum types.</p></blockquote><p><strong><code>String</code> 是聚合结构的糟糕替代.</strong> 对于很多拥有多个组件的聚合结构来说, <code>String</code> 很难表意.</p><blockquote><p>Strings are poor substitutes for aggregate types.</p></blockquote><p><strong><code>String</code> 不适合作为键.</strong> <code>String</code> 类型在 JVM 中共享命名空间, 因此在一些情况下不适合作为键使用.</p><blockquote><p>Strings are poor substitutes for capabilities.</p></blockquote><p>如:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocal</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果使用 <code>String</code> 作为键, 那么可能出现其他的线程使用同样的值对当前线程的本地缓存进行更改, 导致并发问题. 因此, <strong>在很多对独立性和安全性要求高的地方, 需要使用具有独立命名空间的类型作为键.</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocal</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Key</span> <span class="token punctuation">{</span>
        <span class="token class-name">Key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Key</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">Key</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Key</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每个线程本地变量的 <em>key</em> 都有自己独立的命名空间, 使得其对应的值不会被其他线程污染.</p><p>这样 <code>ThreadLocal</code> 的键就对外隐藏了, 因此可以对外简化 API:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="item-63-注意-string-拼接的性能消耗" tabindex="-1"><a class="header-anchor" href="#item-63-注意-string-拼接的性能消耗" aria-hidden="true">#</a> Item 63: 注意 String 拼接的性能消耗</h3><blockquote><p>Beware the performance of string concatenation.</p></blockquote><p><strong>重复使用 <code>+</code> 拼接 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个字符串需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 的时间.</strong> 因为 <code>String</code> 中的值是不可变的, 所以拼接两个字符串会将它们都复制一遍.</p><blockquote><p>Use the string concatenation operator(<code>+</code>) repeatedly to concatenate <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> strings requires time quadratic in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>.</p></blockquote><p><strong>使用 <code>StringBuilder</code> 来进行字符串的拼接.</strong></p><blockquote><p>To achieve acceptable performance, use a <code>StringBuilder</code> in place of a <code>String</code>.</p></blockquote><p>在需要保证线程安全的环境中, 可以使用 <code>StringBuffer</code>.</p><p>总的来说, 当需要拼接好几个字符串的时候, 就不要使用 <code>+</code> 直接拼接了, 而是用 <code>StringBuilder</code> 代替.</p><h3 id="item-64-通过接口引用对象" tabindex="-1"><a class="header-anchor" href="#item-64-通过接口引用对象" aria-hidden="true">#</a> Item 64: 通过接口引用对象</h3><blockquote><p>Refer to objects by their interfaces.</p></blockquote><p><strong>只要有合适的接口类型, 就使用接口类型声明参数, 返回值, 变量和字段.</strong></p><blockquote><p>If appropriate interface types exist, then parameters, return values, variables, and fields should all be declared using interface types.</p></blockquote><p><strong>使用接口引用对象使得程序更加灵活可扩展.</strong></p><blockquote><p>If you get into the habit of using interfaces as types, your program will be much more flexible.</p></blockquote><p>当然, 如果没有适合的接口类型, 还是需要用对象本身的类型去引用. 我们是尽量去使用更抽象的类型去引用他们的子类型实例.</p><blockquote><p>If there is no appropriate interface, just use the least specific class int the class hierarchy that provides the required functionality.</p></blockquote><h3 id="item-65-使用接口代替反射" tabindex="-1"><a class="header-anchor" href="#item-65-使用接口代替反射" aria-hidden="true">#</a> Item 65: 使用接口代替反射</h3><blockquote><p>Prefer interfaces to reflection.</p></blockquote><p>Java 的反射带给程序员可以访问任何类的功能. 只要有一个类的实例, 我们就可以获取到它的从构造器, 方法到字段的任何属性.</p><p>基于反射的功能, 我们可以执行从反射中获取到的构造器/方法, 如: <code>Method#invoke()</code>.</p><p>但是反射也会带来一些问题:</p><ol><li><strong>无法从编译器的类型检查中获益.</strong> 直接通过 <code>Method#invoke()</code> 调用无法进行参数类型检查.</li><li><strong>使用反射是一个很笨拙和麻烦的过程.</strong> 代码编写很死板, 并且可读性很差.</li><li><strong>反射的性能不好.</strong> 相较于普通的方法调用, 基于反射的调用性能很低, 可能会有高达 10 倍左右的性能差距.</li></ol><p>但是一些框架还是需要使用反射, 比如 <em>Spring Framework</em> 通过反射实现 IOC.</p><p>对反射进行合理且有限的使用可以在付出较少性能代价的情况下, 获得很多益处.</p><blockquote><p>You can obtain many of the benefits of reflection while incurring few of its costs by using it only in a very limited form.</p></blockquote><p><strong>对于一般的基于反射的方法调用, 我们可以通过反射创建实例, 然后通过他们的接口或者父类进行方法调用.</strong></p><blockquote><p>You can create instances reflectively and access them normally via their interface or superclass.</p></blockquote><p>这种思想其实就是简化的 <em>Service Provider Framework</em>, 或者说 <em>Service Provider Interface(SPI)</em>.</p><h3 id="item-66-谨慎使用-native-方法" tabindex="-1"><a class="header-anchor" href="#item-66-谨慎使用-native-方法" aria-hidden="true">#</a> Item 66: 谨慎使用 native 方法</h3><blockquote><p>Use native methods judiciously.</p></blockquote><p><em>Java Native Interface(JNI)</em> 允许 Java 开发者调用基于本地编程语言(<em>native programming language</em>)如 C, C++ 编写的 <em>native</em> 方法.</p><p>Java 的 <em>native</em> 方法主要有三个用途:</p><ol><li><strong>提供对特定平台的设施的访问</strong>, 如: 寄存器.</li><li><strong>提供对已有 <em>native</em> 代码库的访问</strong>.</li><li><strong>用于编写程序中对性能要求很高的部分.</strong></li></ol><p>但是, 对于普通开发者, 我们不推荐借助 <em>native</em> 方法来提升性能. 很多 Java 的官方库会在底层使用 JNI, 不需要我们主动去使用. 并且, <em>native</em> 方法是不安全的, 很容易出现内存冲突之类的问题, 也不便于 debug.</p><blockquote><p>It is rarely advisable to use native methods for improved performance.</p></blockquote><p>总之, 在使用 JNI 之前, 请三思.</p><h3 id="item-67-谨慎地进行优化" tabindex="-1"><a class="header-anchor" href="#item-67-谨慎地进行优化" aria-hidden="true">#</a> Item 67: 谨慎地进行优化</h3><blockquote><p>Optimize judiciously.</p></blockquote><p>始终记住, 优化是一件很难的事情, 不是想做就能做到的. 很多时候所谓的优化只会带来更多的麻烦, 尤其是在开发阶段过早地进行优化, 最后你得到了一坨人不人鬼不鬼的东西, 然后巨难受.</p><p><strong>能不动就先别动, 除非你确定有一个完美的能够优化的方案, 并且你能够实现.</strong></p><p>可以看一段有意思的话:</p><blockquote><p>We follow two rules in the matter of optimization:</p><ol><li>Don&#39;t do it.</li><li>(For experts only). Don;t do it yet--that is, not until you have a perfectly clear and unoptimized solution.</li></ol><p>-- M. A. Jackson</p></blockquote><p>其实在写代码时, 我们不应该总是关注优化之类的问题.</p><p><strong>相比于写出快的代码, 不如努力写出好的代码.</strong></p><blockquote><p>Strive to write good programs rather than fast ones.</p></blockquote><p>好的代码是高效率代码的基础, 好代码的好结构使得它能够更轻易地进行优化.</p><p>再之后就是, 什么是快的代码? 不就是不慢的嘛~</p><p><strong>尽量避免限制性能的代码设计.</strong></p><blockquote><p>Strive to avoid design decisions that limit performance.</p></blockquote><p><strong>考虑 API 设计对性能的影响.</strong> 比如让一个公共类型可变需要很多不必要的防御性复制动作.</p><blockquote><p>Consider the performance consequences of your API design decisions.</p></blockquote><p><strong>为获得良好的性能而更改 API 是很糟糕的决定.</strong> 导致更改 API 的性能缺陷可能在之后的版本中由于平台或者其他底层软件的更改而消失, 但是更改后的 API 需要很烦人的兼容性支持.</p><blockquote><p>It&#39;s a very bad idea to warp an API to achieve good performance.</p></blockquote><p><strong>在每次尝试优化前后评估程序性能.</strong> 可能大多数时候优化并没有带来很大的性能提升, 甚至性能更差了, 因为我们很难猜测程序到底在什么地方消耗了大量时间. 不过我们可以通过一些分析工具来辅助判断.</p><blockquote><p>Measure performance before and after each attempted optimization.</p></blockquote><p>总之, 不要在性能优化上过于执着.</p><h3 id="item-68-遵守普遍接受的命名约定" tabindex="-1"><a class="header-anchor" href="#item-68-遵守普遍接受的命名约定" aria-hidden="true">#</a> Item 68: 遵守普遍接受的命名约定</h3><blockquote><p>Adhere to generally accepted naming conventions.</p></blockquote><p>Java 有一套完善的命名标准, 主要在 <em>The Java Language Specification</em> 中定义.</p><p>Java 中主要的命名问题还是<strong>拼写</strong>和<strong>语法</strong>错误.</p><p>下面给出一些具体的命名建议:</p><ol><li>对于包的命名: <ol><li>不要和官方包重名.</li><li>尽量简短, 不超过 8 个字符.</li><li>如果名称过长, 将其划分为多个层次的包.</li></ol></li><li>类和接口的命名: <ol><li>每个单词首字母都要大写.</li><li>尽量只大写每个单词的首字母, 对比: <code>HttpUrl</code> 和 <code>HTTPURL</code>(不如不写)</li><li>包含一个以上的单词.</li><li>尽量不要使用缩写, 除非缩写非常常见, 如: <em>max</em>, <em>min</em> 等.</li></ol></li><li>方法和字段的命名: <ol><li>除了名称首字母小写外, 和类与接口的相同.</li><li>常量字段所有字母大写, 字母之间用下划线(<code>_</code>)隔开.(只有常量名称中推荐包含下划线).</li><li>局部变量类似, 不过允许和鼓励合理的缩写, 如: <code>cnt</code>, <code>num</code> 等.</li></ol></li><li>类型参数主要使用以下几个<strong>单个的大写字母</strong>: <ol><li><code>T</code>: 一个特定类型.</li><li><code>E</code>: 集合中的元素类型.</li><li><code>K</code>, <code>V</code>: <em>map</em> 中的键/值的类型.</li><li><code>X</code>: 异常类型.</li><li><code>R</code>: 返回类型.</li><li><code>T</code>, <code>U</code>, <code>V</code> or <code>T1</code>, <code>T2</code>, <code>T3</code>: 连续的特定类型.</li></ol></li></ol><p>更多的内容详见 <em>The Java Language Specification</em>.</p><h2 id="异常" tabindex="-1"><a class="header-anchor" href="#异常" aria-hidden="true">#</a> 异常</h2><blockquote><p>Exceptions</p></blockquote><h3 id="item-69-只在异常情况下使用异常" tabindex="-1"><a class="header-anchor" href="#item-69-只在异常情况下使用异常" aria-hidden="true">#</a> Item 69: 只在异常情况下使用异常</h3><blockquote><p>Use exceptions only for exceptional conditions.</p></blockquote><p>假设你很不幸, 遇到了这样一段代码:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        range<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">climb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">ArrayIndexOutOfBoundsException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不知道读者们如何看到这样一段代码, 它通过抛出并捕获异常的方式结束 <code>while</code> 循环, 显得很&quot;超然世外&quot;. 正常来说, 我们的代码应该是这样的:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Mountain</span> m <span class="token operator">:</span> range<span class="token punctuation">)</span> m<span class="token punctuation">.</span><span class="token function">climb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>通过异常来结束循环会比正常使用 <code>for</code> 循环慢很多, 并且我们无法保证它能够正常的工作, 因为可能在执行过程中出现其他的异常.</p><p><strong>异常只应该被应用于异常情况发生时, 而不应该被用在一般性的控制流中.</strong></p><blockquote><p>Exceptions are, as their name implies, to be used only for exceptional conditions; they should never be used for ordinary control flow.</p></blockquote><p><strong>一个设计良好的 API 也不应该强迫使用者将异常用于一般性控制流中.</strong></p><blockquote><p>A well-designed API must not force its clients to use exceptions for ordinary control flow.</p></blockquote><h3 id="item-70-可恢复环境使用受检异常-程序错误使用运行时异常" tabindex="-1"><a class="header-anchor" href="#item-70-可恢复环境使用受检异常-程序错误使用运行时异常" aria-hidden="true">#</a> Item 70: 可恢复环境使用受检异常, 程序错误使用运行时异常</h3><blockquote><p>Use checked exceptions for recoverable conditions and runtime exceptions for programming errors.</p></blockquote><p>Java 提供了三种类型的异常: 受检异常(<em>checked exception</em>), 运行时异常(<em>runtime exception</em>), 错误(<em>error</em>).</p><p>初学者往往分不清楚在什么情况下使用它们, 下面给出一些 tips:</p><p><strong>对于调用者可以合理预期恢复的情况, 使用受检异常.</strong> 我们可以通过抛出受检异常的方式强制调用者捕获或者继续抛出对应的异常, 这样能够使调用者清晰地知道调用该方法可能出现的问题, 并做出相应的处理/恢复措施.</p><blockquote><p>Use checked exceptions for conditions from which the caller can reasonable be expected to recover.</p></blockquote><p>运行时异常和错误, 都是不受检异常. 它们都是不必要, 而且大部分时候不应该被捕获的. 如果一个程序抛出了运行时异常或者错误, 那大概表明在这种情况下是很难进行恢复或者继续执行的.</p><p><strong>使用运行时异常来表明程序错误.</strong> 大部分运行时异常都是在表示前提条件违规(<em>precondition violation</em>), 即 API 的使用不符合它要求的规则. 如: <code>ArrayIndexOutOfBoundsException</code> 表示数组的索引违反了其规定.</p><blockquote><p>Use runtime exceptions to indicate programming errors.</p></blockquote><p>但是我们有时候并不能确定运行时异常发生的情况能够被恢复. 比如说, 我们在申请一块较大内存的时候, 由于空间不足, 抛出了运行时异常; 但是我们并不能知道内存不足是由于暂时的高内存占用还是长时间的占用, 因此不便于判断能够恢复并继续申请内存.</p><p><em>如果我们能够确定异常抛出后是能够恢复的, 那么抛出受检异常. 如果不行, 或者不确定能恢复, 那么就抛出运行时异常.</em></p><p>虽然 Java 语言规范(<em>Java Language Specification</em>)中没有明确说明, 但是<strong>错误(<em>error</em>)是专门为 JVM 保留的, 使用者不应该在程序中主动抛出任何异常.</strong></p><p><strong>所有的运行时异常都应该直接或者间接地将 <code>RuntimeException</code> 作为父类.</strong></p><blockquote><p>All of the unchecked throwables you implement should subclass <code>RuntimeException</code>.</p></blockquote><p>我们自己设计的异常要么是 <code>Exception</code> 的子类, 要么是 <code>RuntimeException</code> 的子类, 如果是错误的话就是 <code>Error</code> 的子类. 但是还可以通过实现 <code>Throwable</code> 的方式定义异常, 但是非常不推荐这样使用, 因为 JLS 不能对它很好地进行处理.</p><p>很多开发者会忽略一个点: 异常类也是一个功能完备的类, 能够在其中定义方法. 尤其是可以被恢复的受检异常, 我们可以在异常中定义用于进行恢复或者获取更多信息的方法. 具体会在 <a href="#item-75-%E5%9C%A8%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF%E4%B8%AD%E5%8C%85%E5%90%AB%E6%95%85%E9%9A%9C%E6%8D%95%E8%8E%B7%E4%BF%A1%E6%81%AF">Item 75</a> 中介绍.</p><h3 id="item-71-避免不必要地使用受检异常" tabindex="-1"><a class="header-anchor" href="#item-71-避免不必要地使用受检异常" aria-hidden="true">#</a> Item 71: 避免不必要地使用受检异常</h3><blockquote><p>Avoid unnecessary use of checked exceptions.</p></blockquote><p>受检异常强制 API 调用者捕获可能出现的所有受检异常, 过多地抛出受检异常会使得调用者非常烦躁. 并且, 会抛出受检异常地方法不能被直接用于 Stream API 中.</p><p><strong>只有当调用者不能通过合理使用 API 并且可以从 API 抛出的异常中采取一些措施时, 受检异常才应该被使用.</strong> 我们在抛出受检异常时, 可以先设想一下调用者如何处理捕获到的异常? 如果没有很合适的处理方式, 那么就不要将其作为受检异常抛出.</p><blockquote><p>This burden may be justified if the exceptional condition cannot be prevented by proper use of the API <em>and</em> the programmer using the API can take some useful action once confronted with the exception.</p></blockquote><p><strong>很多时候, 一个会抛出受检异常的方法可以被分为两个方法: 一个是返回值为 <code>boolean</code> 的方法, 它会在会抛出异常的情况下返回 <code>false</code>; 另一个是按照正常逻辑执行的方法.</strong></p><p>我们可以通过这种方式进行优化:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
    obj<span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">TheCheckedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// handle the checked exception</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>划分方法:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">actionPermitted</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span> obj<span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">else</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// handle the exceptional condition.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="item-72-尽量使用标准异常" tabindex="-1"><a class="header-anchor" href="#item-72-尽量使用标准异常" aria-hidden="true">#</a> Item 72: 尽量使用标准异常</h3><blockquote><p>Favor the use of standard exceptions.</p></blockquote><p>相较于初级开发者, 资深的开发者总是能够很好地进行代码复用. JDK 中提供了能够满足大多数 API 需求的异常, 我们推荐尽量使用标准异常.</p><p>使用标准异常使得 API 更易于被学习和使用, 因为使用者会更加熟悉标准异常. 这也使得 API 可读性更好. 并且, 我们可以定义和使用更少的异常类, 减少了一定的内存使用和类加载的时间.</p><p>最常被复用的异常是 <code>IllegalArgumentException</code> 和 <code>IllegalStateException</code>, 以及 <code>NullPointerException</code> 和 <code>ArrayIndexOutOfBoundsException</code>. 在并发上, 我们还会使用到 <code>ConcurrentModificationException</code>. 在使用一些带有可选选项的方法时, 还可以抛出 <code>UnsupportedOperationException</code>.</p><p>还有一个很重要的要求: <strong>不要直接使用 <code>Exception</code>, <code>RuntimeException</code>, <code>Throwable</code> 或者 <code>Error</code></strong>.</p><blockquote><p>Do not use <code>Exception</code>, <code>RuntimeException</code>, <code>Throwable</code>, or <code>Error</code> directly.</p></blockquote><h3 id="item-73-抛出符合抽象层级的异常" tabindex="-1"><a class="header-anchor" href="#item-73-抛出符合抽象层级的异常" aria-hidden="true">#</a> Item 73: 抛出符合抽象层级的异常</h3><blockquote><p>Throw exceptions appropriate to the abstraction.</p></blockquote><p>一个方法应该抛出和他所执行的任务有关的方法, 否则抛出的异常没有意义. 因为一些继承/实现/调用上的原因, 抽象层级高的方法可能会捕获层级更低的方法抛出的异常, 但是这些异常和对应的层级没有很好的关联.</p><p><strong>抽象层级高的方法应该捕获层级更低方法抛出的异常, 并且抛出与他们抽象层级对应的异常.</strong></p><blockquote><p>Higher layers should catch lower-level exceptions and, in their place, throw exceptions that can be explained in terms of the higher-level abstraction.</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// Use lower-level abstraction to do our bidding</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">LowerLevelException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">HigherLevelException</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们在抛出符合抽象层级的异常的同时, 还想保留低级的异常, 可以将其作为参数传入构造器中. 我们将这种方法称为<strong>异常链(<em>exception chaining</em>)</strong>.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// Use lower-level abstraction to do our bidding</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">LowerLevelException</span> cause<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">HigherLevelException</span><span class="token punctuation">(</span>cause<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里给出一个 JDK 中的经典例子--<code>AbstractSequentialList#get(int)</code>:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">ListIterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> i <span class="token operator">=</span> <span class="token function">listIterator</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> i<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchElementException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token string">&quot;index: &quot;</span> <span class="token operator">+</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>虽然异常转换优于无脑传播低层级异常, 但是也不应该过度使用.</strong> 很多时候可以解决这些低层级的异常, 而不是继续抛出.</p><blockquote><p>While exception translation is superior to mindless propagation of exceptions from lower layers, it should not be overused.</p></blockquote><h3 id="item-74-文档化每个方法抛出的所有异常" tabindex="-1"><a class="header-anchor" href="#item-74-文档化每个方法抛出的所有异常" aria-hidden="true">#</a> Item 74: 文档化每个方法抛出的所有异常</h3><blockquote><p>Document all exception thrown by each method.</p></blockquote><p>在文档中注释每个可能抛出的异常是非常重要的, 这有助于使用中了解抛出异常的原因和可能的解决方法.</p><p><strong>总是独立地声明受检异常, 并且在文档中使用 <code>@throw</code> 明确说明抛出异常的原因.</strong> 我们希望方法抛出的异常是精确的, 而不是很模糊的概括. 开发者更希望看到抛出的异常是 <code>NoSuchElementException</code>, <code>IllegalArgumentException</code>, 而不是 <code>Exception</code>, <code>RuntimeException</code>, 更不是 <code>Throwable</code>. 当然, 对于只会被 VM 执行的 <code>main()</code> 方法, 可以直接抛出 <code>Exception</code>.</p><blockquote><p>Always declare checked exceptions individually, and document precisely the conditions under which each one is thrown using <code>@throws</code> tag.</p></blockquote><p>虽然 Java 不强制要求开发者声明不受检异常, 不过我们还是推荐对这些异常进行详细的注释, 因为为受检异常更多代表系统的错误, 不易被恢复.</p><p><strong>在文档中使用 <code>@throws</code> 为每个异常进行标注, 但是不要在方法上使用 <code>throws</code> 声明不受检异常.</strong></p><blockquote><p>Use the Javadoc <code>@throws</code> tag to document each exception that a method can throw, but do <em>not</em> use the <code>throws</code> keyword on unchecked exceptions.</p></blockquote><p><strong>如果一个异常会在类中的很多方法中都因为相同的原因抛出,那么可以在类的文档中对其进行注释.</strong></p><blockquote><p>If an exception is thrown by many methods in a class for the same reason, you can document the exception in the class&#39;s documentation comment rather than documenting it individually for each method.</p></blockquote><h3 id="item-75-在详细信息中包含故障捕获信息" tabindex="-1"><a class="header-anchor" href="#item-75-在详细信息中包含故障捕获信息" aria-hidden="true">#</a> Item 75: 在详细信息中包含故障捕获信息</h3><blockquote><p>Include failure-capture information in detail messages.</p></blockquote><p>开发者在遇到故障时, 不止想要知道发生的是什么故障, 还想要知道是什么导致了故障, 或者说发生故障的上下文信息. 因此, 我们在打印故障信息时, 需要将相关的上下文信息包含进去.</p><p><strong>捕获故障时, 详细信息中应该包含导致故障发生的所有参数和字段信息.</strong> 比如, 当发生 <code>ArrayIndexOutOfBoundsException</code> 时, 我们希望看到导致故障的 <code>index</code> 的值是多少, <code>lowerBound</code> 和 <code>upperBound</code> 分别是多少.</p><blockquote><p>To capture a failure, the detail message of an exception should contain the values of all parameters and fields that contributed to the exception.</p></blockquote><p><strong>但是, 不要在故障捕获信息中包含密码, 盐等敏感信息.</strong></p><blockquote><p>Do not include passwords, encryption keys, and the like in detail messages.</p></blockquote><h3 id="item-76-尽力保证故障原子性" tabindex="-1"><a class="header-anchor" href="#item-76-尽力保证故障原子性" aria-hidden="true">#</a> Item 76: 尽力保证故障原子性</h3><blockquote><p>Strive for failure atomicity.</p></blockquote><p><strong>总的来说, 一个执行错误的方法应该保证其上下文中的对象状态保持在发生错误前.</strong> 这样有利于对故障进行恢复, 防止发生更多的异常. 这种操作称为<strong>故障原子性(<em>failure atomicity</em>)</strong>.</p><blockquote><p>Generally speaking, a failed methods invocation should leave the object in the state that it was in prior to the invocation.</p></blockquote><p>一般来说, 有如下几种实现故障原子性的方式:</p><ol><li>使用不可变对象.</li><li>如果是可变对象, 在方法正式执行前完成所有参数检查.</li><li>合理划分方法执行的阶段, 保证每个阶段都是故障原子性的.</li><li>在备份中进行操作.</li><li>发生异常后主动进行故障恢复.</li></ol><h3 id="item-77-不要忽略异常" tabindex="-1"><a class="header-anchor" href="#item-77-不要忽略异常" aria-hidden="true">#</a> Item 77: 不要忽略异常</h3><blockquote><p>Don&#39;t ignore exceptions.</p></blockquote><p>异常就是用来传递程序运行过程中的错误信息的, 如果我们忽略异常信息, 那么和没有异常没有任何区别.</p><p><strong>一个空的 <code>catch</code> 块违背了使用异常的初衷.</strong></p><blockquote><p>An empty <code>catch</code> exception defeats the purpose of exceptions.</p></blockquote><p><strong>如果一些异常确实可以被忽略, 那么 <code>catch</code> 块中必须包括一个解释为什么可以忽略的注释, 并且异常变量应该被命名为 <code>ignored</code>.</strong></p><blockquote><p>If you choose to ignore an exception, the <code>catch</code> block should contain a comment explaining why it is appropriate to do so, and the variable should be named <code>ignored</code>.</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// Do some additional operation.</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">TimeOutException</span> ignored<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Use default: this operation is not must required.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="并发" tabindex="-1"><a class="header-anchor" href="#并发" aria-hidden="true">#</a> 并发</h2><blockquote><p>Concurrency.</p></blockquote><h3 id="item-78-并行化对共享可变对象的访问操作" tabindex="-1"><a class="header-anchor" href="#item-78-并行化对共享可变对象的访问操作" aria-hidden="true">#</a> Item 78: 并行化对共享可变对象的访问操作</h3><blockquote><p>Synchronize access to shared mutable data.</p></blockquote><p><strong>对于需要互斥访问或者线程间交流的情况, 需要并行化操作.</strong></p><blockquote><p>Synchronization is required for reliable communication between threads as well as for mutable exclusion.</p></blockquote><p><strong>在线程控制上, 不要使用 <code>Thread#stop()</code> 方法.</strong> 因为这个方法是不安全的, 可能会导致数据冲突. 我们推荐使用更优雅的停止线程的方式:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StopThread</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> stopRequested<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span> backgroundThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stopRequested<span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        backgroundThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">requestStop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">requestStop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        stopRequested <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>并发访问任何的共享可变数据时, 需要对所有的读写操作都进行并行化处理.</strong></p><blockquote><p>When multiple threads share mutable data, each thread that reads or writes the data must perform synchronization.</p></blockquote><h3 id="item-79-避免过度同步" tabindex="-1"><a class="header-anchor" href="#item-79-避免过度同步" aria-hidden="true">#</a> Item 79: 避免过度同步</h3><blockquote><p>Avoid excessive synchronization.</p></blockquote><p>过度的同步可能导致性能降低, 死锁, 甚至不可预期的行为.</p><p><strong>为了避免性能或安全故障，不要将同步方法或块内的控制权交给调用者.</strong> 也就是说, 不要在同步块中执行会被重写的方法, 或者外部传入的函数式对象.</p><blockquote><p>To avoid liveness and safety failures, never cede control to the client within a synchronized method or block.</p></blockquote><p><strong>在同步块中做的事情越少越好.</strong></p><blockquote><p>As a rule, you should do as little work as possible inside synchronized regions.</p></blockquote><h3 id="item-80-使用线程池-任务池和流替代线程" tabindex="-1"><a class="header-anchor" href="#item-80-使用线程池-任务池和流替代线程" aria-hidden="true">#</a> Item 80: 使用线程池, 任务池和流替代线程</h3><blockquote><p>Prefer executors, tasks, and streams to threads.</p></blockquote><p>用户自己使用 <code>Thread</code> 进行并发操作并不能很好的控制线程的数量和声明周期, 导致一些性能问题.</p><p>在 <code>java.util.concurrent</code> 包中提供了很多用于实现并发的方法, 都比单独使用 <code>Thread</code> 好. 如: <code>ExecutorService</code>, 或者直接使用 <code>ThreadPoolExecutor</code> 来获得对线程池的最大控制权.</p><p>对于一些特殊的任务, 我们还可以使用 <code>ForkJoinPool</code> 来完成.</p><p>流处理中使用并行操作在之前就已经讲解过了, 这里不再赘述.</p><h3 id="item-81-使用并发工具代替-wait-和-notify" tabindex="-1"><a class="header-anchor" href="#item-81-使用并发工具代替-wait-和-notify" aria-hidden="true">#</a> Item 81: 使用并发工具代替 wait 和 notify</h3><blockquote><p>Prefer concurrent utilities to <code>wait</code> and <code>notify</code>.</p></blockquote><p>在 Java 中, <code>wait()</code> 和 <code>notify()</code> 是最基础的进行并发控制的方法. 它们使用起来并不方便, 我们推荐使用更高层次的封装--<code>java.util.concurrent</code> 提供的并发工具.</p><blockquote><p>Given the difficulty of using <code>wait</code> and <code>notify</code> correctly, you should use the higher-level concurrent utilities instead.</p></blockquote><p><strong>并发集合中的并发操作是不能被制止的, 如果为其加锁只会降低程序性能.</strong> 并且, 并发集合中的并发操作一定是线程安全的, 我们没必要对其进行任何的限制.</p><blockquote><p>It is impossible to exclude concurrent activity from a concurrent collection; locking it will only slow the program.</p></blockquote><p>JUC(<code>java.util.concurrent</code>)中为很多集合提供了它们对应的进行了并发优化的集合类, 如: <code>ConcurrentHashMap</code>, <code>CopyOnWriteArrayList</code>, <code>ConcurrentSkipListMap</code>, <code>ConcurrentSkipListSet</code> 等.</p><p>在一些 API 的使用上, 也推荐使用线程安全的, 如: 使用 <code>System.nanoTime()</code> 替代 <code>System.currentTimeMillis()</code> 等.</p><h3 id="item-82-文档化线程安全情况" tabindex="-1"><a class="header-anchor" href="#item-82-文档化线程安全情况" aria-hidden="true">#</a> Item 82: 文档化线程安全情况</h3><blockquote><p>Document thread safety.</p></blockquote><p>在进行并发编程时, API 的调用者需要明确知道一个方法是否是线程安全的, 或者说在什么情况下是线程安全的. 因此, 在文档中加入线程安全相关的信息非常重要.</p><blockquote><p>To enable safe concurrent use, a class must clearly document what level of thread safety it supports.</p></blockquote><p>不要以为在代码中使用了 <code>synchronized</code> 就能在文档中表明方法是线程安全的. Javadoc 不会对使用了 <code>synchronized</code> 关键字的代码在文档上进行任何特殊的处理.</p><blockquote><p>The presence of the <code>synchronized</code> modifier in a method declaration is an implementation detail, not a part of its API.</p></blockquote><p>线程不是要么安全, 要么不安全的, 而是具有一些不同的分级. 下面给出一些用于标注线程安全的 tag:</p><ol><li><strong>不可变(<em>Immutable</em>)</strong>: 类的实例是不可变的, 如: <code>String</code>, <code>Long</code> 或者 <code>AtomicInteger</code>.</li><li><strong>无条件线程安全(<em>Unconditionally thread-safe</em>)</strong>: 在任何情况下都是线程安全的.</li><li><strong>条件性线程安全(<em>Conditionally thread-safe</em>)</strong>: 在一定条件下是线程安全的.</li><li><strong>线程不安全(<em>Not thread-safe</em>)</strong>: 本身是线程不安全的, 使用者需要增加额外的线程安全手段来保证线程安全.</li><li><strong>线程对立(<em>Thread-hostile</em>)</strong>: 不适合用于并发中.</li></ol><h3 id="item-83-谨慎使用懒加载" tabindex="-1"><a class="header-anchor" href="#item-83-谨慎使用懒加载" aria-hidden="true">#</a> Item 83: 谨慎使用懒加载</h3><blockquote><p>Use lazy initialization judiciously.</p></blockquote><p>懒加载确实能一定程度上提高程序的性能, 不过也可能带来线程安全问题.</p><p>这里用一种常见的懒加载举例--懒汉式单例.</p><p>一些初级开发者可能会写出如下的代码:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看起来好像没有任何问题, 但是在并发条件下, 这个代码不能保证一定是单例的, 这是由 Java 的执行特性导致的, 具体可以见 <em>Java 并发编程的艺术</em>.</p><p>在编写懒汉式单例的时候, 我们通常会说需要<strong>双重检查锁定(<em>double-check</em>)</strong>.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>在使用懒加载时, 一定要考虑是否需要保证线程安全.</strong></p><h3 id="item-84-不要依靠线程调度器" tabindex="-1"><a class="header-anchor" href="#item-84-不要依靠线程调度器" aria-hidden="true">#</a> Item 84: 不要依靠线程调度器</h3><blockquote><p>Don&#39;t depend on the thread scheduler.</p></blockquote><p>如果当前有很多线程都处于就绪状态, 那么会由线程调度器决定哪些线程能被执行, 执行多长时间. 但是不同调度器的决策是不同的, 因此我们不能依靠调度器对线程进行控制.</p><blockquote><p>Any program that relies on the thread scheduler for correctness or performance is likely to be nonportable.</p></blockquote><p>实现健壮, 可用和便捷的程序的最佳方式就是让平均可运行线程数量稳定在处理器数量的一半左右. 这可以很大程度上掩盖调度器的决策方式, 让调度器可以使可运行线程运行到它们停止为止.</p><p><strong>为了节省处理器资源, 没有进行有效工作的线程不应该继续执行.</strong></p><blockquote><p>Thread should not run if they aren&#39;t doing useful work.</p></blockquote><p><strong><code>Thread#yield()</code> 的执行结果也是不可控的, 取决于 JVM 如何实现.</strong></p><blockquote><p><code>Thread#yield()</code> has no testable semantics.</p></blockquote><p>另外就是线程优先级的问题了. <strong>Java 的线程优先级不一定会生效</strong>, 因为它只是对操作系统在调度时起到一个&quot;建议&quot;的作用.</p><blockquote><p>Thread priority are among the least portable features of Java.a</p></blockquote><h2 id="序列化" tabindex="-1"><a class="header-anchor" href="#序列化" aria-hidden="true">#</a> 序列化</h2><blockquote><p>Serialization.</p></blockquote><h3 id="item-85-优先使用-java-序列化的替代方案" tabindex="-1"><a class="header-anchor" href="#item-85-优先使用-java-序列化的替代方案" aria-hidden="true">#</a> Item 85: 优先使用 Java 序列化的替代方案</h3><blockquote><p>Prefer alternatives to Java serialization.</p></blockquote><p>Java 的序列化功能在它被提供的时候就是有风险的. Java 能从 <code>ObjectInputStream#readObject()</code> 方法中反序列化几乎所有的类实例, 这使得序列化很难做到完全的安全. 同时, 还需要考虑第三方包的问题.</p><p>最好的解决办法就是不进行任何的反序列化操作. 并且, 也不要在任何(新的)程序中使用 Java 的序列化功能.</p><blockquote><p>The best way to avoid serialization exploits is never to deserialize anything.</p><p>There is no reason to use Java serialization in any new system you write.</p></blockquote><p>在开发中, 常见的跨平台序列化方式主要有两种--<em>JSON</em> 和 <em>Protocol Buffers(protobuf)</em>. 这两者的最大区别就是 <em>JSON</em> 是可读的文本形式的, 而 <em>protobuf</em> 是更高效率的二进制数据.</p><p>如果我们没有办法避免反序列化, 那么建议使用以上两种之一. 并且, <strong>永远不要反序列化不可信数据.</strong></p><blockquote><p>Never deserialize untrusted data.</p></blockquote><p><strong>我们可以对需要反序列化的数据进行限制, 这种限制最好使用白名单, 而不是黑名单.</strong></p><blockquote><p>Prefer whitelisting to blacklisting.</p></blockquote><h3 id="item-86-谨慎实现-serializable-接口" tabindex="-1"><a class="header-anchor" href="#item-86-谨慎实现-serializable-接口" aria-hidden="true">#</a> Item 86: 谨慎实现 Serializable 接口</h3><blockquote><p>Implement <code>Serializable</code> with great caution.</p></blockquote><p><strong>实现 <code>Serializable</code> 接口的最大问题就是它降低了类实现的灵活性.</strong> 当一个类实现了 <code>Serializable</code> 接口, 它的序列化格式就会作为一个 API 对外暴露. 当这个类的 API 被广泛使用后, 就需要在后续的版本中都去长期维护它的序列化功能.</p><blockquote><p>A major cost of implementing <code>Serializable</code> is that it decreases the flexibility to change a classes implementation once it has been released.</p></blockquote><p>我们在 <a href="#item-85-%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8-java-%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88">Item 85</a> 中就提到了, <strong>使用 Java 的序列化方式可能会导致一些 bug 或者安全性问题.</strong></p><blockquote><p>A second cost of implementing <code>Serializable</code> is that it increases the likelihood of bugs and security holes.</p></blockquote><p><strong>另一个问题就是实现序列化接口会令类的测试工作更加繁重.</strong></p><blockquote><p>A third cost of implementing <code>Serializable</code> is that it increases the testing burden associated with releasing a new version of a class.</p></blockquote><p><strong>当我们想要实现序列化接口时, 考虑一下这样做的收益和风险.</strong></p><blockquote><p>Implementing <code>Serializable</code> is not a decision to be undertaken lightly.</p></blockquote><p><strong>用于被继承的类大多数时候都不应该实现 <code>Serializable</code> 接口, 接口同理.</strong></p><blockquote><p>Classes designed for inheritance should rarely implement <code>Serializable</code>, and interfaces should rarely extend it.</p></blockquote><p><strong>内部类不应该实现 <code>Serializable</code> 接口.</strong></p><blockquote><p>Inner classes should not implement <code>Serializable</code>.</p></blockquote><h3 id="item-87-使用自定义序列化格式" tabindex="-1"><a class="header-anchor" href="#item-87-使用自定义序列化格式" aria-hidden="true">#</a> Item 87: 使用自定义序列化格式</h3><blockquote><p>Consider using a custom serialized form.</p></blockquote><p><strong>默认的序列化格式未必是最佳的, 我们可以使用自定义的序列化格式来达到更好的效果.</strong></p><blockquote><p>Do not accept the default serialized form without first considering whether it is appropriate.</p></blockquote><p><strong>只有在类的物理呈现和逻辑内容相同时, 默认的序列化格式才是可以接受的.</strong></p><blockquote><p>The default serialized form is likely to be appropriate if an object&#39;s physical representation is identical to its logical content.</p></blockquote><p>及时决定使用默认的序列化方式, 也需要提供 <code>readObject()</code> 方法来保证不变性和安全性.</p><blockquote><p>Even if you decide that the default serialized form is appropriate, you often must provide a <code>readObject()</code> method to ensure invariants and security.</p></blockquote><p>在序列化时, 我们可以使用 <code>transient</code> 决定哪些字段会被序列化, 而哪些不会. <strong>被 <code>transient</code> 关键字修饰的字段不会被序列化.</strong></p><p><strong>确保不被 <code>transient</code> 修饰的字段都是类实例逻辑状态的一部分.</strong></p><blockquote><p>Before deciding to make a field nontransient, convince yourself that its value is part of the logical state of the object.</p></blockquote><p><strong>必须对所有的序列化操作采取同步操作.</strong> 一般来说都是在序列化和反序列化方法上使用 <code>synchronized</code> 修饰.</p><blockquote><p>You must impose any synchronization on object serialization that you would impose on any other method that read the entire state of the object.</p></blockquote><p><strong>为任何的可序列化的类添加 UID 字段. 一旦设定之后, 就不要轻易改变 UID, 除非我们想要和之前的内容进行区分.</strong></p><blockquote><p>Regardless of what serialized form you choose, declare an explicit serial version UID in every serializable class you write. Do not change the serial version UID unless you want to break compatibility with all existing serialized instances of a class.</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> randomLongValue<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="item-88-防御性地编写-readobject-方法" tabindex="-1"><a class="header-anchor" href="#item-88-防御性地编写-readobject-方法" aria-hidden="true">#</a> Item 88: 防御性地编写 readObject 方法</h3><blockquote><p>Write <code>readObject()</code> methods defensively.</p></blockquote><p>就像我们在 <a href="#item-50-%E5%9C%A8%E9%9C%80%E8%A6%81%E6%97%B6%E5%88%B6%E4%BD%9C%E9%98%B2%E5%BE%A1%E6%80%A7%E5%89%AF%E6%9C%AC">Item 50</a> 中提到的那样, 可以通过防御性副本保证更小被客户端破坏稳定性的可能.</p><p><strong>反序列化对象时, 防御性地复制任何包含禁止客户端处理的对象引用的字段.</strong></p><blockquote><p>When an object is deserialized, it is critical to defensively copy any field containing an object reference that a client must not process.</p></blockquote><h3 id="item-89-优先使用枚举类型进行实例控制" tabindex="-1"><a class="header-anchor" href="#item-89-优先使用枚举类型进行实例控制" aria-hidden="true">#</a> Item 89: 优先使用枚举类型进行实例控制</h3><blockquote><p>For instance control, prefer enum types to <code>readResolve()</code>.</p></blockquote><p>实现了序列化的类会打破单例的特性, 因为它们可以被动态地反序列化生成新的类实例. 不过我们可以通过 <code>readResolve()</code> 方法来保证单例.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">Object</span> <span class="token function">readResolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token constant">INSTANCE</span><span class="token operator">:</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>如果通过 <code>readResolve()</code> 进行实例控制, 那么所有的引用类型的实例字段都应该被 <code>transient</code> 修饰.</strong> 否则可能会在实例没有被创建时, 通过反序列化的方式创建不安全的实例, 导致安全性问题. <strong>但是使用枚举类进行实例控制不会有这样的问题.</strong></p><blockquote><p>If you depend on <code>readResolve()</code> for instance control, all instance fields with object reference types <em>must</em> be declared <code>transient</code>.</p></blockquote><p><strong><code>readResolve()</code> 方法的可访问性是很重要的.</strong> 如果方法被定义在被 <code>final</code> 修饰的类中, 那么它应该是 <code>private</code> 的; 反之, 就需要慎重考虑是否需要被子类重写了.</p><blockquote><p>The accessibility of <code>readResolve()</code> is significant.</p></blockquote><h3 id="item-90-考虑序列化代理而不是序列化实例" tabindex="-1"><a class="header-anchor" href="#item-90-考虑序列化代理而不是序列化实例" aria-hidden="true">#</a> Item 90: 考虑序列化代理而不是序列化实例</h3><blockquote><p>Consider serialization proxies instead of serialized instances.</p></blockquote><p>这里提供一种<strong>序列化代理模式(<em>serialization proxy pattern</em>)</strong>: 使用一个<strong>私有静态内部类</strong> 来完整地表征封装类实例的所有逻辑状态. 这个私有静态内部类就是封装类的序列化代理(<em>serialization proxy</em>). 内部类的构造方法参数是它的封装类实例, 对封装类的所有逻辑状态进行简单复制(不需要进行任何的检查或防御性复制). 只需要内部类实现 <code>Serializable</code> 接口, 并且默认的序列化格式就是内部类的所有字段信息. 然后通过 <code>writeReplace()</code> 方法来创建内部类的实例. 用于序列化.</p><p>我们以 <a href="#item-50-%E5%9C%A8%E9%9C%80%E8%A6%81%E6%97%B6%E5%88%B6%E4%BD%9C%E9%98%B2%E5%BE%A1%E6%80%A7%E5%89%AF%E6%9C%AC">Item 50</a> 中的类作为例子:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Period</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Date</span> start<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Date</span> end<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Period</span><span class="token punctuation">(</span><span class="token class-name">Date</span> start<span class="token punctuation">,</span> <span class="token class-name">Date</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>start<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>end<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 先复制, 再比较</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>start<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>start <span class="token operator">+</span> <span class="token string">&quot; after &quot;</span> <span class="token operator">+</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Date</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>start<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Date</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>end<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SerializationProxy</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Date</span> start<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Date</span> end<span class="token punctuation">;</span>

        <span class="token class-name">SerializationProxy</span><span class="token punctuation">(</span><span class="token class-name">Period</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> p<span class="token punctuation">.</span>start<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> p<span class="token punctuation">.</span>end<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> anyRandomLongNumber<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token class-name">Object</span> <span class="token function">writeReplace</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SerializationProxy</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">readObject</span><span class="token punctuation">(</span><span class="token class-name">ObjectInputStream</span> stream<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InvalidObjectException</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InvalidObjectException</span><span class="token punctuation">(</span><span class="token string">&quot;Proxy required&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token class-name">Object</span> <span class="token function">readResolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Period</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="结语" tabindex="-1"><a class="header-anchor" href="#结语" aria-hidden="true">#</a> 结语</h2><p>妈妈我终于看完这本书的英文版了, 太煎熬了呜呜呜呜. -- 2023.10.29</p></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/Riicarus/edit/main/docs/posts/Java/CodeSpecification/EffectiveJava.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: riicarus.acc@gmail.com">Riicarus</span><!--]--><!--]--></div></div></footer><!----><!----><!----><!--]--></main><!--]--><!----></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app-1db72e39.js" defer></script>
  </body>
</html>
