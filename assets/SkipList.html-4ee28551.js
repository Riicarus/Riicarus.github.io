import{_ as l,V as e,W as p,X as s,Y as n,Z as i,$ as a,F as c}from"./framework-c6791857.js";const o="/assets/AVLTree-2aa19aa7.png",r="/assets/SkipListEvolution-66b736ea.png",u="/assets/SkipListSearchProcess-810451f1.png",m={},d=s("h1",{id:"skiplist-跳跃表",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#skiplist-跳跃表","aria-hidden":"true"},"#"),n(" SkipList(跳跃表)")],-1),h=s("p",null,"SkipList 作为 Redis zset 的重要实现方式, 提供了很好的插入和删除性能, 同时在排序和搜索上也毫不逊色. 本文通过对一篇论文的阅读来理解 SkipList 的实现和优缺点.",-1),k=s("h2",{id:"论文-skip-lists-a-probabilistic-alternative-to-balanced-trees",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#论文-skip-lists-a-probabilistic-alternative-to-balanced-trees","aria-hidden":"true"},"#"),n(" 论文: Skip Lists: A Probabilistic Alternative to Balanced Trees")],-1),v={href:"https://sci-hub.se/10.1145/78973.78977",target:"_blank",rel:"noopener noreferrer"},g=a('<blockquote><p>Skip lists are data structures that use probabilistic balancing rather than strictly enforced balancing. As a result, the algorithms for insertion and deletion in skip lists are much simpler and significantly faster than equivalent algorithms for balanced trees.<br> 跳跃表使用概率来保证平衡, 而不是严格使用强制平衡操作来保证(如平衡树). 因此, 相较平衡树的平衡算法来说, 跳跃表的插入和删除算法要简单和快捷很多.</p></blockquote><h3 id="平衡树" tabindex="-1"><a class="header-anchor" href="#平衡树" aria-hidden="true">#</a> 平衡树</h3><p>我们先来看看平衡树. 平衡树作为一个抽象数据结构, 被广泛用于字典和有序列表中. 当被插入元素是以随机顺序插入时, 平衡树的表现良好. 但如果以有序的顺序插入时, 平衡树的结构会退化为链表, 导致很多次的重新平衡操作, 性能很差. 平衡树算法在执行操作时重新排列树, 以保持一定的平衡状态并确保良好的性能. 由此我们发现, 平衡树处理插入序列中有序子序列较多的情况时表现不够好, 主要原因是有序子序列带来的很多次的重新平衡操作.</p><figure><img src="'+o+'" alt="AVLTree" tabindex="0" loading="lazy"><figcaption>AVLTree</figcaption></figure><h3 id="skiplist" tabindex="-1"><a class="header-anchor" href="#skiplist" aria-hidden="true">#</a> SkipList</h3><p>再来看 SkipList.</p>',6),b=s("p",null,[n("对于一个(有序)链表来说, 搜索一个节点, 需要遍历整个树, 需要不超过 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])]),n(" 次查找; 如果每个节点都有指向其后第二个节点的指针, 那么我们需要不超过 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n"),s("mi",{mathvariant:"normal"},"/"),s("mn",null,"2"),s("mo",null,"+"),s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"n / 2 + 1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mord"},"/2"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])]),n(" 次查找; 如果每个节点再增加一个指向其后第四个节点的指针, 那么查找次数会变为不超过 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n"),s("mi",{mathvariant:"normal"},"/"),s("mn",null,"4"),s("mo",null,"+"),s("mn",null,"2")]),s("annotation",{encoding:"application/x-tex"},"n / 4 + 2")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mord"},"/4"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"2")])])]),n(" 次; 如果每个节点都维持指向其后第 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mn",null,"2"),s("mi",null,"i")])]),s("annotation",{encoding:"application/x-tex"},"2^i")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8247em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8247em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"i")])])])])])])])])])]),n(" 个节点的指针, 那么查找次数会变为不超过 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mrow",null,[s("mi",null,"log"),s("mo",null,"⁡")]),s("mn",null,"2")]),s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"\\log_2n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.9386em","vertical-align":"-0.2441em"}}),s("span",{class:"mop"},[s("span",{class:"mop"},[n("lo"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.207em"}},[s("span",{style:{top:"-2.4559em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2441em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"n")])])]),n(" 次. 由上, 我们使用增加向后的指针的方式, 将搜索的时间复杂度从 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),n(" 成功降低至 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"log"),s("mo",null,"⁡"),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(\\log n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mop"},[n("lo"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),n(". 不过这样也会有问题: 如果链表长度为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])]),n(", 那么我们需要为每个节点维护 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mrow",null,[s("mi",null,"log"),s("mo",null,"⁡")]),s("mn",null,"2")]),s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"\\log_2 n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.9386em","vertical-align":"-0.2441em"}}),s("span",{class:"mop"},[s("span",{class:"mop"},[n("lo"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.207em"}},[s("span",{style:{top:"-2.4559em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2441em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"n")])])]),n(" 个指向后续节点的指针, 当 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])]),n(" 非常大时, 这个维护成本会变得很高.")],-1),x=s("figure",null,[s("img",{src:r,alt:"SkipList",tabindex:"0",loading:"lazy"}),s("figcaption",null,"SkipList")],-1),w=s("p",null,[n("我们将一个具有指向其后 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])]),n(" 个节点的指针的节点称为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])]),n(" 层节点. 如果每 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mn",null,"2"),s("mi",null,"i")])]),s("annotation",{encoding:"application/x-tex"},"2^i")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8247em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8247em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"i")])])])])])])])])])]),n(" 个节点都有指向其后第 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mn",null,"2"),s("mi",null,"i")])]),s("annotation",{encoding:"application/x-tex"},"2^i")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8247em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8247em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"i")])])])])])])])])])]),n(" 个节点的指针, 那么每层节点会有如下的简单分布:")],-1),y=s("ul",null,[s("li",null,"第 1 层节点: 50%"),s("li",null,"第 2 层节点: 25%"),s("li",null,"第 3 层节点: 12.5%"),s("li",null,"...")],-1),L=s("p",null,[n("但是这样会使得链表结构被束缚住(每层间距必须相等), 和平衡树面临的问题类似了. 那如果我们保持这个分布概率, 但是让"),s("strong",null,"每一层节点随机分布"),n("; 节点的第 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"i")]),s("annotation",{encoding:"application/x-tex"},"i")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6595em"}}),s("span",{class:"mord mathnormal"},"i")])])]),n(" 层指针不需要一定指向其后第 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mn",null,"2"),s("mi",null,"i")])]),s("annotation",{encoding:"application/x-tex"},"2^i")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8247em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8247em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"i")])])])])])])])])])]),n(" 个节点, 而是"),s("strong",null,"指向下一个同层或更高层的节点"),n("; "),s("strong",null,"节点的层数由插入前随机选择"),n("; 这样的话, 我们能够在绝大多数情况下得到 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"log"),s("mo",null,"⁡"),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(\\log n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mop"},[n("lo"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),n(" 的复杂度, 而不被之前的结构束缚.")],-1),f=s("h3",{id:"skiplist-相关算法",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#skiplist-相关算法","aria-hidden":"true"},"#"),n(" SkipList 相关算法")],-1),M=s("p",null,"SkipList 相较于普通的 LinkedList, 不同的算法主要包括初始化, 插入/删除和搜索.",-1),_=s("h4",{id:"结构",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#结构","aria-hidden":"true"},"#"),n(" 结构")],-1),z=s("ul",null,[s("li",null,"每个元素用节点来抽象, 节点的层数是随机产生的."),s("li",null,[n("第 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])]),n(" 层节点拥有从 1 到 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])]),n(" 层的指针.")]),s("li",null,[n("链表的最大层数被设置为一个常数 "),s("code",null,"MaxLevel")]),s("li",null,[n("链表只保存当前的最高层数为 "),s("code",null,"level"),n(".")]),s("li",null,[n("链表的头节点拥有从 1 到 "),s("code",null,"level"),n(" 层的指针, 分别指向后续节点或者尾节点.")]),s("li",null,[n("链表的尾节点从 1 到 "),s("code",null,"level"),n(" 层的指针, 分别由前驱节点或者头节点指向, 被命名为 "),s("code",null,"NIL"),n(". 所有层的节点最终都会指向 "),s("code",null,"NIL"),n(".")])],-1),S=a(`<h4 id="初始化" tabindex="-1"><a class="header-anchor" href="#初始化" aria-hidden="true">#</a> 初始化</h4><p>SkipList 的 <code>level</code> 被设置为 1, 初始化 <code>NIL</code> 尾节点, 将头节点指向 <code>NIL</code>.</p><h4 id="搜索" tabindex="-1"><a class="header-anchor" href="#搜索" aria-hidden="true">#</a> 搜索</h4><p>从头节点开始, 由高层向底层搜索, 先从高层迅速迭代, 如果高层不能继续迭代, 就下降一层, 由此循环直到第一层遍历结束. 此时停止的节点, 要么是要寻找的节点, 要么就是链表中不存在对应的元素.</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>l <span class="token operator">*</span>SkipList<span class="token punctuation">)</span> <span class="token function">Search</span><span class="token punctuation">(</span>searchKey <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x <span class="token operator">:=</span> l<span class="token punctuation">.</span>header

    <span class="token comment">// 这里会一直迭代到第一层 key 最大但是不大于 searchKey 的节点</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> l<span class="token punctuation">.</span>level<span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">;</span> x<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">&lt;</span> searchKey<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 必定是下一个节点</span>
    x <span class="token operator">:=</span> x<span class="token punctuation">.</span>forward<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>

    <span class="token keyword">if</span> x<span class="token punctuation">.</span>key <span class="token operator">!=</span> searchKey <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">,</span> SkipList<span class="token punctuation">.</span>NIL
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> x<span class="token punctuation">.</span>value<span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="插入-删除" tabindex="-1"><a class="header-anchor" href="#插入-删除" aria-hidden="true">#</a> 插入/删除</h4><p>为了找到要插入或者删除元素的位置, 我们需要先使用 <code>Search()</code> 的逻辑来获得位置信息. 然后插入/删除对应的节点, 更新相关的元素(每一层需要更新的指针, 使用 <code>update</code> 表示). 如果插入节点的层数大于当前链表的最大层数, 那么需要更新链表的最大层数 <code>level</code>.</p><figure><img src="`+u+`" alt="SkipListSearchProcess" tabindex="0" loading="lazy"><figcaption>SkipListSearchProcess</figcaption></figure><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>l <span class="token operator">*</span>SkipList<span class="token punctuation">)</span> <span class="token function">Insert</span><span class="token punctuation">(</span>searchKey<span class="token punctuation">,</span> newValue <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    update <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Node<span class="token punctuation">,</span> MaxLevel<span class="token punctuation">)</span>

    x <span class="token operator">:=</span> l<span class="token punctuation">.</span>header
    <span class="token keyword">for</span> i <span class="token operator">:=</span> l<span class="token punctuation">.</span>level<span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">;</span> x<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">&lt;</span> searchKey<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        update<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x
    <span class="token punctuation">}</span>
    x <span class="token operator">:=</span> x<span class="token punctuation">.</span>forward<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>

    <span class="token keyword">if</span> x<span class="token punctuation">.</span>key <span class="token operator">=</span> searchKey <span class="token punctuation">{</span>
        x<span class="token punctuation">.</span>value <span class="token operator">=</span> newValue
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>

    newLevel <span class="token operator">:=</span> <span class="token function">randomLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> newLevel <span class="token operator">&gt;</span> l<span class="token punctuation">.</span>level <span class="token punctuation">{</span>
        <span class="token keyword">for</span> i <span class="token operator">:=</span> l<span class="token punctuation">.</span>level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> newLevel<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
            update<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> l<span class="token punctuation">.</span>header
    <span class="token punctuation">}</span>
        l<span class="token punctuation">.</span>level <span class="token operator">=</span> newLevel
    <span class="token punctuation">}</span>

    x <span class="token operator">:=</span> <span class="token function">makeNode</span><span class="token punctuation">(</span>newLevel<span class="token punctuation">,</span> searchKey<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> newLevel<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
        x<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>l <span class="token operator">*</span>SkipList<span class="token punctuation">)</span> <span class="token function">Delete</span><span class="token punctuation">(</span>searchKey <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    update <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Node<span class="token punctuation">,</span> MaxLevel<span class="token punctuation">)</span>

    x <span class="token operator">:=</span> l<span class="token punctuation">.</span>header
    <span class="token keyword">for</span> i <span class="token operator">:=</span> l<span class="token punctuation">.</span>level<span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">;</span> x<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">&lt;</span> searchKey<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        update<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x
    <span class="token punctuation">}</span>
    x <span class="token operator">:=</span> x<span class="token punctuation">.</span>forward<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>

    <span class="token keyword">if</span> x<span class="token punctuation">.</span>key <span class="token operator">=</span> searchKey <span class="token punctuation">{</span>
        <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> l<span class="token punctuation">.</span>level<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> x <span class="token punctuation">{</span>
                <span class="token keyword">break</span>
            <span class="token punctuation">}</span>
            update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 由上到下清除不需要的层</span>
        <span class="token keyword">for</span> <span class="token punctuation">;</span>l<span class="token punctuation">.</span>level <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> l<span class="token punctuation">.</span>header<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>l<span class="token punctuation">.</span>level<span class="token punctuation">]</span> <span class="token operator">=</span> NILNode <span class="token punctuation">{</span>
                l<span class="token punctuation">.</span>level<span class="token operator">--</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> x<span class="token punctuation">.</span>value<span class="token punctuation">,</span> <span class="token boolean">nil</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">,</span> SkipList<span class="token punctuation">.</span>NIL
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">randomLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
    newLevel <span class="token operator">:=</span> <span class="token number">1</span>
    <span class="token keyword">for</span> <span class="token punctuation">;</span> <span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> p<span class="token punctuation">;</span> newLevel<span class="token operator">++</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token function">min</span><span class="token punctuation">(</span>newLevel<span class="token punctuation">,</span> MaxLevel<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="从哪里开始搜索" tabindex="-1"><a class="header-anchor" href="#从哪里开始搜索" aria-hidden="true">#</a> 从哪里开始搜索?</h3><p>在上面的算法中, 我们简单的从最高层开始搜索. 但是我们可以考虑一个极端情况:<br> 如果 <code>MaxLevel</code> 设置为 32, 链表中有 16 个元素, <code>randomLevel()</code> 中 <code>p</code> 设置为 1/2, 可能有如下情况: 第 1 层有 9 个元素; 第 2 层有 3 个元素; 第 3 层有 3 个元素; 第 14 层有 1 个元素. 如果从最高层开始搜索, 就会做很多次无意义的迭代.</p>`,11),N=s("p",null,[n("那我们应该从哪个地方开始搜索呢? 论文分析中指出, 应该从 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"L"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},")"),s("mo",null,"="),s("msub",null,[s("mrow",null,[s("mi",null,"log"),s("mo",null,"⁡")]),s("mrow",null,[s("mn",null,"1"),s("mi",{mathvariant:"normal"},"/"),s("mi",null,"p")])]),s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"L(n) = \\log_{1/p}n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal"},"L"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.1136em","vertical-align":"-0.4191em"}}),s("span",{class:"mop"},[s("span",{class:"mop"},[n("lo"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2809em"}},[s("span",{style:{top:"-2.4559em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mtight"},"1/"),s("span",{class:"mord mathnormal mtight"},"p")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.4191em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"n")])])]),n(" ("),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])]),n(" 为节点个数)开始. 对于此, 我们有如下解决方案:")],-1),K=s("ul",null,[s("li",null,[n("直接不管, 从最高层莽就完了. 极端情况之所以为极端情况, 就是因为发生概率极小, 而且我们可以从上述情况推测出, 这种极端情况出现在 "),s("code",null,"MaxLevel"),n(" 远大于当前数据量需要的层数时. 而在实际应用中, 对于大量数据的处理基本不会有这种情况发生(本身数据量大, 就需要较大的 "),s("code",null,"MaxLevel"),n("); 对于少量数据的处理, 极端情况带来的多余迭代操作控制在很小的常数级, 用不着关心.")]),s("li",null,[n("从更小的层数开始. 直接通过 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"L"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"L(n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal"},"L"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),n(" 计算出开始层数, 然后由此向下遍历. 但是这样为每次的操作都进行计算, 只是为了减少概率极小的情况, 性能反而降低很多.")]),s("li",null,[n("消除空层. 当待添加节点的 "),s("code",null,"newLevel"),n(" 大于 "),s("code",null,"l.level"),n(" 的时候, 将 "),s("code",null,"newLevel"),n(" 和 "),s("code",null,"l.level"),n(" 都设置为 "),s("code",null,"l.level + 1"),n(", 这样就不会出现空层. 但是, 每次只增加一层, 会破坏随机性, 应该避免此类操作.")])],-1),V=s("h3",{id:"maxlevel-如何确定",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#maxlevel-如何确定","aria-hidden":"true"},"#"),n(),s("code",null,"MaxLevel"),n(" 如何确定?")],-1),I=s("p",null,[n("由公式 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"L"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},")"),s("mo",null,"="),s("msub",null,[s("mrow",null,[s("mi",null,"log"),s("mo",null,"⁡")]),s("mrow",null,[s("mn",null,"1"),s("mi",{mathvariant:"normal"},"/"),s("mi",null,"p")])]),s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"L(n) = \\log_{1/p}n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal"},"L"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.1136em","vertical-align":"-0.4191em"}}),s("span",{class:"mop"},[s("span",{class:"mop"},[n("lo"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2809em"}},[s("span",{style:{top:"-2.4559em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mtight"},"1/"),s("span",{class:"mord mathnormal mtight"},"p")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.4191em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"n")])])]),n(", 确定 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"M"),s("mi",null,"a"),s("mi",null,"x"),s("mi",null,"L"),s("mi",null,"e"),s("mi",null,"v"),s("mi",null,"e"),s("mi",null,"l"),s("mo",null,"="),s("mo",{stretchy:"false"},"⌈"),s("mi",null,"L"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},")"),s("mo",{stretchy:"false"},"⌉")]),s("annotation",{encoding:"application/x-tex"},"MaxLevel = \\lceil L(n) \\rceil")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6944em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"M"),s("span",{class:"mord mathnormal"},"a"),s("span",{class:"mord mathnormal"},"xL"),s("span",{class:"mord mathnormal"},"e"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"v"),s("span",{class:"mord mathnormal"},"e"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"⌈"),s("span",{class:"mord mathnormal"},"L"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")⌉")])])]),n(". 如: "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"p"),s("mo",null,"="),s("mn",null,"1"),s("mi",{mathvariant:"normal"},"/"),s("mn",null,"2"),s("mo",{separator:"true"},","),s("mi",null,"M"),s("mi",null,"a"),s("mi",null,"x"),s("mi",null,"L"),s("mi",null,"e"),s("mi",null,"v"),s("mi",null,"e"),s("mi",null,"l"),s("mo",null,"="),s("mn",null,"16")]),s("annotation",{encoding:"application/x-tex"},"p = 1/2, MaxLevel = 16")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.625em","vertical-align":"-0.1944em"}}),s("span",{class:"mord mathnormal"},"p"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"1/2"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"M"),s("span",{class:"mord mathnormal"},"a"),s("span",{class:"mord mathnormal"},"xL"),s("span",{class:"mord mathnormal"},"e"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"v"),s("span",{class:"mord mathnormal"},"e"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"16")])])]),n(", 可以保存 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mn",null,"2"),s("mn",null,"16")])]),s("annotation",{encoding:"application/x-tex"},"2^{16}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8141em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8141em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mtight"},"16")])])])])])])])])])])]),n(" 个数据.")],-1),O=a(`<blockquote><p>Redis 中 SkipList 的 <code>MaxLevel</code> 为 32.</p></blockquote><h2 id="redis-skiplist" tabindex="-1"><a class="header-anchor" href="#redis-skiplist" aria-hidden="true">#</a> Redis SkipList</h2><h3 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h3><p>Redis 中, <code>zset</code> 的底层实现包括 <code>ziplist</code> 和 <code>skiplist</code>, 当元素数量大于 128 个或者元素大小大于 64 字节时, 就会使用 <code>skiplist</code> 来实现. 与上面论文讲述不同, Redis <strong>允许有相同的 <code>key</code> 存在</strong>, 因此会增加对 <code>value</code> 是否相等的判断逻辑. 同时, <strong>每个节点还增加了一个跨度为 1 的后退指针</strong>, 由表尾向表头迭代, 用于进行逆序操作. 对于每层前进指针, 不止保存下一个元素的指针, 还会保存当前层跨域的节点数量, 用于进行一些区间操作.</p><p><code>redis.h/zskiplist</code> 定义跳跃表结构:</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zskiplist</span> <span class="token punctuation">{</span>

    <span class="token comment">// 头节点，尾节点</span>
    <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>header<span class="token punctuation">,</span> <span class="token operator">*</span>tail<span class="token punctuation">;</span>

    <span class="token comment">// 节点数量</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> length<span class="token punctuation">;</span>

    <span class="token comment">// 目前表内节点的最大层数</span>
    <span class="token keyword">int</span> level<span class="token punctuation">;</span>

<span class="token punctuation">}</span> zskiplist<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>redis.h/zskiplistNode</code> 定义跳跃表节点:</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token punctuation">{</span>

    <span class="token comment">// member 对象</span>
    robj <span class="token operator">*</span>obj<span class="token punctuation">;</span>

    <span class="token comment">// 分值</span>
    <span class="token keyword">double</span> score<span class="token punctuation">;</span>

    <span class="token comment">// 后退指针</span>
    <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>backward<span class="token punctuation">;</span>

    <span class="token comment">// 层</span>
    <span class="token keyword">struct</span> <span class="token class-name">zskiplistLevel</span> <span class="token punctuation">{</span>

        <span class="token comment">// 前进指针</span>
        <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>forward<span class="token punctuation">;</span>

        <span class="token comment">// 这个层跨越的节点数量</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> span<span class="token punctuation">;</span>

    <span class="token punctuation">}</span> level<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span> zskiplistNode<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="使用" tabindex="-1"><a class="header-anchor" href="#使用" aria-hidden="true">#</a> 使用</h3><p>SkipList 的使用目的很简单, 就是实现有序数据集.<br><code>zset</code> 可以用于<strong>集合排序/延时队列/Top K/范围查找</strong>等场景.</p>`,10);function A(T,q){const t=c("ExternalLinkIcon");return e(),p("div",null,[d,h,k,s("p",null,[s("a",v,[n("Skip Lists: A Probabilistic Alternative to Balanced Trees"),i(t)])]),g,b,x,w,y,L,f,M,_,z,S,N,K,V,I,O])}const P=l(m,[["render",A],["__file","SkipList.html.vue"]]);export{P as default};
