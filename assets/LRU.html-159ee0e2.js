const e=JSON.parse('{"key":"v-7b33041c","path":"/posts/Algorithm/Replacement/LRU.html","title":"LRU","lang":"zh-CN","frontmatter":{"date":"2023-03-20T00:00:00.000Z","category":["算法"],"tag":["LRU"],"description":"LRU LRU(Least Recent Used), 是一种缓存置换算法, 当需要置换时, 将最近最少使用的元素置换出缓存. 如果是 Java 的话, 可以直接继承 LinkedHashMap, 修改 removeOldest() 方法即可. Go 中没有这个实现, 可以自己通过 map 和 双向链表实现一个 LinkedHashMap. 用这种方法实现的 LRU 算法, 读写的时间复杂度都为 O(1), 空间复杂度为 O(n).","head":[["meta",{"property":"og:url","content":"https://riicarus.github.io/posts/Algorithm/Replacement/LRU.html"}],["meta",{"property":"og:site_name","content":"Riicarus"}],["meta",{"property":"og:title","content":"LRU"}],["meta",{"property":"og:description","content":"LRU LRU(Least Recent Used), 是一种缓存置换算法, 当需要置换时, 将最近最少使用的元素置换出缓存. 如果是 Java 的话, 可以直接继承 LinkedHashMap, 修改 removeOldest() 方法即可. Go 中没有这个实现, 可以自己通过 map 和 双向链表实现一个 LinkedHashMap. 用这种方法实现的 LRU 算法, 读写的时间复杂度都为 O(1), 空间复杂度为 O(n)."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-30T08:13:26.000Z"}],["meta",{"property":"article:tag","content":"LRU"}],["meta",{"property":"article:published_time","content":"2023-03-20T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-03-30T08:13:26.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"LRU\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-20T00:00:00.000Z\\",\\"dateModified\\":\\"2023-03-30T08:13:26.000Z\\",\\"author\\":[]}"]]},"headers":[],"git":{"createdTime":1678075657000,"updatedTime":1680164006000,"contributors":[{"name":"Riicarus","email":"riicarus.acc@gmail.com","commits":2},{"name":"skyline-blue","email":"2895054643@qq.com","commits":1}]},"readingTime":{"minutes":1.4,"words":421},"filePathRelative":"posts/Algorithm/Replacement/LRU.md","localizedDate":"2023年3月20日","excerpt":"<h1> LRU</h1>\\n<p>LRU(Least Recent Used), 是一种缓存置换算法, 当需要置换时, 将最近最少使用的元素置换出缓存.</p>\\n<p>如果是 Java 的话, 可以直接继承 <code>LinkedHashMap</code>, 修改 <code>removeOldest()</code> 方法即可. Go 中没有这个实现, 可以自己通过 <code>map</code> 和 双向链表实现一个 <code>LinkedHashMap</code>. 用这种方法实现的 LRU 算法, 读写的时间复杂度都为 <span class=\\"katex\\"><span class=\\"katex-mathml\\"></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mord mathnormal\\" style=\\"margin-right:0.02778em;\\">O</span><span class=\\"mopen\\">(</span><span class=\\"mord\\">1</span><span class=\\"mclose\\">)</span></span></span></span>, 空间复杂度为 <span class=\\"katex\\"><span class=\\"katex-mathml\\"></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mord mathnormal\\" style=\\"margin-right:0.02778em;\\">O</span><span class=\\"mopen\\">(</span><span class=\\"mord mathnormal\\">n</span><span class=\\"mclose\\">)</span></span></span></span>.</p>","autoDesc":true}');export{e as data};
