const e=JSON.parse('{"key":"v-1c815d41","path":"/posts/Java/CodeSpecification/EffectiveJava.html","title":"Effective Java","lang":"zh-CN","frontmatter":{"date":"2023-09-26T00:00:00.000Z","category":["Java","Specification"],"tag":["Java","Specification","Effective Java"],"description":"Effective Java 本文中, 英文部分均来自于原文摘抄, 如果想要更好的理解和阅读体验, 请不要忽略英文引用! Effective Java 这本书作为 Java 编程思想和范式的\\"集大成者\\", 需要很深的 Java 编程功底. 我在阅读时也感受到很多没有了解过的东西, 尤其是读英文原著, 感觉一些部分的理解尚且非常浅薄, 尤以 Stream API 的部分为甚. 现在只是第一遍阅读这本书的原版, 只在博客中做粗略的记录和思考. 在读完第一遍之后, 会再次进行巩固和更新.","head":[["meta",{"property":"og:url","content":"https://riicarus.github.io/posts/Java/CodeSpecification/EffectiveJava.html"}],["meta",{"property":"og:site_name","content":"Riicarus"}],["meta",{"property":"og:title","content":"Effective Java"}],["meta",{"property":"og:description","content":"Effective Java 本文中, 英文部分均来自于原文摘抄, 如果想要更好的理解和阅读体验, 请不要忽略英文引用! Effective Java 这本书作为 Java 编程思想和范式的\\"集大成者\\", 需要很深的 Java 编程功底. 我在阅读时也感受到很多没有了解过的东西, 尤其是读英文原著, 感觉一些部分的理解尚且非常浅薄, 尤以 Stream API 的部分为甚. 现在只是第一遍阅读这本书的原版, 只在博客中做粗略的记录和思考. 在读完第一遍之后, 会再次进行巩固和更新."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-11-17T18:15:44.000Z"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"Specification"}],["meta",{"property":"article:tag","content":"Effective Java"}],["meta",{"property":"article:published_time","content":"2023-09-26T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-11-17T18:15:44.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Effective Java\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-09-26T00:00:00.000Z\\",\\"dateModified\\":\\"2023-11-17T18:15:44.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"对象的创建与销毁","slug":"对象的创建与销毁","link":"#对象的创建与销毁","children":[{"level":3,"title":"Item 1: 使用静态工厂方法代替构造方法","slug":"item-1-使用静态工厂方法代替构造方法","link":"#item-1-使用静态工厂方法代替构造方法","children":[]},{"level":3,"title":"Item 2: 使用构造器代替构造方法","slug":"item-2-使用构造器代替构造方法","link":"#item-2-使用构造器代替构造方法","children":[]},{"level":3,"title":"Item 3: 强制单例构造方法私有或使用枚举类","slug":"item-3-强制单例构造方法私有或使用枚举类","link":"#item-3-强制单例构造方法私有或使用枚举类","children":[]},{"level":3,"title":"Item 4: 强制非实例化类的构造方法私有","slug":"item-4-强制非实例化类的构造方法私有","link":"#item-4-强制非实例化类的构造方法私有","children":[]},{"level":3,"title":"Item 5: 使用依赖注入替代硬性资源引用","slug":"item-5-使用依赖注入替代硬性资源引用","link":"#item-5-使用依赖注入替代硬性资源引用","children":[]},{"level":3,"title":"Item 6: 避免创建不必要的实例","slug":"item-6-避免创建不必要的实例","link":"#item-6-避免创建不必要的实例","children":[]},{"level":3,"title":"Item 7: 消除过时的对象引用","slug":"item-7-消除过时的对象引用","link":"#item-7-消除过时的对象引用","children":[]},{"level":3,"title":"Item 8: 避免使用 finalize() 等方法","slug":"item-8-避免使用-finalize-等方法","link":"#item-8-避免使用-finalize-等方法","children":[]},{"level":3,"title":"Item 9: 使用 try-with-resources 替代 try-finally","slug":"item-9-使用-try-with-resources-替代-try-finally","link":"#item-9-使用-try-with-resources-替代-try-finally","children":[]}]},{"level":2,"title":"类共有方法","slug":"类共有方法","link":"#类共有方法","children":[{"level":3,"title":"Item 10: 遵循重写 equals() 方法的共识","slug":"item-10-遵循重写-equals-方法的共识","link":"#item-10-遵循重写-equals-方法的共识","children":[]},{"level":3,"title":"Item 11: 总是同时重写 hashCode() 和 equals() 方法","slug":"item-11-总是同时重写-hashcode-和-equals-方法","link":"#item-11-总是同时重写-hashcode-和-equals-方法","children":[]},{"level":3,"title":"Item 12: 总是重写 toString() 方法","slug":"item-12-总是重写-tostring-方法","link":"#item-12-总是重写-tostring-方法","children":[]},{"level":3,"title":"Item 13: 谨慎地重写 clone() 方法","slug":"item-13-谨慎地重写-clone-方法","link":"#item-13-谨慎地重写-clone-方法","children":[]},{"level":3,"title":"Item 14: 考虑实现 Comparable 接口","slug":"item-14-考虑实现-comparable-接口","link":"#item-14-考虑实现-comparable-接口","children":[]}]},{"level":2,"title":"类与接口","slug":"类与接口","link":"#类与接口","children":[{"level":3,"title":"Item 15: 最小化类和成员可见性","slug":"item-15-最小化类和成员可见性","link":"#item-15-最小化类和成员可见性","children":[]},{"level":3,"title":"Item 16: 在公共类中, 使用访问方法, 而不是公共字段","slug":"item-16-在公共类中-使用访问方法-而不是公共字段","link":"#item-16-在公共类中-使用访问方法-而不是公共字段","children":[]},{"level":3,"title":"Item 17: 最小化可变性","slug":"item-17-最小化可变性","link":"#item-17-最小化可变性","children":[]},{"level":3,"title":"Item 18: 使用组合替代继承","slug":"item-18-使用组合替代继承","link":"#item-18-使用组合替代继承","children":[]},{"level":3,"title":"Item 19: 要么为继承做好兼容和文档化, 要么禁止继承","slug":"item-19-要么为继承做好兼容和文档化-要么禁止继承","link":"#item-19-要么为继承做好兼容和文档化-要么禁止继承","children":[]},{"level":3,"title":"Item 20: 使用接口替代抽象类","slug":"item-20-使用接口替代抽象类","link":"#item-20-使用接口替代抽象类","children":[]},{"level":3,"title":"Item 21: 为子类设计接口","slug":"item-21-为子类设计接口","link":"#item-21-为子类设计接口","children":[]},{"level":3,"title":"Item 22: 只用接口来定义类型","slug":"item-22-只用接口来定义类型","link":"#item-22-只用接口来定义类型","children":[]},{"level":3,"title":"Item 23: 使用类的层级结构代替类标签","slug":"item-23-使用类的层级结构代替类标签","link":"#item-23-使用类的层级结构代替类标签","children":[]},{"level":3,"title":"Item 24: 尽可能使用静态成员类","slug":"item-24-尽可能使用静态成员类","link":"#item-24-尽可能使用静态成员类","children":[]},{"level":3,"title":"Item 25: 一个源文件中只应该有一个主类","slug":"item-25-一个源文件中只应该有一个主类","link":"#item-25-一个源文件中只应该有一个主类","children":[]}]},{"level":2,"title":"泛型","slug":"泛型","link":"#泛型","children":[{"level":3,"title":"Item 26: 不要使用原始类型","slug":"item-26-不要使用原始类型","link":"#item-26-不要使用原始类型","children":[]},{"level":3,"title":"Item 27: 排除未检查警告","slug":"item-27-排除未检查警告","link":"#item-27-排除未检查警告","children":[]},{"level":3,"title":"Item 28: 使用 List 替代 Array","slug":"item-28-使用-list-替代-array","link":"#item-28-使用-list-替代-array","children":[]},{"level":3,"title":"Item 29: 使用泛型类","slug":"item-29-使用泛型类","link":"#item-29-使用泛型类","children":[]},{"level":3,"title":"Item 30: 优先使用泛型方法","slug":"item-30-优先使用泛型方法","link":"#item-30-优先使用泛型方法","children":[]},{"level":3,"title":"Item 31: 使用有界通配符来提高 API 的灵活性","slug":"item-31-使用有界通配符来提高-api-的灵活性","link":"#item-31-使用有界通配符来提高-api-的灵活性","children":[]},{"level":3,"title":"Item 32: 明智地组合泛型和可变参数","slug":"item-32-明智地组合泛型和可变参数","link":"#item-32-明智地组合泛型和可变参数","children":[]},{"level":3,"title":"Item 33: 使用各种类型安全的容器","slug":"item-33-使用各种类型安全的容器","link":"#item-33-使用各种类型安全的容器","children":[]}]},{"level":2,"title":"枚举和注解","slug":"枚举和注解","link":"#枚举和注解","children":[{"level":3,"title":"Item 34: 使用枚举而不是 int 常量","slug":"item-34-使用枚举而不是-int-常量","link":"#item-34-使用枚举而不是-int-常量","children":[]},{"level":3,"title":"Item 35: 使用实例字段而不是序数","slug":"item-35-使用实例字段而不是序数","link":"#item-35-使用实例字段而不是序数","children":[]},{"level":3,"title":"Item 36: 使用 EnumSet 代替位字段","slug":"item-36-使用-enumset-代替位字段","link":"#item-36-使用-enumset-代替位字段","children":[]},{"level":3,"title":"Item 37: 使用 EnumMap 而不是序数索引","slug":"item-37-使用-enummap-而不是序数索引","link":"#item-37-使用-enummap-而不是序数索引","children":[]},{"level":3,"title":"Item 38: 使用接口模拟可继承枚举类","slug":"item-38-使用接口模拟可继承枚举类","link":"#item-38-使用接口模拟可继承枚举类","children":[]},{"level":3,"title":"Item 39: 使用注解替代命名模式","slug":"item-39-使用注解替代命名模式","link":"#item-39-使用注解替代命名模式","children":[]},{"level":3,"title":"Item 40: 总是使用 Override 注解","slug":"item-40-总是使用-override-注解","link":"#item-40-总是使用-override-注解","children":[]},{"level":3,"title":"Item-41: 使用标记接口来定义类型","slug":"item-41-使用标记接口来定义类型","link":"#item-41-使用标记接口来定义类型","children":[]}]},{"level":2,"title":"Lambdas 与 Streams","slug":"lambdas-与-streams","link":"#lambdas-与-streams","children":[{"level":3,"title":"Item 42: 使用 Lambda 表达式替代匿名类","slug":"item-42-使用-lambda-表达式替代匿名类","link":"#item-42-使用-lambda-表达式替代匿名类","children":[]},{"level":3,"title":"Item 43: 使用方法引用替代 Lambda 表达式","slug":"item-43-使用方法引用替代-lambda-表达式","link":"#item-43-使用方法引用替代-lambda-表达式","children":[]},{"level":3,"title":"Item 44: 使用标准的函数式接口","slug":"item-44-使用标准的函数式接口","link":"#item-44-使用标准的函数式接口","children":[]},{"level":3,"title":"Item 45: 明智地使用 Stream API","slug":"item-45-明智地使用-stream-api","link":"#item-45-明智地使用-stream-api","children":[]},{"level":3,"title":"Item-46: 在流中使用无副作用函数","slug":"item-46-在流中使用无副作用函数","link":"#item-46-在流中使用无副作用函数","children":[]},{"level":3,"title":"Item 47: 使用 Collection 作为 Stream API 的返回类型, 而不是 Stream","slug":"item-47-使用-collection-作为-stream-api-的返回类型-而不是-stream","link":"#item-47-使用-collection-作为-stream-api-的返回类型-而不是-stream","children":[]},{"level":3,"title":"Item 48: 谨慎使用并行流","slug":"item-48-谨慎使用并行流","link":"#item-48-谨慎使用并行流","children":[]}]},{"level":2,"title":"方法","slug":"方法","link":"#方法","children":[{"level":3,"title":"Item 49: 检查参数有效性","slug":"item-49-检查参数有效性","link":"#item-49-检查参数有效性","children":[]},{"level":3,"title":"Item 50: 在需要时制作防御性副本","slug":"item-50-在需要时制作防御性副本","link":"#item-50-在需要时制作防御性副本","children":[]},{"level":3,"title":"Item 51: 仔细设计方法签名","slug":"item-51-仔细设计方法签名","link":"#item-51-仔细设计方法签名","children":[]},{"level":3,"title":"Item 52: 谨慎重载方法","slug":"item-52-谨慎重载方法","link":"#item-52-谨慎重载方法","children":[]},{"level":3,"title":"Item 53: 谨慎使用可变参数","slug":"item-53-谨慎使用可变参数","link":"#item-53-谨慎使用可变参数","children":[]},{"level":3,"title":"Item 54: 返回空集合或数组, 而不是 null 对象","slug":"item-54-返回空集合或数组-而不是-null-对象","link":"#item-54-返回空集合或数组-而不是-null-对象","children":[]},{"level":3,"title":"Item 55: 谨慎返回 Optional 对象","slug":"item-55-谨慎返回-optional-对象","link":"#item-55-谨慎返回-optional-对象","children":[]},{"level":3,"title":"Item 56: 为所有暴露的 API 中的元素编写文档注释","slug":"item-56-为所有暴露的-api-中的元素编写文档注释","link":"#item-56-为所有暴露的-api-中的元素编写文档注释","children":[]}]},{"level":2,"title":"通用编程事项","slug":"通用编程事项","link":"#通用编程事项","children":[{"level":3,"title":"Item 57: 最小化局部变量的作用域","slug":"item-57-最小化局部变量的作用域","link":"#item-57-最小化局部变量的作用域","children":[]},{"level":3,"title":"Item 58: 使用 for-each 代替 for 循环","slug":"item-58-使用-for-each-代替-for-循环","link":"#item-58-使用-for-each-代替-for-循环","children":[]},{"level":3,"title":"Item 59: 了解并使用库","slug":"item-59-了解并使用库","link":"#item-59-了解并使用库","children":[]},{"level":3,"title":"Item 60: 不要在需要精确结果的地方使用 float 或 double","slug":"item-60-不要在需要精确结果的地方使用-float-或-double","link":"#item-60-不要在需要精确结果的地方使用-float-或-double","children":[]},{"level":3,"title":"Item 61: 使用原始类型而不是装箱类型","slug":"item-61-使用原始类型而不是装箱类型","link":"#item-61-使用原始类型而不是装箱类型","children":[]},{"level":3,"title":"Item 62: 避免在其他类型更合适时使用 String","slug":"item-62-避免在其他类型更合适时使用-string","link":"#item-62-避免在其他类型更合适时使用-string","children":[]},{"level":3,"title":"Item 63: 注意 String 拼接的性能消耗","slug":"item-63-注意-string-拼接的性能消耗","link":"#item-63-注意-string-拼接的性能消耗","children":[]},{"level":3,"title":"Item 64: 通过接口引用对象","slug":"item-64-通过接口引用对象","link":"#item-64-通过接口引用对象","children":[]},{"level":3,"title":"Item 65: 使用接口代替反射","slug":"item-65-使用接口代替反射","link":"#item-65-使用接口代替反射","children":[]},{"level":3,"title":"Item 66: 谨慎使用 native 方法","slug":"item-66-谨慎使用-native-方法","link":"#item-66-谨慎使用-native-方法","children":[]},{"level":3,"title":"Item 67: 谨慎地进行优化","slug":"item-67-谨慎地进行优化","link":"#item-67-谨慎地进行优化","children":[]},{"level":3,"title":"Item 68: 遵守普遍接受的命名约定","slug":"item-68-遵守普遍接受的命名约定","link":"#item-68-遵守普遍接受的命名约定","children":[]}]},{"level":2,"title":"异常","slug":"异常","link":"#异常","children":[{"level":3,"title":"Item 69: 只在异常情况下使用异常","slug":"item-69-只在异常情况下使用异常","link":"#item-69-只在异常情况下使用异常","children":[]},{"level":3,"title":"Item 70: 可恢复环境使用受检异常, 程序错误使用运行时异常","slug":"item-70-可恢复环境使用受检异常-程序错误使用运行时异常","link":"#item-70-可恢复环境使用受检异常-程序错误使用运行时异常","children":[]},{"level":3,"title":"Item 71: 避免不必要地使用受检异常","slug":"item-71-避免不必要地使用受检异常","link":"#item-71-避免不必要地使用受检异常","children":[]},{"level":3,"title":"Item 72: 尽量使用标准异常","slug":"item-72-尽量使用标准异常","link":"#item-72-尽量使用标准异常","children":[]},{"level":3,"title":"Item 73: 抛出符合抽象层级的异常","slug":"item-73-抛出符合抽象层级的异常","link":"#item-73-抛出符合抽象层级的异常","children":[]},{"level":3,"title":"Item 74: 文档化每个方法抛出的所有异常","slug":"item-74-文档化每个方法抛出的所有异常","link":"#item-74-文档化每个方法抛出的所有异常","children":[]},{"level":3,"title":"Item 75: 在详细信息中包含故障捕获信息","slug":"item-75-在详细信息中包含故障捕获信息","link":"#item-75-在详细信息中包含故障捕获信息","children":[]},{"level":3,"title":"Item 76: 尽力保证故障原子性","slug":"item-76-尽力保证故障原子性","link":"#item-76-尽力保证故障原子性","children":[]},{"level":3,"title":"Item 77: 不要忽略异常","slug":"item-77-不要忽略异常","link":"#item-77-不要忽略异常","children":[]}]},{"level":2,"title":"并发","slug":"并发","link":"#并发","children":[{"level":3,"title":"Item 78: 并行化对共享可变对象的访问操作","slug":"item-78-并行化对共享可变对象的访问操作","link":"#item-78-并行化对共享可变对象的访问操作","children":[]},{"level":3,"title":"Item 79: 避免过度同步","slug":"item-79-避免过度同步","link":"#item-79-避免过度同步","children":[]},{"level":3,"title":"Item 80: 使用线程池, 任务池和流替代线程","slug":"item-80-使用线程池-任务池和流替代线程","link":"#item-80-使用线程池-任务池和流替代线程","children":[]},{"level":3,"title":"Item 81: 使用并发工具代替 wait 和 notify","slug":"item-81-使用并发工具代替-wait-和-notify","link":"#item-81-使用并发工具代替-wait-和-notify","children":[]},{"level":3,"title":"Item 82: 文档化线程安全情况","slug":"item-82-文档化线程安全情况","link":"#item-82-文档化线程安全情况","children":[]},{"level":3,"title":"Item 83: 谨慎使用懒加载","slug":"item-83-谨慎使用懒加载","link":"#item-83-谨慎使用懒加载","children":[]},{"level":3,"title":"Item 84: 不要依靠线程调度器","slug":"item-84-不要依靠线程调度器","link":"#item-84-不要依靠线程调度器","children":[]}]},{"level":2,"title":"序列化","slug":"序列化","link":"#序列化","children":[{"level":3,"title":"Item 85: 优先使用 Java 序列化的替代方案","slug":"item-85-优先使用-java-序列化的替代方案","link":"#item-85-优先使用-java-序列化的替代方案","children":[]},{"level":3,"title":"Item 86: 谨慎实现 Serializable 接口","slug":"item-86-谨慎实现-serializable-接口","link":"#item-86-谨慎实现-serializable-接口","children":[]},{"level":3,"title":"Item 87: 使用自定义序列化格式","slug":"item-87-使用自定义序列化格式","link":"#item-87-使用自定义序列化格式","children":[]},{"level":3,"title":"Item 88: 防御性地编写 readObject 方法","slug":"item-88-防御性地编写-readobject-方法","link":"#item-88-防御性地编写-readobject-方法","children":[]},{"level":3,"title":"Item 89: 优先使用枚举类型进行实例控制","slug":"item-89-优先使用枚举类型进行实例控制","link":"#item-89-优先使用枚举类型进行实例控制","children":[]},{"level":3,"title":"Item 90: 考虑序列化代理而不是序列化实例","slug":"item-90-考虑序列化代理而不是序列化实例","link":"#item-90-考虑序列化代理而不是序列化实例","children":[]}]},{"level":2,"title":"结语","slug":"结语","link":"#结语","children":[]}],"git":{"createdTime":1695732846000,"updatedTime":1700244944000,"contributors":[{"name":"Riicarus","email":"riicarus.acc@gmail.com","commits":27}]},"readingTime":{"minutes":151.7,"words":45511},"filePathRelative":"posts/Java/CodeSpecification/EffectiveJava.md","localizedDate":"2023年9月26日","excerpt":"<h1> Effective Java</h1>\\n<p><strong>本文中, 英文部分均来自于原文摘抄, 如果想要更好的理解和阅读体验, 请不要忽略英文引用!</strong></p>\\n<p><em>Effective Java</em> 这本书作为 Java 编程思想和范式的\\"集大成者\\", 需要很深的 Java 编程功底. 我在阅读时也感受到很多没有了解过的东西, 尤其是读英文原著, 感觉一些部分的理解尚且非常浅薄, 尤以 Stream API 的部分为甚.</p>\\n<p>现在只是第一遍阅读这本书的原版, 只在博客中做粗略的记录和思考. 在读完第一遍之后, 会再次进行巩固和更新.</p>","autoDesc":true}');export{e as data};
