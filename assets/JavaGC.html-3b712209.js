const e=JSON.parse('{"key":"v-3317f515","path":"/posts/Java/JVM/JavaGC.html","title":"Java GC","lang":"zh-CN","frontmatter":{"date":"2023-03-29T00:00:00.000Z","category":["Java","JVM"],"tag":["Java","JVM","GC"],"description":"Java GC GC 要解决的任务: 哪些内存需要回收? 什么时候回收? 怎么回收? 垃圾判定算法 垃圾判定算法主要包括两种, 引用计数法和可达性分析算法. 引用计数法 创建的每一个对象都包含一个引用计数器, 用于记录自身的引用情况. 当一个指针指向当前对象时, 引用计数器 +1. Object obj = new Object();","head":[["meta",{"property":"og:url","content":"https://riicarus.github.io/posts/Java/JVM/JavaGC.html"}],["meta",{"property":"og:site_name","content":"Riicarus"}],["meta",{"property":"og:title","content":"Java GC"}],["meta",{"property":"og:description","content":"Java GC GC 要解决的任务: 哪些内存需要回收? 什么时候回收? 怎么回收? 垃圾判定算法 垃圾判定算法主要包括两种, 引用计数法和可达性分析算法. 引用计数法 创建的每一个对象都包含一个引用计数器, 用于记录自身的引用情况. 当一个指针指向当前对象时, 引用计数器 +1. Object obj = new Object();"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://riicarus.github.io/"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-09-11T01:38:36.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"Java GC"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"JVM"}],["meta",{"property":"article:tag","content":"GC"}],["meta",{"property":"article:published_time","content":"2023-03-29T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-09-11T01:38:36.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java GC\\",\\"image\\":[\\"https://riicarus.github.io/\\"],\\"datePublished\\":\\"2023-03-29T00:00:00.000Z\\",\\"dateModified\\":\\"2023-09-11T01:38:36.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"垃圾判定算法","slug":"垃圾判定算法","link":"#垃圾判定算法","children":[{"level":3,"title":"引用计数法","slug":"引用计数法","link":"#引用计数法","children":[]},{"level":3,"title":"可达性分析算法","slug":"可达性分析算法","link":"#可达性分析算法","children":[]},{"level":3,"title":"对象的 finalization 机制","slug":"对象的-finalization-机制","link":"#对象的-finalization-机制","children":[]}]},{"level":2,"title":"垃圾回收算法","slug":"垃圾回收算法","link":"#垃圾回收算法","children":[{"level":3,"title":"标记-清除法","slug":"标记-清除法","link":"#标记-清除法","children":[]},{"level":3,"title":"复制算法","slug":"复制算法","link":"#复制算法","children":[]},{"level":3,"title":"标记-整理算法","slug":"标记-整理算法","link":"#标记-整理算法","children":[]},{"level":3,"title":"分代清除策略","slug":"分代清除策略","link":"#分代清除策略","children":[]},{"level":3,"title":"分区收集策略","slug":"分区收集策略","link":"#分区收集策略","children":[]}]},{"level":2,"title":"STW","slug":"stw","link":"#stw","children":[{"level":3,"title":"为什么 GC 要 STW","slug":"为什么-gc-要-stw","link":"#为什么-gc-要-stw","children":[]},{"level":3,"title":"STW 带来的问题","slug":"stw-带来的问题","link":"#stw-带来的问题","children":[]}]},{"level":2,"title":"GC 类型划分","slug":"gc-类型划分","link":"#gc-类型划分","children":[]},{"level":2,"title":"安全区域和安全点","slug":"安全区域和安全点","link":"#安全区域和安全点","children":[{"level":3,"title":"安全点","slug":"安全点","link":"#安全点","children":[]},{"level":3,"title":"安全区域","slug":"安全区域","link":"#安全区域","children":[]}]},{"level":2,"title":"GC 收集器","slug":"gc-收集器","link":"#gc-收集器","children":[{"level":3,"title":"GC 收集器影响的堆空间","slug":"gc-收集器影响的堆空间","link":"#gc-收集器影响的堆空间","children":[]},{"level":3,"title":"GC 相关术语","slug":"gc-相关术语","link":"#gc-相关术语","children":[]},{"level":3,"title":"Java GC 收集器","slug":"java-gc-收集器","link":"#java-gc-收集器","children":[]},{"level":3,"title":"分代 GC 收集器","slug":"分代-gc-收集器","link":"#分代-gc-收集器","children":[]},{"level":3,"title":"分区收集器","slug":"分区收集器","link":"#分区收集器","children":[]}]}],"git":{"createdTime":1680060873000,"updatedTime":1694396316000,"contributors":[{"name":"Riicarus","email":"riicarus.acc@gmail.com","commits":10}]},"readingTime":{"minutes":19.78,"words":5933},"filePathRelative":"posts/Java/JVM/JavaGC.md","localizedDate":"2023年3月29日","excerpt":"<h1> Java GC</h1>\\n<p>GC 要解决的任务:</p>\\n<ul>\\n<li>哪些内存需要回收?</li>\\n<li>什么时候回收?</li>\\n<li>怎么回收?</li>\\n</ul>\\n<h2> 垃圾判定算法</h2>\\n<p>垃圾判定算法主要包括两种, <strong>引用计数法</strong>和<strong>可达性分析算法</strong>.</p>\\n<h3> 引用计数法</h3>\\n<p>创建的每一个对象都包含一个引用计数器, 用于记录自身的引用情况. 当一个指针指向当前对象时, 引用计数器 <code>+1</code>.</p>\\n<div class=\\"language-java line-numbers-mode\\" data-ext=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token class-name\\">Object</span> obj <span class=\\"token operator\\">=</span> <span class=\\"token keyword\\">new</span> <span class=\\"token class-name\\">Object</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{e as data};
