import{_ as o,V as d,W as c,$ as l,X as e,Y as a}from"./framework-c6791857.js";const i={},s=l('<h1 id="mysql-索引" tabindex="-1"><a class="header-anchor" href="#mysql-索引" aria-hidden="true">#</a> MySQL 索引</h1><blockquote><p>索引是影响数据库性能的一大部分, 也是面试很容易问到的方向. 这里记录 MySQL 索引相关的问题.</p></blockquote><h2 id="什么是索引" tabindex="-1"><a class="header-anchor" href="#什么是索引" aria-hidden="true">#</a> 什么是索引?</h2><p>索引是一种数据结构, 合理利用可以提高数据库的查询效率. 可以将索引类比为书的目录, 用于快速定位想要查找的位置.</p><p>索引一般存储在磁盘的文件中, 占用物理空间.</p><p>索引不能过多, 索引越多, 对数据库的插入和更新功能影响就越大.</p><h2 id="mysql-索引的类型" tabindex="-1"><a class="header-anchor" href="#mysql-索引的类型" aria-hidden="true">#</a> MySQL 索引的类型</h2><p>索引可以从几个方面分类:</p><ul><li>数据结构</li><li>物理存储</li><li>逻辑</li></ul><p>在数据结构方面, 索引包括如下类型:</p>',10),n=e("ul",null,[e("li",null,[a("B+ 树索引: 所有的数据存储在叶子节点, 复杂度 "),e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("mi",null,"O"),e("mo",{stretchy:"false"},"("),e("mi",null,"l"),e("mi",null,"o"),e("mi",null,"g"),e("mi",null,"n"),e("mo",{stretchy:"false"},")")]),e("annotation",{encoding:"application/x-tex"},"O(log n)")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),e("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),e("span",{class:"mopen"},"("),e("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),e("span",{class:"mord mathnormal"},"o"),e("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),e("span",{class:"mord mathnormal"},"n"),e("span",{class:"mclose"},")")])])]),a(", 适用于范围查询.")]),e("li",null,[a("Hash 索引: 适用于等值查询, 检索效率高, 复杂度 "),e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("mi",null,"O"),e("mo",{stretchy:"false"},"("),e("mn",null,"1"),e("mo",{stretchy:"false"},")")]),e("annotation",{encoding:"application/x-tex"},"O(1)")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),e("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),e("span",{class:"mopen"},"("),e("span",{class:"mord"},"1"),e("span",{class:"mclose"},")")])])]),a(".")]),e("li",null,"全文索引: 适用于文本类型."),e("li",null,"R-Tree 索引: 适用于 GIS 类型数据.")],-1),t=l('<p>在物理存储方面:</p><ul><li>聚集索引: 以<strong>主键</strong>创建的索引, 叶子节点中保存的是表中的完整数据.</li><li>非聚集索引: 以<strong>非主键</strong>创建的索引, 叶子节点中保存的是主键和索引列.</li></ul><p>在逻辑方面:</p><ul><li>主键索引: 特殊的唯一索引, 不允许空值.</li><li>唯一索引: 索引列中的值必须是唯一的, 但是允许空值.</li><li>普通索引: MySQL 基本索引类型, 允许空值和重复值.</li><li>联合索引: 多个字段创建的索引, 遵循最左前缀原则.</li><li>空间索引: 遵循 OpenGIS 几何数据模型规则.</li></ul><h2 id="索引的优缺点" tabindex="-1"><a class="header-anchor" href="#索引的优缺点" aria-hidden="true">#</a> 索引的优缺点?</h2><p>优点:</p><ul><li>加快查询速度.</li><li>唯一索引保证插入数据唯一性.</li></ul><p>缺点:</p><ul><li>索引的创建和维护都需要耗费时间.</li><li>索引要占用一定的物理空间.</li><li>对表中元素进行增删改, 需要动态维护索引.</li></ul><h2 id="为什么使用-b-树-而不是二叉树" tabindex="-1"><a class="header-anchor" href="#为什么使用-b-树-而不是二叉树" aria-hidden="true">#</a> 为什么使用 B+ 树, 而不是二叉树?</h2><blockquote><p>思考方向: 查询速度, 查询稳定性, 存储数据数量, IO 次数.</p></blockquote><p>普通二叉树由于不稳定, 可能会退化为链表, 相当于全表扫描, 肯定不会使用.</p><p>平衡二叉树一个节点只存储一个数据, 树高度很高, 磁盘 IO 次数多, 查询效率低(<strong>决定数据库查询效率的一大因素就是磁盘 IO 次数</strong>).</p><p>对于 B 树来说, 它的非叶子节点不仅会保存键值对, 也会保存数据, 这样的话保存键值的空间就会减少, 树的阶数也更小, 相对于 B+ 树来说就会更高瘦, 磁盘 IO 次数更多.</p><blockquote><p>InnoDB 每页默认大小为 16KB, 以页为单位进行数据读写.</p></blockquote><p>同时, B+ 树的所有数据都保存在叶子节点, 并且叶子节点的数据是被按照顺序排列的双向链表连接的, 非常有利于各种查找操作.</p><blockquote><p>扩展: 参考 InnoDB 数据页, 页分裂机制...</p></blockquote><h2 id="hash-索引和-b-树索引的区别" tabindex="-1"><a class="header-anchor" href="#hash-索引和-b-树索引的区别" aria-hidden="true">#</a> Hash 索引和 B+ 树索引的区别?</h2><ul><li>B+ 树支持范围查询, Hash 索引不行.</li><li>B+ 树支持联合索引的最左前缀原则, Hash 索引不行.</li><li>B+ 树支持 <code>ORDER BY</code> 排序, Hash 索引不行.</li><li>B+ 树在使用 <code>LIKE</code> 进行模糊查询时, 可以进行优化, 而 Hash 索引不支持模糊查询.</li><li>Hash 索引在等值查询上效率更高, 前提是 Hash 冲突少.</li></ul><h2 id="什么是回表-如何减少回表" tabindex="-1"><a class="header-anchor" href="#什么是回表-如何减少回表" aria-hidden="true">#</a> 什么是回表, 如何减少回表?</h2><p>如果要查询的数据在索引树中找不到, 就会拿到<code>主键 id</code>, 回到主键索引树中获取, 这就叫回表.<br> 如: 我们有一个关于 <code>student_id</code> 的索引, 但是 SQL 语句为 <code>SELECT * FROM user WHERE student_id = &quot;2020080907004&quot;</code>, 此时索引为非聚簇索引, 只保存了<code>主键 id</code> 和 <code>student_id</code> 两个数据, 不能满足 <code>SELECT *</code> 的需求, 就会拿着 <code>主键 id</code> 去主键索引树中进行查找.</p><p>减少回表的方式:<br> 如果要查找的数据组相对固定, 可以为其建立<strong>联合索引</strong>, 这样保证要查找的数据在对应的索引树中. 如: 在用户登录时, 我们需要查找用户的 <code>student_id</code>, <code>password</code>, <code>salt</code>, 就可以新建一个结构为 <code>(student_id, password, salt)</code> 的联合索引(注意最左前缀原则), 这样就不不会产生回表操作, 只是会多一些索引树占用空间.</p><h2 id="覆盖索引" tabindex="-1"><a class="header-anchor" href="#覆盖索引" aria-hidden="true">#</a> 覆盖索引</h2><p>其实覆盖索引就是上一个问题的解决方案. 如果 <code>SELECT</code> 需要的数据列只需要从索引中就能取得, 那么就不需要回表, 也就是说<strong>查询列被所建的索引覆盖</strong>.</p><h2 id="索引的最左前缀原则" tabindex="-1"><a class="header-anchor" href="#索引的最左前缀原则" aria-hidden="true">#</a> 索引的最左前缀原则</h2><p>最左前缀原则用于联合索引中, 很好的提高了索引的复用能力. 如: 我们建立了联合索引 <code>(a, b, c)</code>, 相当于建立了 <code>(a)</code>, <code>(a, b)</code>, <code>(a, b, c)</code> 三个索引. 在字符串中, 最左前缀可以是字符串索引的最左 N 个字符.</p><p>在联合索引树中查找时, 会优先匹配左侧的索引字段, 然后逐步向右匹配索引字段, 所以要注意建立联合索引的字段顺序和 SQL 语句中编写的查询字段的顺序.</p><blockquote><p>联合索引的最左前缀匹配原则中, MySQL 会向右一直匹配到遇到范围查询为止. 如: 有联合索引 <code>(a, b, c, d)</code>, SQL 语句为 <code>a = 1 AND b = 2 AND c &gt; 3 AND d = 4</code>, 此时按照联合索引的最左前缀匹配, 只会匹配到 <code>(a, b, c)</code>, <code>d</code> 用不到索引; 如果想要 <code>d</code> 用上索引, 就需要将索引建为 <code>(a, b, d, c)</code>(保证 <code>c</code> 在最后即可), 此时就可以使 <code>a, b, c, d</code> 都用上索引.</p></blockquote><h2 id="索引下推" tabindex="-1"><a class="header-anchor" href="#索引下推" aria-hidden="true">#</a> 索引下推</h2><p>这是 MySQL 5.6 之后的功能, 也是针对联合索引进行的优化. 如: 我们有 <code>(name, age)</code> 的联合索引, 在 5.6 之前, 在联合索引树找到 <code>name</code> 对应的的数据之后, 会拿到其<code>主键 id</code>, 然后<strong>回表</strong>匹配其他字段, 这样效率很低.<br> 因此, 在 5.6 之后, 提出了索引下推的优化, 当找到 <code>name</code> 对应的数据之后, 会继续在联合索引树中对 <code>age</code> (其余的联合索引字段)进行筛选, 最后才进行回表, 减少回表带来的性能损失.</p><h2 id="索引失效条件" tabindex="-1"><a class="header-anchor" href="#索引失效条件" aria-hidden="true">#</a> 索引失效条件</h2><ul><li>查询条件包含 <code>OR</code>, 索引可能失效.</li><li>如果字段类型是字符串, 在使用 <code>WHERE</code> 时, 一定要用引号括起来, 否则索引失效.</li><li><code>LIKE</code> 可能会导致索引失效.</li><li>联合索引中, 查询时的条件列不遵循最左前缀原则, 索引失效(必须要左侧字段用上索引, 右侧元素才能正常使用索引, 并且左侧元素不能是范围查询).</li><li>在索引列上使用 MySQL 内置函数, 索引失效.</li><li>对索引列进行计算, 索引失效.</li><li>对索引字段使用 <code>!=</code>, <code>&lt;&gt;</code>, <code>not in</code>, 索引可能失效.</li><li>对索引字段使用 <code>is null</code> 或 <code>is not null</code>, 索引可能失效.</li><li>左连接查询或右连接查询关联的字段编码格式不同, 索引失效.</li><li>MySQL 估计走全表要比走索引快, 就不用索引.</li></ul><h2 id="大表如何添加索引" tabindex="-1"><a class="header-anchor" href="#大表如何添加索引" aria-hidden="true">#</a> 大表如何添加索引?</h2><p><strong>在添加索引时, 会对表加锁</strong>, 可能会影响效率或出现故障. 因此, 我们采用如下方案:</p><ol><li>创建一张和原表 <code>A</code> 相同数据结构的新表 <code>B</code>;</li><li>在新表 <code>B</code> 添加需要的索引;</li><li>将原表 <code>A</code> 数据导入 新表 <code>B</code>;</li><li>将新表 <code>B</code> 重命名为原表 <code>A</code> 的表名, 原表 <code>A</code> 改为别的名字.</li></ol><h2 id="如何判断语句是否走索引" tabindex="-1"><a class="header-anchor" href="#如何判断语句是否走索引" aria-hidden="true">#</a> 如何判断语句是否走索引?</h2><p>使用 <code>explain</code> 语句.</p><h2 id="建立索引的原则" tabindex="-1"><a class="header-anchor" href="#建立索引的原则" aria-hidden="true">#</a> 建立索引的原则</h2><ol><li>一定要遵循最左前缀原则.</li><li>针对 (1), <code>=</code> 和 <code>IN</code> 可以乱序.</li><li>选择区分度高的列作为索引. 区分度公式: <code>count(distinct col)/count(*)</code></li><li>索引列不能参与计算. 尽量计算参数, 不要计算索引列, 否则会导致对全表元素的计算, 相当于全表扫描.</li><li>尽量扩展索引, 不要新建索引. 如: 表中已有 <code>a</code> 的索引, 现在要加上 <code>(a, b)</code> 的索引, 只需要修改原来的索引即可.</li></ol>',39),r=[s,n,t];function h(p,u){return d(),c("div",null,r)}const b=o(i,[["render",h],["__file","MySQL_Index.html.vue"]]);export{b as default};
