import{_ as n,V as o,W as s,X as e,Y as c,Z as d,$ as r,F as i}from"./framework-c6791857.js";const t="/assets/ThreadPoolExecutorUML-403ef11f.png",l="/assets/ThreadPoolExecutorOperatingMechanism-988171f3.png",p="/assets/ThreadPoolExecutorLifeCircle-664c63ec.png",u="/assets/ThreadPoolGetTask-bd90197d.png",k="/assets/ThreadPoolWorkerGetTaskProcess-6dd6e539.png",h="/assets/ThreadPoolWorkerThreadIncrement-dd8803d4.png",m="/assets/ThreadPoolWorkerExecuteTask-2f5561a6.png",g={},f=r('<h1 id="线程池" tabindex="-1"><a class="header-anchor" href="#线程池" aria-hidden="true">#</a> 线程池</h1><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><h3 id="什么是线程池" tabindex="-1"><a class="header-anchor" href="#什么是线程池" aria-hidden="true">#</a> 什么是线程池</h3><p>线程池是一种基于池化思想管理线程的工具, 通常出现在多线程服务器中.</p><p>线程池维护多个线程, 等待管理者分配可以并发执行的任务. 这样一方面<strong>避免了处理任务时创建和销毁线程带来的开销</strong>, 另一方面<strong>避免了线程数量膨胀带来的过度调度问题, 保证了对内核的充分利用</strong>.</p><p>使用线程池的好处如下:</p><ol><li>降低资源消耗;</li><li>提高相应速度;</li><li>提高线程的可管理性;</li><li>提供更多强大功能;</li></ol><h2 id="线程池的核心设计" tabindex="-1"><a class="header-anchor" href="#线程池的核心设计" aria-hidden="true">#</a> 线程池的核心设计</h2><h3 id="总体设计" tabindex="-1"><a class="header-anchor" href="#总体设计" aria-hidden="true">#</a> 总体设计</h3><p>Java 线程池的核心实现类是 <code>ThreadPoolExecutor</code>, 下面是其继承关系图:</p><figure><img src="'+t+'" alt="ThreadPoolExecutorUML" tabindex="0" loading="lazy"><figcaption>ThreadPoolExecutorUML</figcaption></figure><p>顶层接口 <code>Executor</code> 提供的是一种思想: 将任务提交和任务执行解耦. 用户无需关心线程的创建和调度, 只需要提供 <code>Runnable</code> 对象, 将任务的运行逻辑提交到执行器(<code>Executor</code>)中, 由执行器来完成线程的调度和任务执行.</p><p><code>ExecutorService</code> 接口增加了一些功能:</p><ol><li>扩充执行任务的能力, 补充可以为一个或者一批异步任务生成 <code>Future</code> 的方法;</li><li>提供了管控线程池的方法, 比如停止线程池的运行;</li></ol><p><code>AbstractExecutorService</code> 则是上层的抽象类, 将任务执行的流程串联了起来, 保证下层只需要关注一个执行任务的方法即可.</p><p><code>ThreadPoolExecutor</code> 实现最复杂的运行部分, 一方面维护自身的生命周期, 一方面同时管理线程和任务.</p><p>如下是 <code>ThreadPoolExecutor</code> 的运行机制:</p><figure><img src="'+l+`" alt="ThreadPoolExecutorOperatingMechanism" tabindex="0" loading="lazy"><figcaption>ThreadPoolExecutorOperatingMechanism</figcaption></figure><p>线程池在内部构建了一个生产者-消费者模型, 用于实现线程和任务的解耦, 可以更好的缓冲任务, 复用线程. 线程池的运行主要分为两部分: 任务管理和线程管理.<br> 任务管理部分充当生产者的角色, 任务被提交后, 线程池会判断该任务后续的流转:</p><ol><li>直接申请线程执行任务;</li><li>缓冲到队列中等待线程执行;</li><li>使用拒绝策略;</li></ol><p>线程管理部分是消费者, 根据任务请求进行线程分配, 线程执行完任务之后会继续获取新的任务进行执行, 当线程拿不到任务的时候, 会被回收.</p><h3 id="生命周期管理" tabindex="-1"><a class="header-anchor" href="#生命周期管理" aria-hidden="true">#</a> 生命周期管理</h3><p>线程池运行的状态不是用户显式设置的, 而是伴随着线程池的执行, 由内部进行维护. 线程池内部使用一个变量维护两个值: 运行状态(<code>runState</code>) 和 线程数量(<code>workerCount</code>):</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token constant">RUNNING</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在 <code>ctl</code> 中, 高 3 位保存 <code>runState</code>, 低 29 位保存 <code>workerCount</code>.</p><p><code>ThreadPoolExecutor</code> 运行状态有 5 种:</p><ol><li><code>RUNNING</code>: 能接受新提交的任务, 并且也能处理阻塞队列中的任务;</li><li><code>SHUTDOWN</code>: 关闭状态, 不再接收新提交的任务, 但可以继续处理阻塞队列中已保存的任务;</li><li><code>STOP</code>: 不能接收新任务, 也不会处理队列中的任务, 会中断正在处理任务的线程;</li><li><code>TIDYING</code>: 所有的任务都已经终止, <code>workerCount</code> 为 0;</li><li><code>TERMINATED</code>: <code>terminated()</code> 方法执行完后, 进入此状态;</li></ol><p>生命周期转化如下图:</p><figure><img src="`+p+'" alt="ThreadPoolExecutorLifeCircle" tabindex="0" loading="lazy"><figcaption>ThreadPoolExecutorLifeCircle</figcaption></figure><h3 id="任务执行机制" tabindex="-1"><a class="header-anchor" href="#任务执行机制" aria-hidden="true">#</a> 任务执行机制</h3><h4 id="任务调度" tabindex="-1"><a class="header-anchor" href="#任务调度" aria-hidden="true">#</a> 任务调度</h4><p>任务调度是线程池的主要入口, 当用户提交了一个任务, 接下来任务如何执行都由任务调度决定. 这一部分是<strong>线程池的核心机制</strong>.</p><p>首先, 所有任务的调度都是由 <code>execute()</code> 方法完成的, 这部分完成的工作是: 检查现在线程池的运行状态/运行线程数/运行策略, 决定接下来的执行流程, 是直接申请线程执行, 还是放入缓冲队列, 抑或是直接拒绝.</p><p>执行过程如下:</p><ol><li>首先检查线程池运行状态, 如果不是 <code>RUNNING</code>, 则直接拒绝, 线程池要保证在 <code>RUNNING</code> 状态下完成任务;</li><li>如果 <code>workerCount</code> &lt; <code>corePoolSize</code>, 则创建并启动一个线程来执行新提交的任务;</li><li>如果 <code>workerCount</code> &gt;= <code>corePoolSize</code>, 且线程池的阻塞队列未满, 将任务添加到缓冲队列中;</li><li>如果 <code>workerCount</code> &gt;= <code>corePoolSize</code> 并且 <code>workerCount</code> &lt; <code>maximumPoolSize</code>, 且线程池内的缓冲队列已满, 则创建并启动一个线程来执行新提交的任务;</li><li>如果 <code>workerCount</code> &gt;= <code>maximumPoolSize</code>, 并且线程池内的阻塞队列已满, 则根据拒绝策略来处理, 默认为拒绝并抛出异常;</li></ol><h4 id="任务缓冲" tabindex="-1"><a class="header-anchor" href="#任务缓冲" aria-hidden="true">#</a> 任务缓冲</h4><p>任务缓冲是线程池能够管理任务的核心部分.</p><p>使用不同的队列可以实现不同的任务存取策略:</p><ol><li><code>ArrayBlockingQueue</code>: 一个数组实现的有界队列, 按照 FIFO 规则对元素排序. 支持公平锁和非公平锁;</li><li><code>LinkedBlockingQueue</code>: 一个链表实现的有界队列, 按照 FIFO 规则对元素排序. 默认长度为 <code>Integer.MAX_VALUE</code>, 由 OOM 风险;</li><li><code>PriorityBlockingQueue</code>: 一个支持线程优先级排序的无界队列, 默认自然序进行排序, 也可以自定义实现 <code>compareTo()</code> 排序方法, 不能保证同优先级元素的顺序;</li><li><code>DelayQueue</code>: 一个实现 <code>PriorityBlockingQueue</code> 的可延迟获取的无界队列, 创建元素时, 可以指定多久才可以从队列中获取当前元素. 只有延时期满后才可以从队列中获取元素;</li><li><code>SynchronousQueue</code>: 一个不存储元素的队列, 每个 <code>put</code> 操作都需要等待 <code>take</code>, 否则不能添加元素. 支持公平锁和非公平锁;</li><li><code>LinkedTransferQueue</code>: 一个由链表组成的无界阻塞队列, 只是多了 <code>transfer()</code> 和 <code>tryTransfer()</code> 方法;</li><li><code>LinkedBlockingDeque</code>: 一个链表组成的双向阻塞队列, 头尾都可以添加/移除元素, 降低并发的锁竞争.</li></ol><h4 id="任务获取" tabindex="-1"><a class="header-anchor" href="#任务获取" aria-hidden="true">#</a> 任务获取</h4><p>线程需要从任务缓冲模块获取任务来执行, 这部分策略由 <code>getTask()</code> 实现, 流程如下:</p><figure><img src="'+u+`" alt="ThreadPoolGetTask" tabindex="0" loading="lazy"><figcaption>ThreadPoolGetTask</figcaption></figure><p><code>getTask()</code> 需要平衡当前线程池中的线程数, 如果认为线程池中线程数量过多, 就返回 <code>null</code>. 工作线程 <code>Worker</code> 会不断获取新任务执行, 如果没有可执行任务 就会被回收.</p><h4 id="任务拒绝" tabindex="-1"><a class="header-anchor" href="#任务拒绝" aria-hidden="true">#</a> 任务拒绝</h4><p>任务拒绝是线程池保护模块的重要部分, 当任务的缓冲队列已满, 并且 <code>workerCount</code> &gt;= <code>maximumPoolSize</code> 时, 就会开始拒绝所有任务, 采取任务拒绝策略;</p><p>拒绝策略是一个接口, 设计如下:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> executor<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>JDK 提供了四种拒绝策略:</p><ol><li><code>AbortPolicy</code>: 默认拒绝策略, 丢弃任务并且抛出异常;</li><li><code>DiscordPolicy</code>: 丢弃任务, 但是不抛出异常;</li><li><code>DiscordOldestPolicy</code>: 丢弃队列最前面的任务, 然后重新提交被拒绝的任务;</li><li><code>CallerRunsPolicy</code>: 由调用线程(提交任务的线程)处理该任务;</li></ol><h3 id="工作线程管理" tabindex="-1"><a class="header-anchor" href="#工作线程管理" aria-hidden="true">#</a> 工作线程管理</h3><h4 id="工作线程" tabindex="-1"><a class="header-anchor" href="#工作线程" aria-hidden="true">#</a> 工作线程</h4><p>线程池为了掌握线程的状态并且维护线程的生命周期, 设计了线程池的工作线程 <code>worker</code>. 定义如下:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token comment">//Worker持有的线程</span>
    <span class="token keyword">final</span> <span class="token class-name">Thread</span> thread<span class="token punctuation">;</span>
    <span class="token comment">//初始化的任务，可以为null</span>
    <span class="token class-name">Runnable</span> firstTask<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>thread</code> 是调用构造方法时, 通过 <code>ThreadFactory</code> 创建的线程, 可以用来执行任务.<br><code>firstTask</code> 是创建时传入的第一个任务, 可以为 <code>null</code>. 如果值是非空的, 工作线程就会在启动初期立即执行这个任务, 也就是对应核心线程创建时的情况; 如果为空值, 就会创建一个线程去执行任务列表中的任务, 也就是非核心线程的创建.</p><figure><img src="`+k+'" alt="ThreadPoolWorkerGetTaskProcess" tabindex="0" loading="lazy"><figcaption>ThreadPoolWorkerGetTaskProcess</figcaption></figure><p>线程池需要管理线程的生命周期, 需要在线程长时间不运行时进行回收. 线程池使用一张 <code>hashMap</code> 去维护线程的引用, 这样可以通过添加引用/移除引用这样的操作来控制线程的生命周期. 最重要的事就是如何判断这个线程是否运行.</p><p><code>Worker</code> 通过继承 <code>AbstractQueueSynchronizer</code> 来实现独占锁这个功能, 而不是使用可重入锁, 目的是使用不可重入的特性来反映当前线程的执行状态.</p><ol><li><code>lock</code> 方法一旦获取了独占锁, 就表示当前线程正在执行任务;</li><li>如果正在执行任务, 则不应该中断线程;</li><li>如果不是独占锁的状态, 也就是处于空闲状态, 这时候可以对线程进行中断;</li><li>线程池在执行 <code>shutdown()</code> 或 <code>tryTerminate()</code> 方法时会调用 <code>interruptIdleWorkers()</code> 方法来中断空闲的线程, <code>interruptIdleWorkers()</code> 会调用 <code>tryLock()</code> 方法来判断线程池中的线程是否处于空闲状态; 如果是空闲状态就可以安全回收;</li></ol><h4 id="工作线程增加" tabindex="-1"><a class="header-anchor" href="#工作线程增加" aria-hidden="true">#</a> 工作线程增加</h4><p>通过 <code>addWorker()</code> 方法来增加工作线程, 不考虑线程池在哪个阶段增加的线程, 仅仅完成增加线程并使它执行, 最后返回是否成功的结果.</p><figure><img src="'+h+`" alt="ThreadPoolWorkerThreadIncrement" tabindex="0" loading="lazy"><figcaption>ThreadPoolWorkerThreadIncrement</figcaption></figure><h4 id="工作线程回收" tabindex="-1"><a class="header-anchor" href="#工作线程回收" aria-hidden="true">#</a> 工作线程回收</h4><p>线程池中线程的销毁依赖 JVM 的垃圾回收, 线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收. 线程池只需要消除对线程的引用即可使其被回收.</p><p><code>Worker</code> 被创建出来后, 就会不断地进行轮询并且获取任务去执行, <strong>核心线程可以无限等待获取任务, 非核心线程要限时获取任务</strong>. 当 <code>Worker</code> 无法获取到任务时, 就会结束循环, 并且主动将自己在线程池中的引用消除.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//执行任务</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token comment">//获取不到任务时，主动回收自己</span>
    <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> completedAbruptly<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>线程回收的工作在 <code>processWorkerExit()</code> 方法中完成, 线程池会根据销毁的情景来动态改变自己的状态, 或者平衡线程.</p><h4 id="工作线程执行任务" tabindex="-1"><a class="header-anchor" href="#工作线程执行任务" aria-hidden="true">#</a> 工作线程执行任务</h4><p>在 <code>Worker</code> 类中的 <code>run()</code> 方法调用了 <code>runWorker()</code> 方法来执行任务, <code>runWorker()</code> 方法的执行过程如下:</p><figure><img src="`+m+'" alt="ThreadPoolWorkerExecuteTask" tabindex="0" loading="lazy"><figcaption>ThreadPoolWorkerExecuteTask</figcaption></figure>',69),v=e("p",null,"参考资料:",-1),b={href:"https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html",target:"_blank",rel:"noopener noreferrer"};function x(T,P){const a=i("ExternalLinkIcon");return o(),s("div",null,[f,e("blockquote",null,[v,e("ol",null,[e("li",null,[e("a",b,[c("Java 线程池实现原理及其在美团业务中的实践"),d(a)])])])])])}const _=n(g,[["render",x],["__file","ThreadPool.html.vue"]]);export{_ as default};
