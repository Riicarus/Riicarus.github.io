import{_ as e,V as a,W as i,$ as r}from"./framework-c6791857.js";const d={},o=r('<h1 id="事务" tabindex="-1"><a class="header-anchor" href="#事务" aria-hidden="true">#</a> 事务</h1><h2 id="什么是事务" tabindex="-1"><a class="header-anchor" href="#什么是事务" aria-hidden="true">#</a> 什么是事务?</h2><p>事务通常由一个或者一组 <code>SQL</code> 操作组成, 满足 ACID 原则.</p><h2 id="什么是-acid" tabindex="-1"><a class="header-anchor" href="#什么是-acid" aria-hidden="true">#</a> 什么是 ACID?</h2><p>ACID 原则是关系型数据库必须遵守的原则.<br> ACID 包括:</p><ul><li>Atomicity: 原子性<br> 事务中的操作视作一个整体, 要么全部执行, 要么全部不执行.</li><li>Consistency: 一致性<br> 数据库中的数据只能从一个一致性状态, 转换到另一个一致性状态. 即: 事务中的数据要么都成功更改, 要么都不被更改.</li><li>Isolation: 隔离性<br> 事务之间是独立的, 互不影响. 一个未完成事务不会影响另一个未完成事务.</li><li>Durability: 持久性<br> 事务一旦被提交, 数据更改就会被持久化保存.</li></ul><h2 id="事务的开启与关闭" tabindex="-1"><a class="header-anchor" href="#事务的开启与关闭" aria-hidden="true">#</a> 事务的开启与关闭</h2><ul><li>使用 <code>start transaction</code>, <code>begin</code>, <code>begin work</code> 来开始事务.</li><li>使用 <code>commit</code> 来提交一个事务.</li><li>使用 <code>rollback</code> 来回滚一个事务.</li></ul><h2 id="事务回滚点" tabindex="-1"><a class="header-anchor" href="#事务回滚点" aria-hidden="true">#</a> 事务回滚点</h2><ul><li>使用 <code>savepoint point_name</code> 来定义回滚点.</li><li>使用 <code>rollback to point_name</code> 来回滚事务到回滚点.</li></ul><h2 id="事务隔离级别" tabindex="-1"><a class="header-anchor" href="#事务隔离级别" aria-hidden="true">#</a> 事务隔离级别</h2><ul><li><p>读未提交--脏读问题</p></li><li><p>读已提交--不可重复读问题</p></li><li><p>可重复读(MySQL 默认)--幻读问题</p></li><li><p>串行化</p></li><li><p>脏读: 读取到事务未提交的数据.</p></li><li><p>不可重复读: 读取到其他事务新提交的数据.</p></li><li><p>幻读: 另一个事务在一个事务要处理的数据范围内新增了数据, 并且先于第一个事务提交.</p></li></ul><h3 id="读未提交" tabindex="-1"><a class="header-anchor" href="#读未提交" aria-hidden="true">#</a> 读未提交</h3><p>基于<strong>写互斥锁</strong>实现. 多个事务对同一个数据进行写操作时, 需要先获取互斥锁; 但是读操作不受影响.</p><h3 id="读已提交" tabindex="-1"><a class="header-anchor" href="#读已提交" aria-hidden="true">#</a> 读已提交</h3><p>同样使用<strong>写互斥锁</strong>. 但是对读操作加入了<strong>MVCC</strong>多版本并发控制处理, 在<strong>每次</strong>进行读操作时, 都会创建一个 <code>ReadView</code>, 包含最近一次事务提交的数据版本.</p><h3 id="可重复读" tabindex="-1"><a class="header-anchor" href="#可重复读" aria-hidden="true">#</a> 可重复读</h3><p>同样使用<strong>写互斥锁</strong> + <strong>MVCC</strong>, 但是在一次事务中, 只会在<strong>第一次</strong>读数据时创建 <code>ReadView</code>, 因此之后所有读操作读到的数据都是一致的.</p><h3 id="串行化" tabindex="-1"><a class="header-anchor" href="#串行化" aria-hidden="true">#</a> 串行化</h3><p>使用<strong>表锁</strong>, 让所有事务排队, 同一时间只能由一个事务在进行操作.</p>',20),n=[o];function t(c,h){return a(),i("div",null,n)}const s=e(d,[["render",t],["__file","Transaction.html.vue"]]);export{s as default};
