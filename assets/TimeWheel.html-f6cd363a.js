const e=JSON.parse('{"key":"v-1c9b1892","path":"/posts/Component/TimeWheel.html","title":"TimeWheel","lang":"zh-CN","frontmatter":{"date":"2024-09-12T00:00:00.000Z","category":["组件"],"tag":["组件","时间轮"],"description":"TimeWheel 基本思路 时间轮首先是一个“轮”, 即环形数组. 就像手表一样, 用 buckets[] 代表刻度, 以 tick 为单位递进增加时间, 触发对应 bucket 上的任务, 以此无限循环. 每圈时间轮会经过 interval = tickMs * bucketSize 的时间间隔, 对于超过时间间隔的任务, 基本有两种实现方式----多层时间轮和单层复用时间轮. 多层时间轮通过增加上级时间轮的方式来应对 delay 超过 interval 的情况. 下层时间轮每经过一圈, 就将上层时间轮推进一个 tick. 如果上层时间轮的任务被触发, 就放入到下层时间轮中, 直到在最底层时间轮被触发.","head":[["meta",{"property":"og:url","content":"https://riicarus.github.io/posts/Component/TimeWheel.html"}],["meta",{"property":"og:site_name","content":"Riicarus"}],["meta",{"property":"og:title","content":"TimeWheel"}],["meta",{"property":"og:description","content":"TimeWheel 基本思路 时间轮首先是一个“轮”, 即环形数组. 就像手表一样, 用 buckets[] 代表刻度, 以 tick 为单位递进增加时间, 触发对应 bucket 上的任务, 以此无限循环. 每圈时间轮会经过 interval = tickMs * bucketSize 的时间间隔, 对于超过时间间隔的任务, 基本有两种实现方式----多层时间轮和单层复用时间轮. 多层时间轮通过增加上级时间轮的方式来应对 delay 超过 interval 的情况. 下层时间轮每经过一圈, 就将上层时间轮推进一个 tick. 如果上层时间轮的任务被触发, 就放入到下层时间轮中, 直到在最底层时间轮被触发."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-12T16:20:20.000Z"}],["meta",{"property":"article:tag","content":"组件"}],["meta",{"property":"article:tag","content":"时间轮"}],["meta",{"property":"article:published_time","content":"2024-09-12T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-12T16:20:20.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"TimeWheel\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-09-12T00:00:00.000Z\\",\\"dateModified\\":\\"2024-09-12T16:20:20.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"基本思路","slug":"基本思路","link":"#基本思路","children":[]},{"level":2,"title":"相关组件","slug":"相关组件","link":"#相关组件","children":[]},{"level":2,"title":"设计思路","slug":"设计思路","link":"#设计思路","children":[]}],"git":{"createdTime":1726158020000,"updatedTime":1726158020000,"contributors":[{"name":"Riicarus","email":"riicarus.acc@gmail.com","commits":1}]},"readingTime":{"minutes":3.98,"words":1194},"filePathRelative":"posts/Component/TimeWheel.md","localizedDate":"2024年9月12日","excerpt":"<h1> TimeWheel</h1>\\n<h2> 基本思路</h2>\\n<p>时间轮首先是一个“轮”, 即环形数组. 就像手表一样, 用 <code>buckets[]</code> 代表刻度, 以 <code>tick</code> 为单位递进增加时间, 触发对应 <code>bucket</code> 上的任务, 以此无限循环.</p>\\n<p>每圈时间轮会经过 <code>interval = tickMs * bucketSize</code> 的时间间隔, 对于超过时间间隔的任务, 基本有两种实现方式----多层时间轮和单层复用时间轮.</p>\\n<p>多层时间轮通过增加上级时间轮的方式来应对 <code>delay</code> 超过 <code>interval</code> 的情况. 下层时间轮每经过一圈, 就将上层时间轮推进一个 <code>tick</code>. 如果上层时间轮的任务被触发, 就放入到下层时间轮中, 直到在最底层时间轮被触发.</p>","autoDesc":true}');export{e as data};
